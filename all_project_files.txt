
==============================================
FILE: ./.DS_Store
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./.env.example
==============================================

          1	DB_URL=postgresql://user:pass@localhost:5432/ndne
          2	REDIS_URL=redis://localhost:6379
          3	JWT_SECRET=change-me
          4	PORT=4000
          5	CORS_ORIGINS=http://localhost:5173
          6	KEY_STORAGE_MODE=server
          7	AI_SERVICE_URL=http://agent:5000
          8	DEFAULT_LLM_MODEL=openai/gpt-4o
          9	OPENROUTER_API_KEY=
         10	OPENROUTER_MODELS_ENDPOINT=https://openrouter.ai/api/v1/models
         11	DIGEST_FREQUENCY_HOURS=24
         12	PLAY_MONEY_TREASURY=100000
         13	MAX_MONETARY_NO_CONSENT=500
         14	MODEL_SELECTION_ADMIN_ONLY=true


==============================================
FILE: ./.eslintrc.js
==============================================

          1	module.exports = {
          2	  root: true,
          3	  parser: '@typescript-eslint/parser',
          4	  parserOptions: {
          5	    project: ['./tsconfig.json'],
          6	    tsconfigRootDir: __dirname,
          7	    sourceType: 'module',
          8	  },
          9	  env: {
         10	    browser: true,
         11	    node: true,
         12	    es2021: true,
         13	  },
         14	  plugins: ['@typescript-eslint'],
         15	  extends: [
         16	    'eslint:recommended',
         17	    'plugin:@typescript-eslint/recommended',
         18	    'prettier',
         19	  ],
         20	  rules: {},
         21	};


==============================================
FILE: ./.github/workflows/ci.yml
==============================================

          1	name: CI Pipeline
          2	
          3	on:
          4	  push:
          5	    branches: [main]
          6	  pull_request:
          7	    branches: [main]
          8	
          9	jobs:
         10	  lint:
         11	    name: Lint
         12	    runs-on: ubuntu-latest
         13	    steps:
         14	      - uses: actions/checkout@v3
         15	
         16	      - name: Setup Node.js
         17	        uses: actions/setup-node@v3
         18	        with:
         19	          node-version: '18'
         20	          cache: 'npm'
         21	
         22	      - name: Install dependencies
         23	        run: npm ci
         24	
         25	      - name: Run ESLint
         26	        run: npm run lint
         27	
         28	      - name: Run TypeScript type-check
         29	        run: npm run typecheck
         30	
         31	  test-backend:
         32	    name: Backend Tests
         33	    runs-on: ubuntu-latest
         34	    services:
         35	      postgres:
         36	        image: postgres:15
         37	        env:
         38	          POSTGRES_PASSWORD: postgres
         39	          POSTGRES_USER: postgres
         40	          POSTGRES_DB: ndne_test
         41	        ports:
         42	          - 5432:5432
         43	        options: >-
         44	          --health-cmd pg_isready
         45	          --health-interval 10s
         46	          --health-timeout 5s
         47	          --health-retries 5
         48	      redis:
         49	        image: redis:alpine
         50	        ports:
         51	          - 6379:6379
         52	        options: >-
         53	          --health-cmd "redis-cli ping"
         54	          --health-interval 10s
         55	          --health-timeout 5s
         56	          --health-retries 5
         57	          
         58	    steps:
         59	      - uses: actions/checkout@v3
         60	
         61	      - name: Setup Node.js
         62	        uses: actions/setup-node@v3
         63	        with:
         64	          node-version: '18'
         65	          cache: 'npm'
         66	
         67	      - name: Install dependencies
         68	        run: |
         69	          cd backend
         70	          npm ci
         71	
         72	      - name: Run DB migrations
         73	        run: |
         74	          cd backend
         75	          npx prisma migrate deploy
         76	        env:
         77	          DB_URL: postgresql://postgres:postgres@localhost:5432/ndne_test
         78	          
         79	      - name: Run unit tests
         80	        run: |
         81	          cd backend
         82	          npm test
         83	        env:
         84	          DB_URL: postgresql://postgres:postgres@localhost:5432/ndne_test
         85	          REDIS_URL: redis://localhost:6379
         86	          JWT_SECRET: test-jwt-secret
         87	          NODE_ENV: test
         88	
         89	  test-frontend:
         90	    name: Frontend Tests
         91	    runs-on: ubuntu-latest
         92	    steps:
         93	      - uses: actions/checkout@v3
         94	
         95	      - name: Setup Node.js
         96	        uses: actions/setup-node@v3
         97	        with:
         98	          node-version: '18'
         99	          cache: 'npm'
        100	
        101	      - name: Install dependencies
        102	        run: |
        103	          cd frontend
        104	          npm ci
        105	
        106	      - name: Run tests
        107	        run: |
        108	          cd frontend
        109	          npm test
        110	
        111	  e2e-tests:
        112	    name: End-to-End Tests
        113	    runs-on: ubuntu-latest
        114	    needs: [test-backend, test-frontend]
        115	    services:
        116	      postgres:
        117	        image: postgres:15
        118	        env:
        119	          POSTGRES_PASSWORD: postgres
        120	          POSTGRES_USER: postgres
        121	          POSTGRES_DB: ndne_test
        122	        ports:
        123	          - 5432:5432
        124	        options: >-
        125	          --health-cmd pg_isready
        126	          --health-interval 10s
        127	          --health-timeout 5s
        128	          --health-retries 5
        129	      redis:
        130	        image: redis:alpine
        131	        ports:
        132	          - 6379:6379
        133	        options: >-
        134	          --health-cmd "redis-cli ping"
        135	          --health-interval 10s
        136	          --health-timeout 5s
        137	          --health-retries 5
        138	
        139	    steps:
        140	      - uses: actions/checkout@v3
        141	
        142	      - name: Setup Node.js
        143	        uses: actions/setup-node@v3
        144	        with:
        145	          node-version: '18'
        146	          cache: 'npm'
        147	
        148	      - name: Install dependencies (root)
        149	        run: npm ci
        150	
        151	      - name: Install Playwright browsers
        152	        run: npx playwright install --with-deps
        153	
        154	      - name: Start backend & frontend
        155	        run: |
        156	          cd backend
        157	          npx prisma migrate deploy
        158	          npm run dev &
        159	          cd ../frontend
        160	          npm run dev &
        161	          sleep 10
        162	        env:
        163	          DB_URL: postgresql://postgres:postgres@localhost:5432/ndne_test
        164	          REDIS_URL: redis://localhost:6379
        165	          JWT_SECRET: test-jwt-secret
        166	          NODE_ENV: test
        167	          PORT: 4000
        168	          CORS_ORIGINS: http://localhost:5173
        169	
        170	      - name: Run Playwright E2E tests
        171	        run: npm run test:e2e
        172	
        173	  build-docker:
        174	    name: Build Docker Images
        175	    runs-on: ubuntu-latest
        176	    needs: [lint, test-backend, test-frontend]
        177	    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        178	    steps:
        179	      - uses: actions/checkout@v3
        180	
        181	      - name: Set up Docker Buildx
        182	        uses: docker/setup-buildx-action@v2
        183	
        184	      - name: Build backend image
        185	        uses: docker/build-push-action@v4
        186	        with:
        187	          context: ./backend
        188	          push: false
        189	          tags: ndne-backend:latest
        190	          cache-from: type=gha
        191	          cache-to: type=gha,mode=max
        192	
        193	      - name: Build frontend image
        194	        uses: docker/build-push-action@v4
        195	        with:
        196	          context: ./frontend
        197	          push: false
        198	          tags: ndne-frontend:latest
        199	          cache-from: type=gha
        200	          cache-to: type=gha,mode=max
        201	
        202	  # Deployment jobs would be added here
        203	  # For example:
        204	  # deploy-preview:
        205	  #   name: Deploy Preview to Fly.io
        206	  #   runs-on: ubuntu-latest
        207	  #   needs: [build-docker]
        208	  #   if: github.event_name == 'pull_request'
        209	  #   steps:
        210	  #     # Deploy to Fly.io steps
        211	
        212	  # deploy-production:
        213	  #   name: Deploy Production to Render
        214	  #   runs-on: ubuntu-latest
        215	  #   needs: [build-docker]
        216	  #   if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        217	  #   steps:
        218	  #     # Deploy to Render steps

==============================================
FILE: ./.gitignore
==============================================

          1	node_modules
          2	dist
          3	**/.DS_Store
          4	.env
          5	.env.*
          6	pnpm-lock.yaml


==============================================
FILE: ./.husky/_/.gitignore
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./.husky/_/husky.sh
==============================================

          1	#!/usr/bin/env sh
          2	if [ -z "$husky_skip_init" ]; then
          3	  debug () {
          4	    if [ "$HUSKY_DEBUG" = "1" ]; then
          5	      echo "husky (debug) - $1"
          6	    fi
          7	  }
          8	
          9	  readonly hook_name="$(basename -- "$0")"
         10	  debug "starting $hook_name..."
         11	
         12	  if [ "$HUSKY" = "0" ]; then
         13	    debug "HUSKY env variable is set to 0, skipping hook"
         14	    exit 0
         15	  fi
         16	
         17	  if [ -f ~/.huskyrc ]; then
         18	    debug "sourcing ~/.huskyrc"
         19	    . ~/.huskyrc
         20	  fi
         21	
         22	  readonly husky_skip_init=1
         23	  export husky_skip_init
         24	  sh -e "$0" "$@"
         25	  exitCode="$?"
         26	
         27	  if [ $exitCode != 0 ]; then
         28	    echo "husky - $hook_name hook exited with code $exitCode (error)"
         29	  fi
         30	
         31	  if [ $exitCode = 127 ]; then
         32	    echo "husky - command not found in PATH=$PATH"
         33	  fi
         34	
         35	  exit $exitCode
         36	fi


==============================================
FILE: ./.prettierrc
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./README.md
==============================================

          1	# NDNE
          2	
          3	AI Representative Governance System
          4	
          5	## Requirements
          6	
          7	- **Node.js**: v18 or higher
          8	- **Docker**: Latest stable version
          9	- **Docker Compose**: Latest stable version (usually included with Docker Desktop)
         10	- **npm**: v7 or higher
         11	
         12	## Quickstart
         13	
         14	```bash
         15	# Make sure Docker is running first!
         16	docker-compose up -d postgres redis  # Start database and Redis services
         17	
         18	# Install dependencies
         19	npm ci
         20	
         21	# Start servers using convenience scripts
         22	./scripts/start-servers.sh           # Starts both backend and frontend
         23	
         24	# Alternatively, start servers manually
         25	npm run dev:backend                  # Start backend in watch mode on http://localhost:4000
         26	npm run dev:frontend                 # Start frontend on http://localhost:5173
         27	
         28	# Stop all servers when done
         29	./scripts/stop-servers.sh
         30	```
         31	
         32	## Database Setup
         33	
         34	On first run, you'll need to set up the database:
         35	
         36	```bash
         37	cd backend
         38	npx prisma migrate dev     # Apply all migrations
         39	npx prisma db seed         # Seed the database with initial data
         40	```
         41	
         42	## Local Development with Docker
         43	
         44	You can also run the entire stack with Docker:
         45	
         46	```bash
         47	# Make sure Docker is running!
         48	docker-compose up --build -d           # Build and start all services (postgres, redis, backend, frontend)
         49	docker-compose exec backend npm run migrate
         50	docker-compose exec backend npm run seed
         51	```
         52	
         53	Access the application at:
         54	- Frontend: http://localhost:5173
         55	- Backend API: http://localhost:4000
         56	
         57	## Environment Variables
         58	
         59	The backend service requires a `.env` file in the `backend` directory. Copy the example file and modify as needed:
         60	
         61	```bash
         62	cp backend/.env.example backend/.env
         63	```
         64	
         65	Key environment variables:
         66	- `DB_URL`: PostgreSQL connection string
         67	- `REDIS_URL`: Redis connection string
         68	- `JWT_SECRET`: Secret for JWT token generation
         69	- `OPENROUTER_API_KEY`: Your OpenRouter API key for LLM services
         70	
         71	## Troubleshooting
         72	
         73	### Database Connection Issues
         74	
         75	If you encounter database connection errors:
         76	
         77	1. Ensure Docker is running
         78	2. Check if PostgreSQL container is running:
         79	   ```bash
         80	   docker ps | grep postgres
         81	   ```
         82	3. If it's not running, start the containers:
         83	   ```bash
         84	   docker-compose up -d postgres redis
         85	   ```
         86	4. Restart the backend server
         87	   ```bash
         88	   cd backend && npm run dev
         89	   ```
         90	
         91	### Login Failures
         92	
         93	If login attempts fail with a 500 server error:
         94	1. Check backend logs for database connection errors
         95	2. Ensure the PostgreSQL container is running
         96	3. Verify that your backend/.env file has the correct DB_URL
         97	
         98	### API Endpoint Errors
         99	
        100	If the frontend shows API errors:
        101	1. Ensure both frontend and backend servers are running
        102	2. Check that the backend is accessible at http://localhost:4000/api/health
        103	3. Look for CORS errors in the browser console
        104	
        105	## Project Structure
        106	
        107	- `backend/`: Node.js Express server with Prisma ORM
        108	  - `src/`: Source code
        109	    - `routes/`: API routes
        110	    - `middleware/`: Express middleware
        111	    - `services/`: Business logic
        112	    - `utils/`: Utility functions
        113	  - `prisma/`: Database schema and migrations
        114	- `frontend/`: React application
        115	  - `src/`: Source code
        116	    - `components/`: React components
        117	    - `pages/`: Page components
        118	    - `context/`: React context providers
        119	    - `api/`: API client
        120	
        121	## Development Scripts
        122	
        123	- `npm run dev:backend`: Start backend server in development mode
        124	- `npm run dev:frontend`: Start frontend dev server with hot reload
        125	- `npm run build`: Build the application for production
        126	- `npm run test`: Run tests
        127	- `./scripts/start-servers.sh`: Start both backend and frontend servers
        128	- `./scripts/stop-servers.sh`: Stop all running servers
        129	
        130	## Documentation
        131	
        132	- See `HANDOFF.md` for the current state of the project and next steps
        133	- See `TESTING_LOG.md` for testing history and known issues
        134	- See `NDNE_CANONICAL_COMPLETION_AUDIT.md` for remaining implementation tasks


==============================================
FILE: ./all_project_files.txt
==============================================

          1	
          2	==============================================
          3	FILE: ./.DS_Store
          4	==============================================
          5	
          6	     [Binary file, content omitted]
          7	
          8	
          9	==============================================
         10	FILE: ./.env.example
         11	==============================================
         12	
         13	          1	DB_URL=postgresql://user:pass@localhost:5432/ndne
         14	          2	REDIS_URL=redis://localhost:6379
         15	          3	JWT_SECRET=change-me
         16	          4	PORT=4000
         17	          5	CORS_ORIGINS=http://localhost:5173
         18	          6	KEY_STORAGE_MODE=server
         19	          7	AI_SERVICE_URL=http://agent:5000
         20	          8	DEFAULT_LLM_MODEL=openai/gpt-4o
         21	          9	OPENROUTER_API_KEY=
         22	         10	OPENROUTER_MODELS_ENDPOINT=https://openrouter.ai/api/v1/models
         23	         11	DIGEST_FREQUENCY_HOURS=24
         24	         12	PLAY_MONEY_TREASURY=100000
         25	         13	MAX_MONETARY_NO_CONSENT=500
         26	         14	MODEL_SELECTION_ADMIN_ONLY=true
         27	
         28	
         29	==============================================
         30	FILE: ./.eslintrc.js
         31	==============================================
         32	
         33	          1	module.exports = {
         34	          2	  root: true,
         35	          3	  parser: '@typescript-eslint/parser',
         36	          4	  parserOptions: {
         37	          5	    project: ['./tsconfig.json'],
         38	          6	    tsconfigRootDir: __dirname,
         39	          7	    sourceType: 'module',
         40	          8	  },
         41	          9	  env: {
         42	         10	    browser: true,
         43	         11	    node: true,
         44	         12	    es2021: true,
         45	         13	  },
         46	         14	  plugins: ['@typescript-eslint'],
         47	         15	  extends: [
         48	         16	    'eslint:recommended',
         49	         17	    'plugin:@typescript-eslint/recommended',
         50	         18	    'prettier',
         51	         19	  ],
         52	         20	  rules: {},
         53	         21	};
         54	
         55	
         56	==============================================
         57	FILE: ./.github/workflows/ci.yml
         58	==============================================
         59	
         60	          1	name: CI Pipeline
         61	          2	
         62	          3	on:
         63	          4	  push:
         64	          5	    branches: [main]
         65	          6	  pull_request:
         66	          7	    branches: [main]
         67	          8	
         68	          9	jobs:
         69	         10	  lint:
         70	         11	    name: Lint
         71	         12	    runs-on: ubuntu-latest
         72	         13	    steps:
         73	         14	      - uses: actions/checkout@v3
         74	         15	
         75	         16	      - name: Setup Node.js
         76	         17	        uses: actions/setup-node@v3
         77	         18	        with:
         78	         19	          node-version: '18'
         79	         20	          cache: 'npm'
         80	         21	
         81	         22	      - name: Install dependencies
         82	         23	        run: npm ci
         83	         24	
         84	         25	      - name: Run ESLint
         85	         26	        run: npm run lint
         86	         27	
         87	         28	      - name: Run TypeScript type-check
         88	         29	        run: npm run typecheck
         89	         30	
         90	         31	  test-backend:
         91	         32	    name: Backend Tests
         92	         33	    runs-on: ubuntu-latest
         93	         34	    services:
         94	         35	      postgres:
         95	         36	        image: postgres:15
         96	         37	        env:
         97	         38	          POSTGRES_PASSWORD: postgres
         98	         39	          POSTGRES_USER: postgres
         99	         40	          POSTGRES_DB: ndne_test
        100	         41	        ports:
        101	         42	          - 5432:5432
        102	         43	        options: >-
        103	         44	          --health-cmd pg_isready
        104	         45	          --health-interval 10s
        105	         46	          --health-timeout 5s
        106	         47	          --health-retries 5
        107	         48	      redis:
        108	         49	        image: redis:alpine
        109	         50	        ports:
        110	         51	          - 6379:6379
        111	         52	        options: >-
        112	         53	          --health-cmd "redis-cli ping"
        113	         54	          --health-interval 10s
        114	         55	          --health-timeout 5s
        115	         56	          --health-retries 5
        116	         57	          
        117	         58	    steps:
        118	         59	      - uses: actions/checkout@v3
        119	         60	
        120	         61	      - name: Setup Node.js
        121	         62	        uses: actions/setup-node@v3
        122	         63	        with:
        123	         64	          node-version: '18'
        124	         65	          cache: 'npm'
        125	         66	
        126	         67	      - name: Install dependencies
        127	         68	        run: |
        128	         69	          cd backend
        129	         70	          npm ci
        130	         71	
        131	         72	      - name: Run DB migrations
        132	         73	        run: |
        133	         74	          cd backend
        134	         75	          npx prisma migrate deploy
        135	         76	        env:
        136	         77	          DB_URL: postgresql://postgres:postgres@localhost:5432/ndne_test
        137	         78	          
        138	         79	      - name: Run unit tests
        139	         80	        run: |
        140	         81	          cd backend
        141	         82	          npm test
        142	         83	        env:
        143	         84	          DB_URL: postgresql://postgres:postgres@localhost:5432/ndne_test
        144	         85	          REDIS_URL: redis://localhost:6379
        145	         86	          JWT_SECRET: test-jwt-secret
        146	         87	          NODE_ENV: test
        147	         88	
        148	         89	  test-frontend:
        149	         90	    name: Frontend Tests
        150	         91	    runs-on: ubuntu-latest
        151	         92	    steps:
        152	         93	      - uses: actions/checkout@v3
        153	         94	
        154	         95	      - name: Setup Node.js
        155	         96	        uses: actions/setup-node@v3
        156	         97	        with:
        157	         98	          node-version: '18'
        158	         99	          cache: 'npm'
        159	        100	
        160	        101	      - name: Install dependencies
        161	        102	        run: |
        162	        103	          cd frontend
        163	        104	          npm ci
        164	        105	
        165	        106	      - name: Run tests
        166	        107	        run: |
        167	        108	          cd frontend
        168	        109	          npm test
        169	        110	
        170	        111	  e2e-tests:
        171	        112	    name: End-to-End Tests
        172	        113	    runs-on: ubuntu-latest
        173	        114	    needs: [test-backend, test-frontend]
        174	        115	    services:
        175	        116	      postgres:
        176	        117	        image: postgres:15
        177	        118	        env:
        178	        119	          POSTGRES_PASSWORD: postgres
        179	        120	          POSTGRES_USER: postgres
        180	        121	          POSTGRES_DB: ndne_test
        181	        122	        ports:
        182	        123	          - 5432:5432
        183	        124	        options: >-
        184	        125	          --health-cmd pg_isready
        185	        126	          --health-interval 10s
        186	        127	          --health-timeout 5s
        187	        128	          --health-retries 5
        188	        129	      redis:
        189	        130	        image: redis:alpine
        190	        131	        ports:
        191	        132	          - 6379:6379
        192	        133	        options: >-
        193	        134	          --health-cmd "redis-cli ping"
        194	        135	          --health-interval 10s
        195	        136	          --health-timeout 5s
        196	        137	          --health-retries 5
        197	        138	
        198	        139	    steps:
        199	        140	      - uses: actions/checkout@v3
        200	        141	
        201	        142	      - name: Setup Node.js
        202	        143	        uses: actions/setup-node@v3
        203	        144	        with:
        204	        145	          node-version: '18'
        205	        146	          cache: 'npm'
        206	        147	
        207	        148	      - name: Install dependencies (root)
        208	        149	        run: npm ci
        209	        150	
        210	        151	      - name: Install Playwright browsers
        211	        152	        run: npx playwright install --with-deps
        212	        153	
        213	        154	      - name: Start backend & frontend
        214	        155	        run: |
        215	        156	          cd backend
        216	        157	          npx prisma migrate deploy
        217	        158	          npm run dev &
        218	        159	          cd ../frontend
        219	        160	          npm run dev &
        220	        161	          sleep 10
        221	        162	        env:
        222	        163	          DB_URL: postgresql://postgres:postgres@localhost:5432/ndne_test
        223	        164	          REDIS_URL: redis://localhost:6379
        224	        165	          JWT_SECRET: test-jwt-secret
        225	        166	          NODE_ENV: test
        226	        167	          PORT: 4000
        227	        168	          CORS_ORIGINS: http://localhost:5173
        228	        169	
        229	        170	      - name: Run Playwright E2E tests
        230	        171	        run: npm run test:e2e
        231	        172	
        232	        173	  build-docker:
        233	        174	    name: Build Docker Images
        234	        175	    runs-on: ubuntu-latest
        235	        176	    needs: [lint, test-backend, test-frontend]
        236	        177	    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        237	        178	    steps:
        238	        179	      - uses: actions/checkout@v3
        239	        180	
        240	        181	      - name: Set up Docker Buildx
        241	        182	        uses: docker/setup-buildx-action@v2
        242	        183	
        243	        184	      - name: Build backend image
        244	        185	        uses: docker/build-push-action@v4
        245	        186	        with:
        246	        187	          context: ./backend
        247	        188	          push: false
        248	        189	          tags: ndne-backend:latest
        249	        190	          cache-from: type=gha
        250	        191	          cache-to: type=gha,mode=max
        251	        192	
        252	        193	      - name: Build frontend image
        253	        194	        uses: docker/build-push-action@v4
        254	        195	        with:
        255	        196	          context: ./frontend
        256	        197	          push: false
        257	        198	          tags: ndne-frontend:latest
        258	        199	          cache-from: type=gha
        259	        200	          cache-to: type=gha,mode=max
        260	        201	
        261	        202	  # Deployment jobs would be added here
        262	        203	  # For example:
        263	        204	  # deploy-preview:
        264	        205	  #   name: Deploy Preview to Fly.io
        265	        206	  #   runs-on: ubuntu-latest
        266	        207	  #   needs: [build-docker]
        267	        208	  #   if: github.event_name == 'pull_request'
        268	        209	  #   steps:
        269	        210	  #     # Deploy to Fly.io steps
        270	        211	
        271	        212	  # deploy-production:
        272	        213	  #   name: Deploy Production to Render
        273	        214	  #   runs-on: ubuntu-latest
        274	        215	  #   needs: [build-docker]
        275	        216	  #   if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        276	        217	  #   steps:
        277	        218	  #     # Deploy to Render steps
        278	
        279	==============================================
        280	FILE: ./.gitignore
        281	==============================================
        282	
        283	          1	node_modules
        284	          2	dist
        285	          3	**/.DS_Store
        286	          4	.env
        287	          5	.env.*
        288	          6	pnpm-lock.yaml
        289	
        290	
        291	==============================================
        292	FILE: ./.husky/_/.gitignore
        293	==============================================
        294	
        295	     [Binary file, content omitted]
        296	
        297	
        298	==============================================
        299	FILE: ./.husky/_/husky.sh
        300	==============================================
        301	
        302	          1	#!/usr/bin/env sh
        303	          2	if [ -z "$husky_skip_init" ]; then
        304	          3	  debug () {
        305	          4	    if [ "$HUSKY_DEBUG" = "1" ]; then
        306	          5	      echo "husky (debug) - $1"
        307	          6	    fi
        308	          7	  }
        309	          8	
        310	          9	  readonly hook_name="$(basename -- "$0")"
        311	         10	  debug "starting $hook_name..."
        312	         11	
        313	         12	  if [ "$HUSKY" = "0" ]; then
        314	         13	    debug "HUSKY env variable is set to 0, skipping hook"
        315	         14	    exit 0
        316	         15	  fi
        317	         16	
        318	         17	  if [ -f ~/.huskyrc ]; then
        319	         18	    debug "sourcing ~/.huskyrc"
        320	         19	    . ~/.huskyrc
        321	         20	  fi
        322	         21	
        323	         22	  readonly husky_skip_init=1
        324	         23	  export husky_skip_init
        325	         24	  sh -e "$0" "$@"
        326	         25	  exitCode="$?"
        327	         26	
        328	         27	  if [ $exitCode != 0 ]; then
        329	         28	    echo "husky - $hook_name hook exited with code $exitCode (error)"
        330	         29	  fi
        331	         30	
        332	         31	  if [ $exitCode = 127 ]; then
        333	         32	    echo "husky - command not found in PATH=$PATH"
        334	         33	  fi
        335	         34	
        336	         35	  exit $exitCode
        337	         36	fi
        338	
        339	
        340	==============================================
        341	FILE: ./.prettierrc
        342	==============================================
        343	
        344	     [Binary file, content omitted]
        345	
        346	
        347	==============================================
        348	FILE: ./README.md
        349	==============================================
        350	
        351	          1	# NDNE
        352	          2	
        353	          3	AI Representative Governance System
        354	          4	
        355	          5	## Requirements
        356	          6	
        357	          7	- **Node.js**: v18 or higher
        358	          8	- **Docker**: Latest stable version
        359	          9	- **Docker Compose**: Latest stable version (usually included with Docker Desktop)
        360	         10	- **npm**: v7 or higher
        361	         11	
        362	         12	## Quickstart
        363	         13	
        364	         14	```bash
        365	         15	# Make sure Docker is running first!
        366	         16	docker-compose up -d postgres redis  # Start database and Redis services
        367	         17	
        368	         18	# Install dependencies
        369	         19	npm ci
        370	         20	
        371	         21	# Start servers using convenience scripts
        372	         22	./scripts/start-servers.sh           # Starts both backend and frontend
        373	         23	
        374	         24	# Alternatively, start servers manually
        375	         25	npm run dev:backend                  # Start backend in watch mode on http://localhost:4000
        376	         26	npm run dev:frontend                 # Start frontend on http://localhost:5173
        377	         27	
        378	         28	# Stop all servers when done
        379	         29	./scripts/stop-servers.sh
        380	         30	```
        381	         31	
        382	         32	## Database Setup
        383	         33	
        384	         34	On first run, you'll need to set up the database:
        385	         35	
        386	         36	```bash
        387	         37	cd backend
        388	         38	npx prisma migrate dev     # Apply all migrations
        389	         39	npx prisma db seed         # Seed the database with initial data
        390	         40	```
        391	         41	
        392	         42	## Local Development with Docker
        393	         43	
        394	         44	You can also run the entire stack with Docker:
        395	         45	
        396	         46	```bash
        397	         47	# Make sure Docker is running!
        398	         48	docker-compose up --build -d           # Build and start all services (postgres, redis, backend, frontend)
        399	         49	docker-compose exec backend npm run migrate
        400	         50	docker-compose exec backend npm run seed
        401	         51	```
        402	         52	
        403	         53	Access the application at:
        404	         54	- Frontend: http://localhost:5173
        405	         55	- Backend API: http://localhost:4000
        406	         56	
        407	         57	## Environment Variables
        408	         58	
        409	         59	The backend service requires a `.env` file in the `backend` directory. Copy the example file and modify as needed:
        410	         60	
        411	         61	```bash
        412	         62	cp backend/.env.example backend/.env
        413	         63	```
        414	         64	
        415	         65	Key environment variables:
        416	         66	- `DB_URL`: PostgreSQL connection string
        417	         67	- `REDIS_URL`: Redis connection string
        418	         68	- `JWT_SECRET`: Secret for JWT token generation
        419	         69	- `OPENROUTER_API_KEY`: Your OpenRouter API key for LLM services
        420	         70	
        421	         71	## Troubleshooting
        422	         72	
        423	         73	### Database Connection Issues
        424	         74	
        425	         75	If you encounter database connection errors:
        426	         76	
        427	         77	1. Ensure Docker is running
        428	         78	2. Check if PostgreSQL container is running:
        429	         79	   ```bash
        430	         80	   docker ps | grep postgres
        431	         81	   ```
        432	         82	3. If it's not running, start the containers:
        433	         83	   ```bash
        434	         84	   docker-compose up -d postgres redis
        435	         85	   ```
        436	         86	4. Restart the backend server
        437	         87	   ```bash
        438	         88	   cd backend && npm run dev
        439	         89	   ```
        440	         90	
        441	         91	### Login Failures
        442	         92	
        443	         93	If login attempts fail with a 500 server error:
        444	         94	1. Check backend logs for database connection errors
        445	         95	2. Ensure the PostgreSQL container is running
        446	         96	3. Verify that your backend/.env file has the correct DB_URL
        447	         97	
        448	         98	### API Endpoint Errors
        449	         99	
        450	        100	If the frontend shows API errors:
        451	        101	1. Ensure both frontend and backend servers are running
        452	        102	2. Check that the backend is accessible at http://localhost:4000/api/health
        453	        103	3. Look for CORS errors in the browser console
        454	        104	
        455	        105	## Project Structure
        456	        106	
        457	        107	- `backend/`: Node.js Express server with Prisma ORM
        458	        108	  - `src/`: Source code
        459	        109	    - `routes/`: API routes
        460	        110	    - `middleware/`: Express middleware
        461	        111	    - `services/`: Business logic
        462	        112	    - `utils/`: Utility functions
        463	        113	  - `prisma/`: Database schema and migrations
        464	        114	- `frontend/`: React application
        465	        115	  - `src/`: Source code
        466	        116	    - `components/`: React components
        467	        117	    - `pages/`: Page components
        468	        118	    - `context/`: React context providers
        469	        119	    - `api/`: API client
        470	        120	
        471	        121	## Development Scripts
        472	        122	
        473	        123	- `npm run dev:backend`: Start backend server in development mode
        474	        124	- `npm run dev:frontend`: Start frontend dev server with hot reload
        475	        125	- `npm run build`: Build the application for production
        476	        126	- `npm run test`: Run tests
        477	        127	- `./scripts/start-servers.sh`: Start both backend and frontend servers
        478	        128	- `./scripts/stop-servers.sh`: Stop all running servers
        479	        129	
        480	        130	## Documentation
        481	        131	
        482	        132	- See `HANDOFF.md` for the current state of the project and next steps
        483	        133	- See `TESTING_LOG.md` for testing history and known issues
        484	        134	- See `NDNE_CANONICAL_COMPLETION_AUDIT.md` for remaining implementation tasks
        485	
        486	
        487	==============================================
        488	FILE: ./all_project_files.txt
        489	==============================================
        490	


==============================================
FILE: ./backend/.env
==============================================

          1	# Production PostgreSQL connection
          2	DB_URL=postgresql://user:pass@localhost:5432/ndne
          3	REDIS_URL=redis://localhost:6379
          4	JWT_SECRET=2UBYPkyNgyglH7G4mlhDtmeVPiIUHx3z
          5	PORT=4000
          6	CORS_ORIGINS=http://localhost:5173,http://localhost:5174,http://localhost:5175,https://example.com
          7	KEY_STORAGE_MODE=server
          8	AI_SERVICE_URL=http://agent:5000
          9	DEFAULT_LLM_MODEL=openai/gpt-4o
         10	OPENROUTER_API_KEY=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
         11	OPENROUTER_MODELS_ENDPOINT=https://openrouter.ai/api/v1/models
         12	DIGEST_FREQUENCY_HOURS=24
         13	PLAY_MONEY_TREASURY=100000
         14	MAX_MONETARY_NO_CONSENT=500
         15	MODEL_SELECTION_ADMIN_ONLY=true


==============================================
FILE: ./backend/checkDB.ts
==============================================

          1	import { PrismaClient } from '@prisma/client';
          2	
          3	const prisma = new PrismaClient();
          4	
          5	async function check() {
          6	  try {
          7	    console.log('Checking database tables...');
          8	    
          9	    try {
         10	      const exampleProposalCount = await prisma.exampleProposal.count();
         11	      console.log('ExampleProposals:', exampleProposalCount);
         12	    } catch (e) {
         13	      console.error('Error checking ExampleProposal:', e);
         14	    }
         15	    
         16	    try {
         17	      const exampleUserArchetypeCount = await prisma.exampleUserArchetype.count();
         18	      console.log('ExampleUserArchetype:', exampleUserArchetypeCount);
         19	    } catch (e) {
         20	      console.error('Error checking ExampleUserArchetype:', e);
         21	    }
         22	    
         23	    try {
         24	      const userCount = await prisma.user.count();
         25	      console.log('Users:', userCount);
         26	    } catch (e) {
         27	      console.error('Error checking User:', e);
         28	    }
         29	    
         30	    try {
         31	      const agentCount = await prisma.agent.count();
         32	      console.log('Agents:', agentCount);
         33	    } catch (e) {
         34	      console.error('Error checking Agent:', e);
         35	    }
         36	  } catch (e) {
         37	    console.error('General Error:', e);
         38	  } finally {
         39	    await prisma.$disconnect();
         40	  }
         41	}
         42	
         43	check();

==============================================
FILE: ./backend/package-lock.json
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./backend/package.json
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./backend/prisma/dev.db
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./backend/prisma/migrations/20250422190838_init/migration.sql
==============================================

          1	-- CreateTable
          2	CREATE TABLE "User" (
          3	    "id" TEXT NOT NULL,
          4	    "email" TEXT NOT NULL,
          5	    "passwordHash" TEXT NOT NULL,
          6	    "publicKey" TEXT NOT NULL,
          7	    "encryptedPrivKey" TEXT NOT NULL,
          8	    "digestFrequency" INTEGER NOT NULL DEFAULT 24,
          9	    "digestTone" TEXT NOT NULL DEFAULT 'neutral',
         10	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
         11	    "updatedAt" TIMESTAMP(3) NOT NULL,
         12	
         13	    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
         14	);
         15	
         16	-- CreateTable
         17	CREATE TABLE "Agent" (
         18	    "id" TEXT NOT NULL,
         19	    "userId" TEXT NOT NULL,
         20	    "name" TEXT NOT NULL,
         21	    "color" TEXT NOT NULL,
         22	    "publicKey" TEXT NOT NULL,
         23	    "encryptedPrivKey" TEXT NOT NULL,
         24	    "autonomyLevel" INTEGER NOT NULL DEFAULT 0,
         25	    "pausedUntil" TIMESTAMP(3),
         26	    "alignmentScore" DOUBLE PRECISION NOT NULL DEFAULT 1,
         27	    "preferences" JSONB NOT NULL,
         28	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
         29	    "updatedAt" TIMESTAMP(3) NOT NULL,
         30	
         31	    CONSTRAINT "Agent_pkey" PRIMARY KEY ("id")
         32	);
         33	
         34	-- CreateTable
         35	CREATE TABLE "Proposal" (
         36	    "id" TEXT NOT NULL,
         37	    "title" TEXT NOT NULL,
         38	    "description" TEXT NOT NULL,
         39	    "type" TEXT NOT NULL DEFAULT 'standard',
         40	    "playMode" BOOLEAN NOT NULL DEFAULT false,
         41	    "amount" DOUBLE PRECISION,
         42	    "createdByAgentId" TEXT NOT NULL,
         43	    "status" TEXT NOT NULL DEFAULT 'open',
         44	    "quorum" INTEGER NOT NULL,
         45	    "threshold" DOUBLE PRECISION NOT NULL DEFAULT 0.5,
         46	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
         47	    "closeAt" TIMESTAMP(3) NOT NULL,
         48	    "vetoWindowEnd" TIMESTAMP(3) NOT NULL,
         49	
         50	    CONSTRAINT "Proposal_pkey" PRIMARY KEY ("id")
         51	);
         52	
         53	-- CreateTable
         54	CREATE TABLE "Vote" (
         55	    "id" TEXT NOT NULL,
         56	    "proposalId" TEXT NOT NULL,
         57	    "agentId" TEXT NOT NULL,
         58	    "value" TEXT NOT NULL,
         59	    "confidence" DOUBLE PRECISION NOT NULL,
         60	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
         61	    "revokedAt" TIMESTAMP(3),
         62	    "overrideByUser" BOOLEAN NOT NULL DEFAULT false,
         63	    "overrideReason" TEXT,
         64	
         65	    CONSTRAINT "Vote_pkey" PRIMARY KEY ("id")
         66	);
         67	
         68	-- CreateTable
         69	CREATE TABLE "Comment" (
         70	    "id" TEXT NOT NULL,
         71	    "proposalId" TEXT NOT NULL,
         72	    "agentId" TEXT NOT NULL,
         73	    "content" TEXT NOT NULL,
         74	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
         75	    "revokedAt" TIMESTAMP(3),
         76	
         77	    CONSTRAINT "Comment_pkey" PRIMARY KEY ("id")
         78	);
         79	
         80	-- CreateTable
         81	CREATE TABLE "Digest" (
         82	    "id" TEXT NOT NULL,
         83	    "userId" TEXT NOT NULL,
         84	    "content" TEXT NOT NULL,
         85	    "generatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
         86	
         87	    CONSTRAINT "Digest_pkey" PRIMARY KEY ("id")
         88	);
         89	
         90	-- CreateTable
         91	CREATE TABLE "ConsentEvent" (
         92	    "id" TEXT NOT NULL,
         93	    "userId" TEXT NOT NULL,
         94	    "agentId" TEXT NOT NULL,
         95	    "action" TEXT NOT NULL,
         96	    "payload" JSONB NOT NULL,
         97	    "signature" TEXT NOT NULL,
         98	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
         99	
        100	    CONSTRAINT "ConsentEvent_pkey" PRIMARY KEY ("id")
        101	);
        102	
        103	-- CreateTable
        104	CREATE TABLE "SystemConfig" (
        105	    "id" INTEGER NOT NULL DEFAULT 1,
        106	    "defaultModel" TEXT NOT NULL DEFAULT 'openai/gpt-4o',
        107	    "modelsEndpoint" TEXT NOT NULL DEFAULT 'https://openrouter.ai/api/v1/models',
        108	    "playMoneyTreasury" DOUBLE PRECISION NOT NULL DEFAULT 100000,
        109	    "maxMonetaryNoConsent" DOUBLE PRECISION NOT NULL DEFAULT 500,
        110	    "keyStorageMode" TEXT NOT NULL DEFAULT 'server',
        111	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
        112	    "updatedAt" TIMESTAMP(3) NOT NULL,
        113	
        114	    CONSTRAINT "SystemConfig_pkey" PRIMARY KEY ("id")
        115	);
        116	
        117	-- CreateIndex
        118	CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
        119	
        120	-- CreateIndex
        121	CREATE UNIQUE INDEX "Agent_userId_key" ON "Agent"("userId");
        122	
        123	-- AddForeignKey
        124	ALTER TABLE "Agent" ADD CONSTRAINT "Agent_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
        125	
        126	-- AddForeignKey
        127	ALTER TABLE "Vote" ADD CONSTRAINT "Vote_proposalId_fkey" FOREIGN KEY ("proposalId") REFERENCES "Proposal"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
        128	
        129	-- AddForeignKey
        130	ALTER TABLE "Vote" ADD CONSTRAINT "Vote_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "Agent"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
        131	
        132	-- AddForeignKey
        133	ALTER TABLE "Comment" ADD CONSTRAINT "Comment_proposalId_fkey" FOREIGN KEY ("proposalId") REFERENCES "Proposal"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
        134	
        135	-- AddForeignKey
        136	ALTER TABLE "Comment" ADD CONSTRAINT "Comment_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "Agent"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
        137	
        138	-- AddForeignKey
        139	ALTER TABLE "Digest" ADD CONSTRAINT "Digest_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
        140	
        141	-- AddForeignKey
        142	ALTER TABLE "ConsentEvent" ADD CONSTRAINT "ConsentEvent_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
        143	
        144	-- AddForeignKey
        145	ALTER TABLE "ConsentEvent" ADD CONSTRAINT "ConsentEvent_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "Agent"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


==============================================
FILE: ./backend/prisma/migrations/20250422200323_add_user_role/migration.sql
==============================================

          1	-- CreateEnum
          2	CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN');
          3	
          4	-- AlterTable
          5	ALTER TABLE "User" ADD COLUMN     "role" "Role" NOT NULL DEFAULT 'USER';


==============================================
FILE: ./backend/prisma/migrations/20250422200434_add_audit_log/migration.sql
==============================================

          1	-- CreateTable
          2	CREATE TABLE "AuditLog" (
          3	    "id" TEXT NOT NULL,
          4	    "timestamp" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
          5	    "userId" TEXT NOT NULL,
          6	    "action" TEXT NOT NULL,
          7	    "targetId" TEXT,
          8	    "details" JSONB,
          9	
         10	    CONSTRAINT "AuditLog_pkey" PRIMARY KEY ("id")
         11	);


==============================================
FILE: ./backend/prisma/migrations/20250422201308_add_llm_usage_log/migration.sql
==============================================

          1	-- CreateTable
          2	CREATE TABLE "LlmUsageLog" (
          3	    "id" TEXT NOT NULL,
          4	    "agentId" TEXT,
          5	    "model" TEXT NOT NULL,
          6	    "inputTokens" INTEGER NOT NULL,
          7	    "outputTokens" INTEGER NOT NULL,
          8	    "latencyMs" INTEGER NOT NULL,
          9	    "outcome" TEXT NOT NULL,
         10	    "errorMessage" TEXT,
         11	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
         12	
         13	    CONSTRAINT "LlmUsageLog_pkey" PRIMARY KEY ("id")
         14	);


==============================================
FILE: ./backend/prisma/migrations/20250422201501_add_play_money_ledger/migration.sql
==============================================

          1	-- CreateTable
          2	CREATE TABLE "PlayMoneyLedgerEntry" (
          3	    "id" TEXT NOT NULL,
          4	    "proposalId" TEXT NOT NULL,
          5	    "amount" DOUBLE PRECISION NOT NULL,
          6	    "balanceAfter" DOUBLE PRECISION NOT NULL,
          7	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
          8	
          9	    CONSTRAINT "PlayMoneyLedgerEntry_pkey" PRIMARY KEY ("id")
         10	);
         11	
         12	-- CreateIndex
         13	CREATE UNIQUE INDEX "PlayMoneyLedgerEntry_proposalId_key" ON "PlayMoneyLedgerEntry"("proposalId");
         14	
         15	-- AddForeignKey
         16	ALTER TABLE "PlayMoneyLedgerEntry" ADD CONSTRAINT "PlayMoneyLedgerEntry_proposalId_fkey" FOREIGN KEY ("proposalId") REFERENCES "Proposal"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


==============================================
FILE: ./backend/prisma/migrations/20250423162700_add_chat_models/migration.sql
==============================================

          1	-- CreateTable
          2	CREATE TABLE "ChatMessage" (
          3	    "id" TEXT NOT NULL PRIMARY KEY,
          4	    "userId" TEXT NOT NULL,
          5	    "agentId" TEXT NOT NULL,
          6	    "content" TEXT NOT NULL,
          7	    "sender" TEXT NOT NULL DEFAULT 'user',
          8	    "timestamp" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
          9	    "metadata" TEXT,
         10	    CONSTRAINT "ChatMessage_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE,
         11	    CONSTRAINT "ChatMessage_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "Agent" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
         12	);
         13	
         14	-- CreateTable
         15	CREATE TABLE "NegotiationSession" (
         16	    "id" TEXT NOT NULL PRIMARY KEY,
         17	    "topic" TEXT NOT NULL,
         18	    "description" TEXT,
         19	    "status" TEXT NOT NULL DEFAULT 'active',
         20	    "startedAt" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
         21	    "completedAt" TIMESTAMP,
         22	    "initiatorId" TEXT NOT NULL,
         23	    "participants" TEXT NOT NULL
         24	);
         25	
         26	-- CreateTable
         27	CREATE TABLE "NegotiationMessage" (
         28	    "id" TEXT NOT NULL PRIMARY KEY,
         29	    "negotiationId" TEXT NOT NULL,
         30	    "agentId" TEXT NOT NULL,
         31	    "content" TEXT NOT NULL,
         32	    "messageType" TEXT NOT NULL DEFAULT 'statement',
         33	    "referencedMessageId" TEXT,
         34	    "metadata" TEXT,
         35	    "timestamp" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
         36	    CONSTRAINT "NegotiationMessage_negotiationId_fkey" FOREIGN KEY ("negotiationId") REFERENCES "NegotiationSession" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
         37	    CONSTRAINT "NegotiationMessage_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "Agent" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
         38	);
         39	
         40	-- Modify Role handling
         41	ALTER TABLE "User" RENAME COLUMN "role" TO "_temp_role";
         42	ALTER TABLE "User" ADD COLUMN "role" TEXT NOT NULL DEFAULT 'USER';
         43	UPDATE "User" SET "role" = 'USER' WHERE "_temp_role" = 'USER';
         44	UPDATE "User" SET "role" = 'ADMIN' WHERE "_temp_role" = 'ADMIN';
         45	ALTER TABLE "User" DROP COLUMN "_temp_role";
         46	
         47	-- AlterTable
         48	ALTER TABLE "Agent" ADD COLUMN "onboardingCompleted" BOOLEAN NOT NULL DEFAULT false;
         49	ALTER TABLE "Agent" ADD COLUMN "lastInteraction" TIMESTAMP;
         50	ALTER TABLE "Agent" ADD COLUMN "userKnowledge" TEXT NOT NULL DEFAULT '{}';
         51	
         52	-- Convert JSON fields to String
         53	UPDATE "Agent" SET "preferences" = '{}' WHERE "preferences" IS NULL;
         54	UPDATE "Agent" SET "userKnowledge" = '{}' WHERE "userKnowledge" IS NULL;
         55	UPDATE "ConsentEvent" SET "payload" = '{}' WHERE "payload" IS NULL;
         56	UPDATE "AuditLog" SET "details" = '{}' WHERE "details" IS NULL;
         57	
         58	-- AlterTable
         59	ALTER TABLE "Proposal" ADD COLUMN "negotiationId" TEXT;
         60	ALTER TABLE "Proposal" ADD COLUMN "isNegotiated" BOOLEAN NOT NULL DEFAULT false;
         61	ALTER TABLE "Proposal" ADD COLUMN "negotiationSummary" TEXT;
         62	
         63	-- CreateIndex
         64	CREATE INDEX "ChatMessage_userId_idx" ON "ChatMessage"("userId");
         65	CREATE INDEX "ChatMessage_agentId_idx" ON "ChatMessage"("agentId");
         66	CREATE INDEX "ChatMessage_timestamp_idx" ON "ChatMessage"("timestamp");
         67	
         68	-- CreateIndex
         69	CREATE INDEX "NegotiationSession_status_idx" ON "NegotiationSession"("status");
         70	CREATE INDEX "NegotiationSession_startedAt_idx" ON "NegotiationSession"("startedAt");
         71	
         72	-- CreateIndex
         73	CREATE INDEX "NegotiationMessage_negotiationId_idx" ON "NegotiationMessage"("negotiationId");
         74	CREATE INDEX "NegotiationMessage_agentId_idx" ON "NegotiationMessage"("agentId");
         75	CREATE INDEX "NegotiationMessage_timestamp_idx" ON "NegotiationMessage"("timestamp");
         76	
         77	-- CreateIndex
         78	CREATE UNIQUE INDEX "Proposal_negotiationId_key" ON "Proposal"("negotiationId");
         79	
         80	-- AddForeignKey
         81	ALTER TABLE "Proposal" ADD CONSTRAINT "Proposal_negotiationId_fkey" FOREIGN KEY ("negotiationId") REFERENCES "NegotiationSession" ("id") ON DELETE SET NULL ON UPDATE CASCADE;

==============================================
FILE: ./backend/prisma/migrations/20250423172053_add_chat_models/migration.sql
==============================================

          1	-- AlterTable
          2	ALTER TABLE "Agent" ALTER COLUMN "preferences" SET DEFAULT '{}',
          3	ALTER COLUMN "preferences" SET DATA TYPE TEXT,
          4	ALTER COLUMN "lastInteraction" SET DATA TYPE TIMESTAMP(3);
          5	
          6	-- AlterTable
          7	ALTER TABLE "AuditLog" ALTER COLUMN "details" SET DATA TYPE TEXT;
          8	
          9	-- AlterTable
         10	ALTER TABLE "ChatMessage" ALTER COLUMN "timestamp" SET DATA TYPE TIMESTAMP(3);
         11	
         12	-- AlterTable
         13	ALTER TABLE "ConsentEvent" ALTER COLUMN "payload" SET DATA TYPE TEXT;
         14	
         15	-- AlterTable
         16	ALTER TABLE "NegotiationMessage" ALTER COLUMN "timestamp" SET DATA TYPE TIMESTAMP(3);
         17	
         18	-- AlterTable
         19	ALTER TABLE "NegotiationSession" ALTER COLUMN "startedAt" SET DATA TYPE TIMESTAMP(3),
         20	ALTER COLUMN "completedAt" SET DATA TYPE TIMESTAMP(3);
         21	
         22	-- DropEnum
         23	DROP TYPE "Role";


==============================================
FILE: ./backend/prisma/migrations/20250423175034_add_negotiation_reactions_and_dynamic_participation/migration.sql
==============================================

          1	/*
          2	  Warnings:
          3	
          4	  - The `preferences` column on the `Agent` table would be dropped and recreated. This will lead to data loss if there is data in the column.
          5	  - The `userKnowledge` column on the `Agent` table would be dropped and recreated. This will lead to data loss if there is data in the column.
          6	  - The `details` column on the `AuditLog` table would be dropped and recreated. This will lead to data loss if there is data in the column.
          7	  - The `metadata` column on the `ChatMessage` table would be dropped and recreated. This will lead to data loss if there is data in the column.
          8	  - The `payload` column on the `ConsentEvent` table would be dropped and recreated. This will lead to data loss if there is data in the column.
          9	  - The `metadata` column on the `NegotiationMessage` table would be dropped and recreated. This will lead to data loss if there is data in the column.
         10	  - You are about to drop the column `participants` on the `NegotiationSession` table. All the data in the column will be lost.
         11	
         12	*/
         13	-- AlterTable
         14	ALTER TABLE "Agent" DROP COLUMN "preferences",
         15	ADD COLUMN     "preferences" JSONB NOT NULL DEFAULT '{}',
         16	DROP COLUMN "userKnowledge",
         17	ADD COLUMN     "userKnowledge" JSONB NOT NULL DEFAULT '{}';
         18	
         19	-- AlterTable
         20	ALTER TABLE "AuditLog" DROP COLUMN "details",
         21	ADD COLUMN     "details" JSONB;
         22	
         23	-- AlterTable
         24	ALTER TABLE "ChatMessage" DROP COLUMN "metadata",
         25	ADD COLUMN     "metadata" JSONB;
         26	
         27	-- AlterTable
         28	ALTER TABLE "ConsentEvent" DROP COLUMN "payload",
         29	ADD COLUMN     "payload" JSONB NOT NULL DEFAULT '{}';
         30	
         31	-- AlterTable
         32	ALTER TABLE "NegotiationMessage" DROP COLUMN "metadata",
         33	ADD COLUMN     "metadata" JSONB;
         34	
         35	-- AlterTable
         36	ALTER TABLE "NegotiationSession" DROP COLUMN "participants";
         37	
         38	-- CreateTable
         39	CREATE TABLE "NegotiationReaction" (
         40	    "id" TEXT NOT NULL,
         41	    "messageId" TEXT NOT NULL,
         42	    "agentId" TEXT NOT NULL,
         43	    "reactionType" TEXT NOT NULL,
         44	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
         45	
         46	    CONSTRAINT "NegotiationReaction_pkey" PRIMARY KEY ("id")
         47	);
         48	
         49	-- CreateIndex
         50	CREATE UNIQUE INDEX "NegotiationReaction_messageId_agentId_reactionType_key" ON "NegotiationReaction"("messageId", "agentId", "reactionType");
         51	
         52	-- AddForeignKey
         53	ALTER TABLE "NegotiationReaction" ADD CONSTRAINT "NegotiationReaction_messageId_fkey" FOREIGN KEY ("messageId") REFERENCES "NegotiationMessage"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
         54	
         55	-- AddForeignKey
         56	ALTER TABLE "NegotiationReaction" ADD CONSTRAINT "NegotiationReaction_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "Agent"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


==============================================
FILE: ./backend/prisma/migrations/20250423181500_add_scenario_models/migration.sql
==============================================

          1	-- CreateTable
          2	CREATE TABLE "ExampleUserArchetype" (
          3	    "id" TEXT NOT NULL,
          4	    "name" TEXT NOT NULL,
          5	    "description" TEXT NOT NULL,
          6	    "interests" JSONB NOT NULL DEFAULT '[]',
          7	    "concerns" JSONB NOT NULL DEFAULT '[]',
          8	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
          9	    "updatedAt" TIMESTAMP(3) NOT NULL,
         10	
         11	    CONSTRAINT "ExampleUserArchetype_pkey" PRIMARY KEY ("id")
         12	);
         13	
         14	-- CreateTable
         15	CREATE TABLE "ExampleProposal" (
         16	    "id" TEXT NOT NULL,
         17	    "title" TEXT NOT NULL,
         18	    "description" TEXT NOT NULL,
         19	    "category" TEXT NOT NULL,
         20	    "stances" JSONB NOT NULL DEFAULT '[]',
         21	    "probeQuestion" TEXT NOT NULL,
         22	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
         23	    "updatedAt" TIMESTAMP(3) NOT NULL,
         24	
         25	    CONSTRAINT "ExampleProposal_pkey" PRIMARY KEY ("id")
         26	);
         27	
         28	-- CreateIndex
         29	CREATE UNIQUE INDEX "ExampleUserArchetype_name_key" ON "ExampleUserArchetype"("name");
         30	
         31	-- CreateIndex
         32	CREATE UNIQUE INDEX "ExampleProposal_title_key" ON "ExampleProposal"("title");
         33	
         34	-- Add field to Agent table to store scenario preferences
         35	ALTER TABLE "Agent" ADD COLUMN "scenarioPreferences" JSONB DEFAULT '{}';

==============================================
FILE: ./backend/prisma/migrations/20250423201538_add_scenario_models/migration.sql
==============================================

          1	/*
          2	  Warnings:
          3	
          4	  - Made the column `scenarioPreferences` on table `Agent` required. This step will fail if there are existing NULL values in that column.
          5	
          6	*/
          7	-- AlterTable
          8	ALTER TABLE "Agent" ALTER COLUMN "scenarioPreferences" SET NOT NULL;


==============================================
FILE: ./backend/prisma/migrations/20250424054852_add_user_name/migration.sql
==============================================

          1	-- AlterTable
          2	ALTER TABLE "User" ADD COLUMN     "name" TEXT;


==============================================
FILE: ./backend/prisma/migrations/20250425102800_add_negotiation_feedback/migration.sql
==============================================

          1	-- CreateTable
          2	CREATE TABLE "NegotiationFeedback" (
          3	    "id" TEXT NOT NULL,
          4	    "negotiationId" TEXT NOT NULL,
          5	    "agentId" TEXT NOT NULL,
          6	    "userId" TEXT NOT NULL,
          7	    "rating" INTEGER NOT NULL,
          8	    "representationAccuracy" INTEGER NOT NULL,
          9	    "comments" TEXT NOT NULL,
         10	    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
         11	    "updatedAt" TIMESTAMP(3) NOT NULL,
         12	
         13	    CONSTRAINT "NegotiationFeedback_pkey" PRIMARY KEY ("id")
         14	);
         15	
         16	-- CreateIndex
         17	CREATE INDEX "NegotiationFeedback_negotiationId_idx" ON "NegotiationFeedback"("negotiationId");
         18	
         19	-- CreateIndex
         20	CREATE INDEX "NegotiationFeedback_agentId_idx" ON "NegotiationFeedback"("agentId");
         21	
         22	-- CreateIndex
         23	CREATE UNIQUE INDEX "NegotiationFeedback_negotiationId_agentId_key" ON "NegotiationFeedback"("negotiationId", "agentId");
         24	
         25	-- AddForeignKey
         26	ALTER TABLE "NegotiationFeedback" ADD CONSTRAINT "NegotiationFeedback_negotiationId_fkey" FOREIGN KEY ("negotiationId") REFERENCES "NegotiationSession"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
         27	
         28	-- AddForeignKey
         29	ALTER TABLE "NegotiationFeedback" ADD CONSTRAINT "NegotiationFeedback_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "Agent"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

==============================================
FILE: ./backend/prisma/migrations/migration_lock.toml
==============================================

          1	# Please do not edit this file manually
          2	# It should be added in your version-control system (i.e. Git)
          3	provider = "postgresql"

==============================================
FILE: ./backend/prisma/scenario-seed.ts
==============================================

          1	import { PrismaClient } from '@prisma/client';
          2	
          3	const prisma = new PrismaClient();
          4	
          5	/**
          6	 * Seed realistic scenarios based on the NDNEcoldstartscenarios.md file.
          7	 * These will be used during onboarding to create more personalized and relevant questions.
          8	 */
          9	async function seedScenarios() {
         10	  console.log('Seeding realistic scenarios for onboarding...');
         11	
         12	  // Create user archetypes from the scenarios document
         13	  const userArchetypes = [
         14	    {
         15	      name: 'Maria',
         16	      description: 'Downtown retailer who runs a café on 6th Street, politically moderate-left',
         17	      interests: [
         18	        'Supporting local businesses',
         19	        'Downtown vitality and safety',
         20	        'Sustainable infrastructure'
         21	      ],
         22	      concerns: [
         23	        'Homelessness impact on retail',
         24	        'Rising business costs',
         25	        'Tourism promotion'
         26	      ]
         27	    },
         28	    {
         29	      name: 'Bill',
         30	      description: 'Retired veteran on fixed income, property-rich but cash-constrained',
         31	      interests: [
         32	        'Public safety',
         33	        'Property value preservation',
         34	        'Limited tax increases'
         35	      ],
         36	      concerns: [
         37	        'Rising utility costs',
         38	        'Fixed income constraints',
         39	        'Property rights'
         40	      ]
         41	    },
         42	    {
         43	      name: 'Ezra',
         44	      description: '26-year-old environmental graduate student who bikes everywhere',
         45	      interests: [
         46	        'Environmental protection',
         47	        'Active transportation',
         48	        'Climate action'
         49	      ],
         50	      concerns: [
         51	        'Urban sprawl',
         52	        'Car-centric planning',
         53	        'Water quality'
         54	      ]
         55	    },
         56	    {
         57	      name: 'Skylar',
         58	      description: 'Cannabis farmer who operates a rural Tier II grow operation',
         59	      interests: [
         60	        'Agricultural regulations',
         61	        'Water rights',
         62	        'Business-friendly policies'
         63	      ],
         64	      concerns: [
         65	        'Regulatory compliance costs',
         66	        'Water availability',
         67	        'Stigmatization'
         68	      ]
         69	    }
         70	  ];
         71	
         72	  // Create proposals from the scenarios document
         73	  const proposals = [
         74	    {
         75	      title: 'Water-Treatment Plant Funding Gap',
         76	      description: 'Issue a 25-year municipal revenue bond and raise residential water rates 12% to close the $50M shortfall after FEMA\'s BRIC grant was cancelled.',
         77	      category: 'INFRASTRUCTURE',
         78	      stances: [
         79	        {
         80	          perspective: 'Infrastructure-first residents',
         81	          opinion: 'Safe water is non-negotiable; bite the bullet now.',
         82	          supports: true
         83	        },
         84	        {
         85	          perspective: 'Fixed-income seniors',
         86	          opinion: '12% is steep—phase it or find state help.',
         87	          supports: false
         88	        },
         89	        {
         90	          perspective: 'Small-business owners',
         91	          opinion: 'Worry about pass-through cost hikes to restaurants & breweries.',
         92	          supports: false
         93	        }
         94	      ],
         95	      probeQuestion: 'If closing a funding gap means your monthly bill rises ~$6, do you prefer: (a) pay now, (b) slower phased hike, (c) seek new state/federal grants even if construction is delayed)?'
         96	    },
         97	    {
         98	      title: 'Downtown Homeless "Resting Sites" Expansion',
         99	      description: 'Approve two adjacent parking-lot campsites, bringing total capacity to 150 tents, as ordered by the court.',
        100	      category: 'SOCIAL_SERVICES',
        101	      stances: [
        102	        {
        103	          perspective: 'Downtown retail',
        104	          opinion: 'Fears customer flight; supports dispersing camps.',
        105	          supports: false
        106	        },
        107	        {
        108	          perspective: 'Service-provider NGOs',
        109	          opinion: 'Support concentrated sites for easier outreach.',
        110	          supports: true
        111	        },
        112	        {
        113	          perspective: 'Libertarian voters',
        114	          opinion: 'Prefer enforcing anti-camping laws post-Johnson decision.',
        115	          supports: false
        116	        }
        117	      ],
        118	      probeQuestion: 'Which matters more: reducing sidewalk camping city-wide or spreading managed sites across neighborhoods to share impacts?'
        119	    },
        120	    {
        121	      title: 'Wildfire-Risk Utility Surcharge',
        122	      description: 'Endorse Pacific Power\'s plan to add a temporary $2/month surcharge to speed undergrounding and covered-conductor projects (500 mi planned, 100 mi in 2025).',
        123	      category: 'PUBLIC_SAFETY',
        124	      stances: [
        125	        {
        126	          perspective: 'Fire-concerned homeowners',
        127	          opinion: 'Strongly support—cheaper than losing a home.',
        128	          supports: true
        129	        },
        130	        {
        131	          perspective: 'Low-income advocates',
        132	          opinion: 'Want income-based credits first.',
        133	          supports: false
        134	        },
        135	        {
        136	          perspective: 'Outdoor recreation business',
        137	          opinion: 'Favor, emphasize tourism reliability.',
        138	          supports: true
        139	        }
        140	      ],
        141	      probeQuestion: 'Would you accept a dedicated $2 utility fee if it demonstrably cut local wildfire ignition risk by 30%?'
        142	    },
        143	    {
        144	      title: 'Transportation System Plan (TSP) Priority Package',
        145	      description: 'Adopt the TSP\'s "Active Streets" scenario, reallocating $5M from road-widening to bike & sidewalk links near two I-5 interchanges.',
        146	      category: 'TRANSPORTATION',
        147	      stances: [
        148	        {
        149	          perspective: 'Cyclists & students',
        150	          opinion: 'Support—safer routes to school.',
        151	          supports: true
        152	        },
        153	        {
        154	          perspective: 'Commuter drivers',
        155	          opinion: 'Oppose—predict worse congestion.',
        156	          supports: false
        157	        },
        158	        {
        159	          perspective: 'Climate-action group',
        160	          opinion: 'Insist on even bolder mode-shift targets.',
        161	          supports: true
        162	        }
        163	      ],
        164	      probeQuestion: 'Rank these in order of importance for new transportation dollars: smoother car traffic, safer bike/walk routes, expanded city bus service.'
        165	    },
        166	    {
        167	      title: 'Cannabis Compliance Reform',
        168	      description: 'Cut Josephine County\'s marijuana "certificate of compliance" fee from $500 to $250, but add mandatory water-use reporting to address Rogue River withdrawals.',
        169	      category: 'REGULATION',
        170	      stances: [
        171	        {
        172	          perspective: 'Licensed growers',
        173	          opinion: 'Back lower fees, balk at extra paperwork.',
        174	          supports: true
        175	        },
        176	        {
        177	          perspective: 'Irrigation district',
        178	          opinion: 'Wants strict usage audits.',
        179	          supports: false
        180	        },
        181	        {
        182	          perspective: 'Public-health coalition',
        183	          opinion: 'Push for stronger odor-control rules instead.',
        184	          supports: false
        185	        }
        186	      ],
        187	      probeQuestion: 'When regulating local cannabis farms, is affordability for legal growers or tight water-use oversight more important to you?'
        188	    },
        189	    {
        190	      title: 'Lodging-Tax Reallocation',
        191	      description: 'Shift 10% of the city\'s 12% Transient Lodging Tax from tourism marketing to police & fire to avoid a separate levy hike.',
        192	      category: 'BUDGET',
        193	      stances: [
        194	        {
        195	          perspective: 'Hotel/restaurant owners',
        196	          opinion: 'Oppose—fear losing promotional dollars.',
        197	          supports: false
        198	        },
        199	        {
        200	          perspective: 'Public-safety supporters',
        201	          opinion: 'Note voters renew levies every few years anyway—prefer stable base funding.',
        202	          supports: true
        203	        },
        204	        {
        205	          perspective: 'Arts & tourism board',
        206	          opinion: 'Offer compromise—sunset clause after three years.',
        207	          supports: false
        208	        }
        209	      ],
        210	      probeQuestion: 'If you had $100 of lodging-tax revenue, how much would you direct to tourism promotion vs. public safety?'
        211	    }
        212	  ];
        213	
        214	  // Save data to database using prisma
        215	  try {
        216	    // Store archetypes
        217	    for (const archetype of userArchetypes) {
        218	      await prisma.exampleUserArchetype.upsert({
        219	        where: { name: archetype.name },
        220	        update: {
        221	          description: archetype.description,
        222	          interests: archetype.interests,
        223	          concerns: archetype.concerns
        224	        },
        225	        create: {
        226	          name: archetype.name,
        227	          description: archetype.description,
        228	          interests: archetype.interests as any,
        229	          concerns: archetype.concerns as any
        230	        }
        231	      }).catch(e => {
        232	        // If the table doesn't exist yet, log and continue
        233	        console.log(`Note: Could not save archetype - ExampleUserArchetype table may not exist yet: ${e.message}`);
        234	      });
        235	    }
        236	
        237	    // Store proposals
        238	    for (const proposal of proposals) {
        239	      await prisma.exampleProposal.upsert({
        240	        where: { title: proposal.title },
        241	        update: {
        242	          description: proposal.description,
        243	          category: proposal.category,
        244	          stances: proposal.stances as any,
        245	          probeQuestion: proposal.probeQuestion
        246	        },
        247	        create: {
        248	          title: proposal.title,
        249	          description: proposal.description,
        250	          category: proposal.category,
        251	          stances: proposal.stances as any,
        252	          probeQuestion: proposal.probeQuestion
        253	        }
        254	      }).catch(e => {
        255	        // If the table doesn't exist yet, log and continue
        256	        console.log(`Note: Could not save proposal - ExampleProposal table may not exist yet: ${e.message}`);
        257	      });
        258	    }
        259	
        260	    console.log('Scenarios seeded successfully!');
        261	  } catch (error) {
        262	    console.error('Error seeding scenarios:', error);
        263	  } finally {
        264	    await prisma.$disconnect();
        265	  }
        266	}
        267	
        268	seedScenarios().catch(e => {
        269	  console.error('Error running seed script:', e);
        270	  process.exit(1);
        271	});

==============================================
FILE: ./backend/prisma/schema.prisma
==============================================

          1	datasource db {
          2	  provider = "postgresql"
          3	  url      = env("DB_URL")
          4	}
          5	
          6	generator client {
          7	  provider = "prisma-client-js"
          8	}
          9	
         10	model User {
         11	  id               String   @id @default(uuid())
         12	  email            String   @unique
         13	  passwordHash     String
         14	  publicKey        String
         15	  encryptedPrivKey String
         16	  role             String   @default("USER")
         17	  digestFrequency  Int      @default(24)
         18	  digestTone       String   @default("neutral")
         19	  createdAt        DateTime @default(now())
         20	  updatedAt        DateTime @updatedAt
         21	  agent            Agent?
         22	  consents         ConsentEvent[]
         23	  digests          Digest[]
         24	  chatMessages     ChatMessage[]
         25	}
         26	
         27	model Agent {
         28	  id               String   @id @default(uuid())
         29	  userId           String   @unique
         30	  name             String
         31	  color            String
         32	  publicKey        String
         33	  encryptedPrivKey String
         34	  autonomyLevel    Int      @default(0)
         35	  pausedUntil      DateTime?
         36	  alignmentScore   Float    @default(1)
         37	  preferences      Json     @default("{}")
         38	  scenarioPreferences Json  @default("{}")
         39	  createdAt        DateTime @default(now())
         40	  updatedAt        DateTime @updatedAt
         41	
         42	  onboardingCompleted Boolean               @default(false)
         43	  lastInteraction     DateTime?
         44	  userKnowledge       Json                  @default("{}")
         45	
         46	  user                User                  @relation(fields: [userId], references: [id])
         47	  votes               Vote[]
         48	  comments            Comment[]
         49	  consents            ConsentEvent[]
         50	  chatMessages        ChatMessage[]
         51	  negotiationMessages NegotiationMessage[]
         52	  negotiationReactions NegotiationReaction[]
         53	  negotiationFeedback NegotiationFeedback[]
         54	}
         55	
         56	model Proposal {
         57	  id               String   @id @default(uuid())
         58	  title            String
         59	  description      String
         60	  type             String   @default("standard")
         61	  playMode         Boolean  @default(false)
         62	  amount           Float?
         63	  createdByAgentId String
         64	  status           String   @default("open")
         65	  quorum           Int
         66	  threshold        Float    @default(0.5)
         67	  createdAt        DateTime @default(now())
         68	  closeAt          DateTime
         69	  vetoWindowEnd    DateTime
         70	
         71	  negotiationId       String?              @unique
         72	  isNegotiated        Boolean              @default(false)
         73	  negotiationSummary  String?
         74	
         75	  votes               Vote[]
         76	  comments            Comment[]
         77	  playMoneyLedgerEntry PlayMoneyLedgerEntry?
         78	  negotiationSession  NegotiationSession?  @relation(fields: [negotiationId], references: [id])
         79	}
         80	
         81	model Vote {
         82	  id             String   @id @default(uuid())
         83	  proposalId     String
         84	  agentId        String
         85	  value          String
         86	  confidence     Float
         87	  createdAt      DateTime @default(now())
         88	  revokedAt      DateTime?
         89	  overrideByUser Boolean  @default(false)
         90	  overrideReason String?
         91	  proposal       Proposal @relation(fields: [proposalId], references: [id])
         92	  agent          Agent    @relation(fields: [agentId], references: [id])
         93	}
         94	
         95	model Comment {
         96	  id         String   @id @default(uuid())
         97	  proposalId String
         98	  agentId    String
         99	  content    String
        100	  createdAt  DateTime @default(now())
        101	  revokedAt  DateTime?
        102	  proposal   Proposal @relation(fields: [proposalId], references: [id])
        103	  agent      Agent    @relation(fields: [agentId], references: [id])
        104	}
        105	
        106	model Digest {
        107	  id          String   @id @default(uuid())
        108	  userId      String
        109	  content     String
        110	  generatedAt DateTime @default(now())
        111	  user        User     @relation(fields: [userId], references: [id])
        112	}
        113	
        114	model ConsentEvent {
        115	  id        String   @id @default(uuid())
        116	  userId    String
        117	  agentId   String
        118	  action    String
        119	  payload   Json     @default("{}")
        120	  signature String
        121	  createdAt DateTime @default(now())
        122	  user      User     @relation(fields: [userId], references: [id])
        123	  agent     Agent    @relation(fields: [agentId], references: [id])
        124	}
        125	
        126	model SystemConfig {
        127	  id                   Int      @id @default(1)
        128	  defaultModel         String   @default("openai/gpt-4o")
        129	  modelsEndpoint       String   @default("https://openrouter.ai/api/v1/models")
        130	  playMoneyTreasury    Float    @default(100000)
        131	  maxMonetaryNoConsent Float    @default(500)
        132	  keyStorageMode       String   @default("server")
        133	  createdAt            DateTime @default(now())
        134	  updatedAt            DateTime @updatedAt
        135	}
        136	
        137	model AuditLog {
        138	  id        String   @id @default(uuid())
        139	  timestamp DateTime @default(now())
        140	  userId    String
        141	  action    String
        142	  targetId  String?
        143	  details   Json?
        144	}
        145	
        146	model LlmUsageLog {
        147	  id           String   @id @default(uuid())
        148	  agentId      String?
        149	  model        String
        150	  inputTokens  Int
        151	  outputTokens Int
        152	  latencyMs    Int
        153	  outcome      String
        154	  errorMessage String?
        155	  createdAt    DateTime @default(now())
        156	}
        157	
        158	model PlayMoneyLedgerEntry {
        159	  id          String   @id @default(uuid())
        160	  proposalId  String   @unique
        161	  amount      Float
        162	  balanceAfter Float
        163	  createdAt   DateTime @default(now())
        164	  proposal    Proposal @relation(fields: [proposalId], references: [id])
        165	}
        166	
        167	model ChatMessage {
        168	  id        String   @id @default(uuid())
        169	  userId    String
        170	  agentId   String
        171	  content   String
        172	  sender    String   @default("user")
        173	  timestamp DateTime @default(now())
        174	  metadata  Json?
        175	  user      User     @relation(fields: [userId], references: [id])
        176	  agent     Agent    @relation(fields: [agentId], references: [id])
        177	
        178	  @@index([userId])
        179	  @@index([agentId])
        180	  @@index([timestamp])
        181	}
        182	
        183	model NegotiationSession {
        184	  id           String               @id @default(uuid())
        185	  topic        String
        186	  description  String?
        187	  status       String               @default("active")
        188	  startedAt    DateTime             @default(now())
        189	  completedAt  DateTime?
        190	  initiatorId  String
        191	  messages     NegotiationMessage[]
        192	  proposal     Proposal?
        193	  feedback     NegotiationFeedback[]
        194	
        195	  @@index([status])
        196	  @@index([startedAt])
        197	}
        198	
        199	model NegotiationMessage {
        200	  id                 String             @id @default(uuid())
        201	  negotiationId      String
        202	  agentId            String
        203	  content            String
        204	  messageType        String             @default("statement")
        205	  referencedMessageId String?
        206	  metadata           Json?
        207	  timestamp          DateTime           @default(now())
        208	  negotiationSession NegotiationSession @relation(fields: [negotiationId], references: [id], onDelete: Cascade)
        209	  agent              Agent              @relation(fields: [agentId], references: [id])
        210	  reactions          NegotiationReaction[]
        211	
        212	  @@index([negotiationId])
        213	  @@index([agentId])
        214	  @@index([timestamp])
        215	}
        216	
        217	model NegotiationReaction {
        218	  id             String   @id @default(uuid())
        219	  messageId      String
        220	  agentId        String
        221	  reactionType   String
        222	  createdAt      DateTime @default(now())
        223	  negotiationMessage NegotiationMessage @relation(fields: [messageId], references: [id])
        224	  agent          Agent    @relation(fields: [agentId], references: [id])
        225	  @@unique([messageId, agentId, reactionType])
        226	}
        227	
        228	// Example scenarios for onboarding
        229	model ExampleUserArchetype {
        230	  id          String   @id @default(uuid())
        231	  name        String   @unique
        232	  description String
        233	  interests   Json     @default("[]")
        234	  concerns    Json     @default("[]")
        235	  createdAt     DateTime @default(now())
        236	  updatedAt     DateTime @updatedAt
        237	}
        238	
        239	// Feedback model for negotiation agent performance
        240	model NegotiationFeedback {
        241	  id                     String   @id @default(uuid())
        242	  negotiationId          String
        243	  agentId                String
        244	  userId                 String
        245	  rating                 Int      // 1-5 scale
        246	  representationAccuracy Int      // 1-5 scale
        247	  comments               String
        248	  createdAt              DateTime @default(now())
        249	  updatedAt              DateTime @updatedAt
        250	  
        251	  negotiation NegotiationSession @relation(fields: [negotiationId], references: [id])
        252	  agent       Agent             @relation(fields: [agentId], references: [id])
        253	  
        254	  @@index([negotiationId])
        255	  @@index([agentId])
        256	  @@unique([negotiationId, agentId]) // One feedback per agent per negotiation
        257	}
        258	
        259	model ExampleProposal {
        260	  id            String   @id @default(uuid())
        261	  title         String   @unique
        262	  description   String
        263	  category      String
        264	  stances       Json     @default("[]")
        265	  probeQuestion String
        266	  createdAt     DateTime @default(now())
        267	  updatedAt     DateTime @updatedAt
        268	}


==============================================
FILE: ./backend/prisma/seed.js
==============================================

          1	"use strict";
          2	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
          3	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
          4	    return new (P || (P = Promise))(function (resolve, reject) {
          5	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          6	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          7	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          8	        step((generator = generator.apply(thisArg, _arguments || [])).next());
          9	    });
         10	};
         11	var __generator = (this && this.__generator) || function (thisArg, body) {
         12	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
         13	    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
         14	    function verb(n) { return function (v) { return step([n, v]); }; }
         15	    function step(op) {
         16	        if (f) throw new TypeError("Generator is already executing.");
         17	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
         18	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
         19	            if (y = 0, t) op = [op[0] & 2, t.value];
         20	            switch (op[0]) {
         21	                case 0: case 1: t = op; break;
         22	                case 4: _.label++; return { value: op[1], done: false };
         23	                case 5: _.label++; y = op[1]; op = [0]; continue;
         24	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
         25	                default:
         26	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
         27	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
         28	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
         29	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
         30	                    if (t[2]) _.ops.pop();
         31	                    _.trys.pop(); continue;
         32	            }
         33	            op = body.call(thisArg, _);
         34	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
         35	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
         36	    }
         37	};
         38	Object.defineProperty(exports, "__esModule", { value: true });
         39	var client_1 = require("@prisma/client");
         40	var prisma = new client_1.PrismaClient();
         41	function main() {
         42	    return __awaiter(this, void 0, void 0, function () {
         43	        return __generator(this, function (_a) {
         44	            switch (_a.label) {
         45	                case 0: return [4 /*yield*/, prisma.systemConfig.upsert({
         46	                        where: { id: 1 },
         47	                        update: {},
         48	                        create: {},
         49	                    })];
         50	                case 1:
         51	                    _a.sent();
         52	                    return [2 /*return*/];
         53	            }
         54	        });
         55	    });
         56	}
         57	main()
         58	    .catch(function (e) {
         59	    console.error(e);
         60	    process.exit(1);
         61	})
         62	    .finally(function () { return __awaiter(void 0, void 0, void 0, function () {
         63	    return __generator(this, function (_a) {
         64	        switch (_a.label) {
         65	            case 0: return [4 /*yield*/, prisma.$disconnect()];
         66	            case 1:
         67	                _a.sent();
         68	                return [2 /*return*/];
         69	        }
         70	    });
         71	}); });


==============================================
FILE: ./backend/prisma/seed.ts
==============================================

          1	import { PrismaClient } from '@prisma/client';
          2	
          3	const prisma = new PrismaClient();
          4	
          5	async function main() {
          6	  await prisma.systemConfig.upsert({
          7	    where: { id: 1 },
          8	    update: {},
          9	    create: {},
         10	  });
         11	}
         12	
         13	main()
         14	  .catch((e) => {
         15	    console.error(e);
         16	    process.exit(1);
         17	  })
         18	  .finally(async () => {
         19	    await prisma.$disconnect();
         20	  });


==============================================
FILE: ./backend/src/index.ts
==============================================

          1	import dotenv from 'dotenv';
          2	import express from 'express';
          3	import helmet from 'helmet';
          4	import cors from 'cors';
          5	import logger from './utils/logger';
          6	import errorHandler from './middleware/errorHandler';
          7	import authRouter from './routes/auth';
          8	import keyRouter from './routes/key';
          9	import proposalRouter from './routes/proposal';
         10	import voteRouter from './routes/vote';
         11	import pauseAgentRouter from './routes/agents/pauseAgentHandler';
         12	import feedbackRouter from './routes/agents/feedbackHandler'; // Import the feedback router
         13	import onboardingRouter from './routes/onboarding'; // Import the onboarding router
         14	import adminRouter from './routes/admin'; // Import the admin router
         15	import chatRouter from './routes/chat'; // Import the chat router
         16	import negotiationRouter from './routes/negotiation'; // Import the negotiation router
         17	import negotiationFeedbackRouter from './routes/feedback'; // Import the negotiation feedback router
         18	import agentMeRouter from './routes/agents/me'; // Import the agent "me" router
         19	import agentRouter from './routes/agents/index'; // Import the main agent router
         20	
         21	import issuesRouter from './routes/issues';
         22	
         23	dotenv.config();
         24	
         25	const requiredEnv = ['DB_URL', 'REDIS_URL', 'JWT_SECRET'];
         26	requiredEnv.forEach(key => {
         27	  if (!process.env[key]) {
         28	    logger.error(`Missing env var: ${key}`);
         29	    process.exit(1);
         30	  }
         31	});
         32	
         33	const app = express();
         34	const port = process.env.PORT || 4000;
         35	
         36	app.use(helmet());
         37	// Log configured CORS origins for debugging
         38	const corsOrigins = process.env.CORS_ORIGINS?.split(',') || ['http://localhost:5173', 'http://localhost:5174'];
         39	// Add ports 5173-5175 explicitly for dev purposes
         40	const extendedCorsOrigins = [...corsOrigins, 'http://localhost:5175'];
         41	logger.info(`Configured CORS origins: ${extendedCorsOrigins}`);
         42	
         43	app.use(cors({
         44	  origin: extendedCorsOrigins,
         45	  credentials: true, // Allow cookies if needed
         46	  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
         47	  allowedHeaders: ['Content-Type', 'Authorization']
         48	}));
         49	app.use(express.json());
         50	app.use('/api/auth', authRouter);
         51	app.use('/api/keys', keyRouter);
         52	app.use('/api/proposals', proposalRouter);
         53	app.use('/api', voteRouter);
         54	app.use('/api/agents', pauseAgentRouter);
         55	app.use('/api/agents', feedbackRouter); // Mount the feedback router
         56	app.use('/api/onboarding', onboardingRouter); // Mount the onboarding router
         57	app.use('/api/admin', adminRouter); // Mount the admin router
         58	app.use('/api/chat', chatRouter); // Mount the chat router
         59	app.use('/api', negotiationRouter); // Mount the negotiation router
         60	app.use('/api', negotiationFeedbackRouter); // Mount the negotiation feedback router
         61	app.use('/api/agents', agentMeRouter); // Mount the agent "me" router
         62	app.use('/api/agents', agentRouter); // Mount the main agent router
         63	app.use('/api/issues', issuesRouter); // Mount the issues router
         64	
         65	app.get('/health', (_req, res) => {
         66	  res.status(200).json({ status: 'ok' });
         67	});
         68	
         69	app.get('/api/health', (_req, res) => {
         70	  res.status(200).json({ status: 'ok' });
         71	});
         72	
         73	app.get('/', (_req, res) => {
         74	  res.send('NDNE backend is running');
         75	});
         76	
         77	// 404 handler - must come after all routes
         78	app.use((_req, res) => {
         79	  res.status(404).json({ status: 'error', message: 'Resource not found' });
         80	});
         81	
         82	// Global error handler - must be the last middleware
         83	app.use(errorHandler);
         84	
         85	app.listen(port, () => {
         86	  logger.info(`NDNE backend listening at http://localhost:${port}`);
         87	});
         88	
         89	// Handle unhandled promise rejections
         90	process.on('unhandledRejection', (reason, promise) => {
         91	  logger.error('Unhandled Promise Rejection', { reason, promise });
         92	  // Don't exit the process to maintain availability, but log it
         93	});
         94	
         95	// Handle uncaught exceptions
         96	process.on('uncaughtException', (error) => {
         97	  logger.error('Uncaught Exception', { error });
         98	  // Give the logger time to process the error before exiting
         99	  setTimeout(() => {
        100	    process.exit(1);
        101	  }, 1000);
        102	});


==============================================
FILE: ./backend/src/jobs/digest-worker.ts
==============================================

          1	import { Worker, Job } from 'bullmq';
          2	import IORedis from 'ioredis';
          3	import { PrismaClient, User, Agent, Vote, Proposal } from '@prisma/client'; // Import specific types
          4	
          5	// Ensure REDIS_URL is defined in your .env file
          6	const connection = new IORedis(process.env.REDIS_URL || 'redis://localhost:6379', {
          7	  maxRetriesPerRequest: null // Prevent immediate job failure on connection issues
          8	});
          9	
         10	const prisma = new PrismaClient();
         11	
         12	const queueName = 'digestQueue';
         13	
         14	console.log(`Starting Digest Worker for queue: ${queueName}`);
         15	
         16	// Define the type for the user object fetched with agent
         17	type UserWithAgent = User & { agent: Agent | null };
         18	
         19	// Define the structure for fetched activity
         20	interface DigestActivity {
         21	    agentVotes: (Vote & { proposal: Proposal })[];
         22	    newProposals: Proposal[];
         23	    vetoAlerts: (Proposal & { agentVote: Vote | null })[]; // Proposals needing potential veto
         24	}
         25	
         26	
         27	// Define the worker
         28	const worker = new Worker(queueName, async (job: Job) => {
         29	  console.log(`Processing job ${job.id} of type ${job.name}`);
         30	  const { userId } = job.data;
         31	
         32	  if (!userId) {
         33	    console.error(`Job ${job.id} is missing userId.`);
         34	    throw new Error(`Job ${job.id} is missing userId.`);
         35	  }
         36	
         37	  try {
         38	    // 1. Fetch user and their preferences
         39	    const user = await prisma.user.findUnique({
         40	      where: { id: userId },
         41	      include: { agent: true } // Include agent
         42	    });
         43	
         44	    if (!user || !user.agent) { // Ensure user and agent exist
         45	      console.error(`User ${userId} or their agent not found for job ${job.id}.`);
         46	      return { status: 'skipped', reason: 'User or agent not found' };
         47	    }
         48	
         49	    // 2. Determine time window for fetching activity
         50	    const frequencyHours = user.digestFrequency || 24; // Default to 24 hours
         51	    const sinceDate = new Date(Date.now() - frequencyHours * 60 * 60 * 1000);
         52	    const now = new Date();
         53	    const vetoLookaheadDate = new Date(Date.now() + frequencyHours * 60 * 60 * 1000); // Look ahead for veto warnings
         54	
         55	    // 3. Fetch relevant activity
         56	    const agentId = user.agent.id;
         57	    const activity: DigestActivity = {
         58	        agentVotes: [],
         59	        newProposals: [],
         60	        vetoAlerts: []
         61	    };
         62	
         63	    // Fetch agent votes within the window
         64	    activity.agentVotes = await prisma.vote.findMany({
         65	        where: {
         66	            agentId: agentId,
         67	            createdAt: { gte: sinceDate }
         68	        },
         69	        include: { proposal: true }, // Include proposal details
         70	        orderBy: { createdAt: 'desc' }
         71	    });
         72	
         73	    // Fetch new proposals created within the window
         74	    activity.newProposals = await prisma.proposal.findMany({
         75	        where: {
         76	            createdAt: { gte: sinceDate }
         77	        },
         78	        orderBy: { createdAt: 'desc' }
         79	    });
         80	
         81	    // Fetch proposals nearing veto window end where agent voted and user hasn't overridden
         82	    const potentiallyVetoableProposals = await prisma.proposal.findMany({
         83	        where: {
         84	            status: 'open', // Only open proposals
         85	            vetoWindowEnd: {
         86	                gte: now, // Veto window hasn't passed
         87	                lte: vetoLookaheadDate // Veto window ends within the lookahead period
         88	            },
         89	            // Ensure the agent has voted on this proposal
         90	            votes: {
         91	                some: {
         92	                    agentId: agentId,
         93	                    overrideByUser: false // And the user hasn't already overridden
         94	                }
         95	            }
         96	        },
         97	        include: {
         98	            // Include the specific vote by the agent for context
         99	            votes: {
        100	                where: { agentId: agentId }
        101	            }
        102	        },
        103	        orderBy: { vetoWindowEnd: 'asc' }
        104	    });
        105	    // Map to expected structure, ensuring agentVote is attached
        106	    activity.vetoAlerts = potentiallyVetoableProposals.map(p => ({
        107	        ...p,
        108	        agentVote: p.votes.find(v => v.agentId === agentId) || null
        109	    }));
        110	
        111	
        112	    // 4. Generate digest content (consider tone)
        113	    // Use agent-service to generate digest summary
        114	    const digestContent = await import('../services/agent-service').then(({ generateDigest }) =>
        115	      generateDigest(user.id, activity, user.agent?.id)
        116	    );
        117	  
        118	    // Don't save empty digests
        119	    if (!digestContent.trim().endsWith(":\n\n") && !digestContent.trim().endsWith("update:\n\n") && !digestContent.trim().endsWith("Report:\n\n")) {
        120	        // 5. Store the digest in the database
        121	        await prisma.digest.create({
        122	          data: {
        123	            userId: user.id,
        124	            content: digestContent,
        125	            // generatedAt is handled by @default(now())
        126	          }
        127	        });
        128	        console.log(`Successfully processed and stored digest job ${job.id} for user ${userId}`);
        129	    } else {
        130	        console.log(`No new activity for user ${userId}, skipping digest storage for job ${job.id}.`);
        131	    }
        132	
        133	
        134	    return { status: 'completed', userId: userId };
        135	
        136	    // 6. TODO: Trigger email/send mechanism (separate task/service)
        137	
        138	  } catch (error) {
        139	    console.error(`Error processing job ${job.id} for user ${userId}:`, error);
        140	    // Throw the error so BullMQ handles retries/failure according to queue settings
        141	    throw error;
        142	  }
        143	}, { connection });
        144	
        145	// --- Helper Functions ---
        146	
        147	function formatDateTime(date: Date | null | undefined): string {
        148	    if (!date) return 'N/A';
        149	    return date.toLocaleString('en-US', { dateStyle: 'short', timeStyle: 'short' });
        150	}
        151	
        152	// Generate the digest content based on activity and user tone preference
        153	function generateDigest(user: UserWithAgent, activity: DigestActivity): string {
        154	  let content = "";
        155	
        156	  // Add Veto Alerts first
        157	  if (activity.vetoAlerts.length > 0) {
        158	    content += "--- Veto Window Alerts ---\n";
        159	    activity.vetoAlerts.forEach(p => {
        160	      content += `Proposal "${p.title}" (ID: ${p.id.substring(0, 8)}) requires your review.\n`;
        161	      content += `  - Your agent voted: ${p.agentVote?.value.toUpperCase() || 'N/A'}\n`;
        162	      content += `  - Veto window ends: ${formatDateTime(p.vetoWindowEnd)}\n`;
        163	    });
        164	    content += "\n";
        165	  }
        166	
        167	  // Add Agent Votes
        168	  if (activity.agentVotes.length > 0) {
        169	    content += "--- Recent Agent Votes ---\n";
        170	    activity.agentVotes.forEach(v => {
        171	      content += `On proposal "${v.proposal.title}" (ID: ${v.proposalId.substring(0, 8)}):\n`;
        172	      content += `  - Agent voted: ${v.value.toUpperCase()} (Confidence: ${v.confidence * 100}%)\n`;
        173	      if (v.overrideByUser) {
        174	        content += `  - !! You overrode this vote. Reason: ${v.overrideReason || 'Not specified'}\n`;
        175	      }
        176	      content += `  - Voted at: ${formatDateTime(v.createdAt)}\n`;
        177	    });
        178	    content += "\n";
        179	  }
        180	
        181	  // Add New Proposals
        182	  if (activity.newProposals.length > 0) {
        183	    content += "--- New Proposals ---\n";
        184	    activity.newProposals.forEach(p => {
        185	      content += `Title: "${p.title}" (ID: ${p.id.substring(0, 8)})\n`;
        186	      content += `  - Type: ${p.type}${p.playMode ? ' (Play Money)' : ''}\n`;
        187	      content += `  - Created: ${formatDateTime(p.createdAt)}\n`;
        188	      content += `  - Closes: ${formatDateTime(p.closeAt)}\n`;
        189	    });
        190	    content += "\n";
        191	  }
        192	
        193	  // Add Comments - TODO: Fetch and add relevant comments if needed later
        194	
        195	  // Add prefix based on tone only if there is content
        196	  if (content) {
        197	      let prefix = "";
        198	      switch (user.digestTone) {
        199	        case 'friendly':
        200	          prefix = `Hey ${user.email}! Here's your latest update:\n\n`;
        201	          break;
        202	        case 'formal':
        203	          prefix = `Dear User,\nPlease find your scheduled digest below:\n\n`;
        204	          break;
        205	        default: // neutral
        206	          prefix = `Digest Report:\n\n`;
        207	      }
        208	      return prefix + content;
        209	  } else {
        210	      // Return an empty string or a "no activity" message based on tone
        211	       switch (user.digestTone) {
        212	        case 'friendly':
        213	          return `Hey ${user.email}! Nothing new to report for this period.\n\n`;
        214	        case 'formal':
        215	          return `Dear User,\nThere has been no reportable activity during this digest period.\n\n`;
        216	        default: // neutral
        217	          return `Digest Report:\n\nNo new activity.\n`;
        218	      }
        219	  }
        220	}
        221	
        222	
        223	// --- Event Listeners for Logging ---
        224	
        225	worker.on('completed', (job: Job, result: any) => {
        226	  console.log(`Job ${job.id} completed successfully. Result:`, result);
        227	});
        228	
        229	worker.on('failed', (job: Job | undefined, err: Error) => {
        230	  if (job) {
        231	    console.error(`Job ${job.id} failed with error: ${err.message}`);
        232	  } else {
        233	    console.error(`A job failed with error: ${err.message}`);
        234	  }
        235	});
        236	
        237	worker.on('error', (err: Error) => {
        238	  console.error('Worker encountered an error:', err);
        239	});
        240	
        241	console.log('Digest Worker initialized and listening for jobs.');
        242	
        243	// Graceful shutdown
        244	process.on('SIGINT', async () => {
        245	  console.log('Closing Digest Worker...');
        246	  await worker.close();
        247	  await connection.quit();
        248	  await prisma.$disconnect();
        249	  console.log('Digest Worker closed.');
        250	  process.exit(0);
        251	});

==============================================
FILE: ./backend/src/middleware/errorHandler.ts
==============================================

          1	import { Request, Response, NextFunction, ErrorRequestHandler } from 'express';
          2	import logger from '../utils/logger';
          3	import { HttpError } from '../utils/HttpError';
          4	
          5	/**
          6	 * Express error handling middleware.
          7	 * Catches errors passed via next(error), logs them, and sends a generic
          8	 * error response to the client.
          9	 */
         10	const errorHandler: ErrorRequestHandler = (err, req, res, next) => {
         11	  // Check if this is our custom HttpError
         12	  const isHttpError = err instanceof HttpError;
         13	  
         14	  // Get status code, defaulting to 500 if not specified
         15	  const statusCode = err.statusCode || 500;
         16	
         17	  // Determine message based on environment and error type
         18	  const responseMessage = process.env.NODE_ENV === 'production' && statusCode >= 500
         19	    ? 'Internal Server Error' // Hide detailed server errors in production
         20	    : err.message || 'An unexpected error occurred';
         21	
         22	  // Log the error with Winston
         23	  logger.error('Error caught by handler', {
         24	    message: err.message,
         25	    stack: err.stack,
         26	    statusCode,
         27	    url: req.originalUrl,
         28	    method: req.method,
         29	    ip: req.ip,
         30	    httpError: isHttpError,
         31	    // Include any custom details if present
         32	    ...(isHttpError && err.details && { details: err.details }),
         33	  });
         34	
         35	  // Send response to client
         36	  res.status(statusCode).json({
         37	    status: 'error',
         38	    message: responseMessage,
         39	    // Only include these details in non-production or for client errors (4xx)
         40	    ...(process.env.NODE_ENV !== 'production' && {
         41	      stack: err.stack,
         42	      ...(isHttpError && err.details && { details: err.details })
         43	    }),
         44	  });
         45	
         46	  // Note: We don't call next() here because the response is already sent.
         47	};
         48	
         49	export default errorHandler;

==============================================
FILE: ./backend/src/middleware/requireAdmin.ts
==============================================

          1	import { Request, Response, NextFunction } from 'express';
          2	import { PrismaClient, Role } from '@prisma/client'; // Import Role enum
          3	
          4	const prisma = new PrismaClient();
          5	
          6	// Extend Request type to include user from requireAuth middleware
          7	interface AuthenticatedRequest extends Request {
          8	    user?: { userId: string; [key: string]: any };
          9	}
         10	
         11	/**
         12	 * Middleware to ensure the authenticated user has the ADMIN role.
         13	 * Requires JWT authentication (requireAuth) to run first.
         14	 */
         15	export async function requireAdmin(req: AuthenticatedRequest, res: Response, next: NextFunction) {
         16	    const userId = req.user?.userId;
         17	
         18	    if (!userId) {
         19	        // Should be caught by requireAuth, but good practice to check
         20	        return res.status(401).json({ error: 'User not authenticated.' });
         21	    }
         22	
         23	    try {
         24	        const user = await prisma.user.findUnique({
         25	            where: { id: userId },
         26	            select: { role: true } // Only select the role
         27	        });
         28	
         29	        if (!user) {
         30	            // User existed during JWT validation but not now? Unlikely but possible.
         31	            return res.status(401).json({ error: 'Authenticated user not found.' });
         32	        }
         33	
         34	        if (user.role !== Role.ADMIN) {
         35	            console.warn(`Forbidden: User ${userId} attempted admin action without ADMIN role.`);
         36	            return res.status(403).json({ error: 'Forbidden: Requires admin privileges.' });
         37	        }
         38	
         39	        // User is an admin, proceed
         40	        next();
         41	
         42	    } catch (error) {
         43	        console.error(`Error checking admin role for user ${userId}:`, error);
         44	        res.status(500).json({ error: 'Internal server error during authorization check.' });
         45	    }
         46	}

==============================================
FILE: ./backend/src/middleware/requireAuth.ts
==============================================

          1	import { Request, Response, NextFunction } from 'express';
          2	import jwt from 'jsonwebtoken';
          3	
          4	// Define the structure of the JWT payload expected after verification
          5	export interface UserJWTPayload {
          6	    userId: string;
          7	    agentId: string;
          8	    // Add other fields from JWT payload if necessary
          9	    [key: string]: any;
         10	}
         11	
         12	// Extend Express Request type to include the decoded user payload
         13	export interface AuthenticatedRequest extends Request {
         14	    user?: UserJWTPayload;
         15	}
         16	
         17	/**
         18	 * Middleware to verify JWT token from Authorization header.
         19	 * Attaches the decoded payload to req.user upon successful verification.
         20	 */
         21	export function requireAuth(req: AuthenticatedRequest, res: Response, next: NextFunction) {
         22	  const auth = req.headers.authorization;
         23	  console.log('[DEBUG-AUTH] Authorization header present:', !!auth);
         24	  
         25	  // Log URL being accessed to trace authentication issues
         26	  console.log('[DEBUG-AUTH] Request to protected endpoint:', req.method, req.originalUrl);
         27	
         28	  if (!auth || !auth.startsWith('Bearer ')) {
         29	      console.warn('[DEBUG-AUTH] Missing or invalid Authorization header format');
         30	      return res.status(401).json({ error: 'Missing or invalid Authorization header.' });
         31	  }
         32	
         33	  const token = auth.split(' ')[1];
         34	  console.log('[DEBUG-AUTH] Token length:', token.length);
         35	  console.log('[DEBUG-AUTH] Token prefix:', token.substring(0, 15) + '...');
         36	  
         37	  try {
         38	    const secret = process.env.JWT_SECRET;
         39	    if (!secret) {
         40	        console.error('[DEBUG-AUTH-CRITICAL] JWT_SECRET environment variable is not set.');
         41	        return res.status(500).json({ error: 'Server configuration error.' });
         42	    }
         43	    
         44	    // Log some details about the JWT secret (safely)
         45	    console.log('[DEBUG-AUTH] Using JWT secret with length:', secret.length);
         46	    console.log('[DEBUG-AUTH] JWT secret first/last chars:',
         47	      `${secret.substring(0, 3)}...${secret.substring(secret.length - 3)}`);
         48	    
         49	    // Add extra validation to prevent using the placeholder secret
         50	    if (secret === 'change-me') {
         51	      console.error('[DEBUG-AUTH-CRITICAL] Using placeholder JWT_SECRET "change-me"');
         52	      return res.status(500).json({ error: 'Server configuration error: Invalid JWT secret' });
         53	    }
         54	    
         55	    // Verify the token and cast the payload to our defined interface
         56	    const payload = jwt.verify(token, secret) as UserJWTPayload;
         57	    
         58	    // Validate payload has expected properties
         59	    if (!payload.userId || !payload.agentId) {
         60	      console.error('[DEBUG-AUTH-CRITICAL] Token payload missing required fields:', payload);
         61	      return res.status(401).json({ error: 'Invalid token payload.' });
         62	    }
         63	    
         64	    req.user = payload; // Attach user payload
         65	    console.log('[DEBUG-AUTH] Authenticated user:', {
         66	      userId: payload.userId,
         67	      agentId: payload.agentId,
         68	      iat: payload.iat,
         69	      exp: payload.exp
         70	    });
         71	    
         72	    next();
         73	  } catch (error) {
         74	    const isTokenExpired = error instanceof jwt.TokenExpiredError;
         75	    const isInvalidToken = error instanceof jwt.JsonWebTokenError;
         76	    
         77	    console.error('[DEBUG-AUTH-CRITICAL] Token verification failed:', {
         78	      error: error instanceof Error ? error.message : String(error),
         79	      type: isTokenExpired ? 'TokenExpiredError' :
         80	            isInvalidToken ? 'JsonWebTokenError' : 'Other',
         81	      tokenLength: token.length,
         82	      tokenPrefix: token.substring(0, 15) + '...'
         83	    });
         84	    
         85	    // Handle specific JWT errors with better error messages
         86	    if (isTokenExpired) {
         87	      return res.status(401).json({ error: 'Token has expired. Please login again.' });
         88	    } else if (isInvalidToken) {
         89	      return res.status(401).json({ error: 'Invalid token. Please login again.' });
         90	    }
         91	    
         92	    // Generic error response as fallback
         93	    res.status(401).json({ error: 'Authentication failed.' });
         94	  }
         95	}

==============================================
FILE: ./backend/src/middleware/verifySignature.ts
==============================================

          1	import { Request, Response, NextFunction } from 'express';
          2	import { PrismaClient } from '@prisma/client';
          3	import * as ed from '@noble/ed25519'; // Use ESM import style
          4	import { bytesToHex, hexToBytes } from '@noble/hashes/utils'; // For hex conversion
          5	
          6	const prisma = new PrismaClient();
          7	
          8	// Extend Request type to include user from requireAuth middleware
          9	interface AuthenticatedRequest extends Request {
         10	    user?: { userId: string; [key: string]: any };
         11	}
         12	
         13	/**
         14	 * Middleware to verify an Ed25519 signature provided in the X-Signature header.
         15	 * Assumes the request body is the signed payload (serialized as JSON string).
         16	 * Requires JWT authentication (requireAuth) to run first to identify the user.
         17	 */
         18	export async function verifySignature(req: AuthenticatedRequest, res: Response, next: NextFunction) {
         19	    const signatureHex = req.headers['x-signature'] as string;
         20	    const userId = req.user?.userId;
         21	
         22	    if (!signatureHex) {
         23	        return res.status(400).json({ error: 'Missing X-Signature header.' });
         24	    }
         25	
         26	    if (!userId) {
         27	        // Should be caught by requireAuth, but good practice to check
         28	        return res.status(401).json({ error: 'User not authenticated.' });
         29	    }
         30	
         31	    // Important: Ensure body-parser (like express.json()) has run BEFORE this middleware
         32	    if (!req.body) {
         33	        console.error('verifySignature middleware requires request body, but req.body is missing. Ensure express.json() runs first.');
         34	        return res.status(500).json({ error: 'Server configuration error: Missing request body.' });
         35	    }
         36	
         37	    try {
         38	        // 1. Fetch the user's public key
         39	        const user = await prisma.user.findUnique({
         40	            where: { id: userId },
         41	            select: { publicKey: true } // Only select the public key
         42	        });
         43	
         44	        if (!user || !user.publicKey) {
         45	            return res.status(401).json({ error: 'User public key not found or user does not exist.' });
         46	        }
         47	
         48	        // 2. Prepare the message that was signed
         49	        //    Crucially, this MUST match exactly how the client signed it.
         50	        //    Typically, the raw JSON string of the request body is signed.
         51	        const message = JSON.stringify(req.body);
         52	        const messageBytes = new TextEncoder().encode(message); // Convert message string to Uint8Array
         53	
         54	        // 3. Convert hex signature and public key to bytes
         55	        const signatureBytes = hexToBytes(signatureHex);
         56	        const publicKeyBytes = hexToBytes(user.publicKey);
         57	
         58	        // 4. Verify the signature (Note: verify is synchronous)
         59	        const isValid = ed.verify(signatureBytes, messageBytes, publicKeyBytes);
         60	
         61	        if (!isValid) {
         62	            console.warn(`Signature verification failed for user ${userId}`);
         63	            return res.status(403).json({ error: 'Invalid signature.' });
         64	        }
         65	
         66	        // Signature is valid, proceed to the next handler
         67	        console.log(`Signature verified successfully for user ${userId}`);
         68	        next();
         69	
         70	    } catch (error: any) {
         71	        console.error('Error during signature verification:', error);
         72	        // Handle specific errors like invalid hex format
         73	        if (error.message?.includes('Invalid hex string')) {
         74	             return res.status(400).json({ error: 'Invalid signature format.' });
         75	        }
         76	        res.status(500).json({ error: 'Internal server error during signature verification.' });
         77	    }
         78	}

==============================================
FILE: ./backend/src/routes/admin.ts
==============================================

          1	import { Router, Request, Response } from 'express';
          2	import { PrismaClient, Prisma } from '@prisma/client';
          3	import axios from 'axios'; // Ensure axios is imported
          4	import { requireAuth, AuthenticatedRequest } from '../middleware/requireAuth'; // Import from centralized middleware
          5	import { requireAdmin } from '../middleware/requireAdmin'; // Import the admin guard
          6	
          7	const prisma = new PrismaClient();
          8	const router = Router();
          9	
         10	// In-memory cache for LLM models
         11	let cachedModels: { id: string; name: string }[] = [];
         12	let cacheTimestamp = 0;
         13	const CACHE_TTL = 60 * 60 * 1000; // 1 hour in milliseconds
         14	
         15	// Define body for setting default model
         16	interface SetModelBody {
         17	    defaultModel: string;
         18	}
         19	
         20	// Helper function for Audit Logging
         21	async function logAdminAction(userId: string, action: string, details?: Prisma.InputJsonValue, targetId?: string) {
         22	    try {
         23	        await prisma.auditLog.create({
         24	            data: {
         25	                userId,
         26	                action,
         27	                details,
         28	                targetId,
         29	            }
         30	        });
         31	        console.log(`Audit log created for action: ${action} by user ${userId}`);
         32	    } catch (error) {
         33	        console.error(`Failed to create audit log for action ${action} by user ${userId}:`, error);
         34	        // Decide if failure to log should block the action or just be logged
         35	    }
         36	}
         37	
         38	
         39	// PUT /api/admin/model - Set the default LLM model
         40	// Requires authentication AND admin role
         41	router.put('/model', requireAuth, requireAdmin, async (req: AuthenticatedRequest, res: Response) => {
         42	    const { defaultModel } = req.body as SetModelBody;
         43	    const adminUserId = req.user?.userId;
         44	
         45	    if (!adminUserId) {
         46	        return res.status(401).json({ error: 'Admin user ID not found in token.' });
         47	    }
         48	
         49	    if (!defaultModel || typeof defaultModel !== 'string') {
         50	        return res.status(400).json({ error: 'Missing or invalid defaultModel in request body.' });
         51	    }
         52	
         53	    try {
         54	        const currentConfig = await prisma.systemConfig.findUnique({
         55	             where: { id: 1 } // Assuming config has ID 1
         56	        });
         57	        const previousModel = currentConfig?.defaultModel;
         58	
         59	        const updatedConfig = await prisma.systemConfig.update({
         60	            where: { id: 1 },
         61	            data: { defaultModel: defaultModel },
         62	        });
         63	
         64	        await logAdminAction(
         65	            adminUserId,
         66	            'UPDATE_DEFAULT_MODEL',
         67	            { previousModel: previousModel, newModel: defaultModel },
         68	            'SystemConfig:1'
         69	        );
         70	
         71	        res.status(200).json({ message: 'Default model updated successfully.', newModel: updatedConfig.defaultModel });
         72	
         73	    } catch (error) {
         74	        console.error('Error updating default model:', error);
         75	         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
         76	             return res.status(404).json({ error: 'System configuration not found.' });
         77	        }
         78	        res.status(500).json({ error: 'Internal server error updating default model.' });
         79	    }
         80	});
         81	
         82	// GET /api/admin/models - Fetch list of available LLM models
         83	// Requires authentication AND admin role
         84	router.get('/models', requireAuth, requireAdmin, async (_req: AuthenticatedRequest, res: Response) => {
         85	    const modelsEndpoint = process.env.OPENROUTER_MODELS_ENDPOINT || 'https://openrouter.ai/api/v1/models'; // Fallback URL
         86	
         87	    try {
         88	        const now = Date.now();
         89	        // Return cached models if cache is valid
         90	        if (cachedModels.length > 0 && now - cacheTimestamp < CACHE_TTL) {
         91	            console.log('Returning cached models from cache');
         92	            return res.status(200).json(cachedModels);
         93	        }
         94	        console.log(`Fetching models from ${modelsEndpoint}`);
         95	        let modelsFromUpstream;
         96	        try {
         97	            const response = await axios.get(modelsEndpoint, {
         98	                headers: {
         99	                    'Accept': 'application/json',
        100	                }
        101	            });
        102	            if (response.status !== 200 || !response.data || !response.data.data) {
        103	                throw new Error(`Unexpected response: ${response.status}`);
        104	            }
        105	            modelsFromUpstream = response.data.data.map((model: any) => ({
        106	                id: model.id,
        107	                name: model.name || model.id,
        108	            }));
        109	            // Update cache
        110	            cachedModels = modelsFromUpstream;
        111	            cacheTimestamp = now;
        112	            return res.status(200).json(modelsFromUpstream);
        113	        } catch (fetchError: any) {
        114	            console.error('Error fetching models, attempting fallback:', fetchError);
        115	            if (cachedModels.length > 0) {
        116	                console.log('Returning stale cached models');
        117	                return res.status(200).json(cachedModels);
        118	            }
        119	            // No cache available, return error
        120	            if (axios.isAxiosError(fetchError) && fetchError.response) {
        121	                return res.status(fetchError.response.status || 502).json({ error: 'Failed to fetch models due to upstream error.', details: fetchError.response.data });
        122	            }
        123	            return res.status(500).json({ error: 'Internal server error fetching LLM models.' });
        124	        }
        125	
        126	    } catch (error: any) {
        127	        console.error('Error fetching LLM models:', error.message);
        128	        if (axios.isAxiosError(error) && error.response) {
        129	            console.error('Upstream error details:', error.response.status, error.response.data);
        130	             return res.status(error.response.status || 502).json({ error: 'Failed to fetch models due to upstream error.', details: error.response.data });
        131	        }
        132	        res.status(500).json({ error: 'Internal server error fetching LLM models.' });
        133	    }
        134	});
        135	
        136	
        137	// GET /api/admin (placeholder index)
        138	router.get('/', requireAuth, requireAdmin, (_req, res) => {
        139	    res.json({ message: 'Admin endpoint index. Add specific endpoints as needed.' });
        140	});
        141	
        142	
        143	export default router;

==============================================
FILE: ./backend/src/routes/agents/feedbackHandler.ts
==============================================

          1	import { Router, Request, Response } from 'express';
          2	import { PrismaClient } from '@prisma/client';
          3	// Remove jwt import
          4	import { requireAuth, AuthenticatedRequest } from '../../middleware/requireAuth'; // Import centralized auth
          5	
          6	const prisma = new PrismaClient();
          7	const router = Router();
          8	
          9	// Remove local requireAuth definition
         10	
         11	interface FeedbackRequestBody {
         12	  voteId?: string;
         13	  commentId?: string;
         14	  reason: string; // Reason for the override/feedback
         15	}
         16	
         17	// AuthenticatedRequest is now imported, but we need to ensure it includes the params type
         18	// Let's adjust the usage directly in the route handler signature instead of redefining the interface here.
         19	
         20	
         21	// POST /api/agents/:id/feedback - Apply requireAuth middleware
         22	// Use AuthenticatedRequest directly, adding the specific params type inline
         23	router.post('/:id/feedback', requireAuth, async (req: AuthenticatedRequest & Request<{ id: string }, {}, FeedbackRequestBody>, res: Response) => {
         24	  const agentIdFromParam = req.params.id;
         25	  const { voteId, commentId, reason } = req.body;
         26	  
         27	  // Add detailed logging for debugging
         28	  console.log(`[DEBUG] Feedback request received for agent ${agentIdFromParam}`);
         29	  console.log(`[DEBUG] Request body:`, JSON.stringify({voteId, commentId, reason}));
         30	  console.log(`[DEBUG] Authenticated user:`, JSON.stringify(req.user));
         31	  
         32	  // Assuming JWT payload includes agentId (as defined in requireAuth.ts UserJWTPayload)
         33	  const authenticatedAgentId = req.user?.agentId; // Get agentId from authenticated user
         34	
         35	  // Verify ownership: Authenticated user's agentId must match the agentId in the URL param
         36	  if (!authenticatedAgentId || authenticatedAgentId !== agentIdFromParam) {
         37	      return res.status(403).json({ error: 'Forbidden: You can only provide feedback for your own agent.' });
         38	  }
         39	
         40	  if (!reason) {
         41	    return res.status(400).json({ error: 'Reason is required for feedback.' });
         42	  }
         43	
         44	  if (!voteId && !commentId) {
         45	    return res.status(400).json({ error: 'Either voteId or commentId must be provided.' });
         46	  }
         47	
         48	  if (voteId && commentId) {
         49	    return res.status(400).json({ error: 'Provide either voteId or commentId, not both.' });
         50	  }
         51	
         52	  try {
         53	    // 1. Fetch the agent (using agentIdFromParam which is now verified)
         54	    console.log(`[DEBUG] Attempting to fetch agent with ID: ${agentIdFromParam}`);
         55	    const agent = await prisma.agent.findUnique({
         56	      where: { id: agentIdFromParam },
         57	      // No need to include votes/comments here, fetch counts later if needed
         58	    });
         59	    console.log(`[DEBUG] Agent fetch result:`, agent ? `Found agent ${agent.id}` : `Agent not found`);
         60	
         61	    if (!agent) {
         62	      // This case might be redundant due to the ownership check, but good for robustness
         63	      return res.status(404).json({ error: 'Agent not found.' });
         64	    }
         65	
         66	    let overrideOccurred = false;
         67	
         68	    // 2. Process feedback/override
         69	    if (voteId) {
         70	      console.log(`[DEBUG] Attempting to fetch vote with ID: ${voteId}`);
         71	      const vote = await prisma.vote.findUnique({ where: { id: voteId } });
         72	      console.log(`[DEBUG] Vote fetch result:`, vote ? `Found vote ${vote.id}` : `Vote not found`);
         73	      
         74	      // Ensure vote exists and belongs to the verified agent
         75	      if (!vote) {
         76	        console.log(`[DEBUG] Vote not found: ${voteId}`);
         77	        return res.status(404).json({ error: 'Vote not found.' });
         78	      }
         79	      
         80	      if (vote.agentId !== agentIdFromParam) {
         81	        console.log(`[DEBUG] Vote belongs to agent ${vote.agentId}, not to ${agentIdFromParam}`);
         82	        return res.status(403).json({ error: 'Vote does not belong to this agent.' });
         83	      }
         84	      if (!vote.overrideByUser) { // Only count the first override
         85	         await prisma.vote.update({
         86	           where: { id: voteId },
         87	           data: { overrideByUser: true, overrideReason: reason },
         88	         });
         89	         overrideOccurred = true;
         90	      }
         91	    } else if (commentId) {
         92	      // Still keeping comment feedback as not implemented
         93	       return res.status(501).json({ error: 'Feedback on comments not fully implemented yet.' });
         94	    }
         95	
         96	    // 3. Recalculate Alignment Score if an override occurred
         97	    let newAlignmentScore = agent.alignmentScore;
         98	    if (overrideOccurred) {
         99	        // Fetch fresh counts after update
        100	        console.log(`[DEBUG] Recalculating alignment score for agent ${agentIdFromParam}`);
        101	        const totalVotes = await prisma.vote.count({ where: { agentId: agentIdFromParam } });
        102	        const overriddenVotes = await prisma.vote.count({ where: { agentId: agentIdFromParam, overrideByUser: true } });
        103	        console.log(`[DEBUG] Agent stats: totalVotes=${totalVotes}, overriddenVotes=${overriddenVotes}`);
        104	
        105	        const totalActions = totalVotes;
        106	        const totalOverrides = overriddenVotes;
        107	
        108	        if (totalActions > 0) {
        109	            // Calculate score, ensure it's between 0 and 1
        110	            newAlignmentScore = Math.max(0, Math.min(1, (totalActions - totalOverrides) / totalActions));
        111	        } else {
        112	            newAlignmentScore = 1; // Default to 1 if no actions yet
        113	        }
        114	
        115	        // 4. Update Agent's score
        116	        await prisma.agent.update({
        117	            where: { id: agentIdFromParam },
        118	            data: { alignmentScore: newAlignmentScore },
        119	        });
        120	    }
        121	
        122	    // 5. Call agent-service to generate updated alignment score explanation (optional)
        123	    // Removed call to non-existent generateAlignmentExplanation function
        124	
        125	    console.log(`[DEBUG] Feedback processing complete. New alignment score: ${newAlignmentScore}`);
        126	    res.status(200).json({ message: 'Feedback processed.', newAlignmentScore });
        127	
        128	  } catch (error) {
        129	    console.error('Error processing feedback:', error);
        130	    console.log(`[DEBUG] Error details:`, error);
        131	    res.status(500).json({ error: 'Internal server error processing feedback.' });
        132	  }
        133	});
        134	
        135	export default router;

==============================================
FILE: ./backend/src/routes/agents/index.ts
==============================================

          1	import { Router, Response } from "express";
          2	import { PrismaClient } from "@prisma/client";
          3	import { requireAuth, AuthenticatedRequest } from "../../middleware/requireAuth";
          4	import { HttpError } from "../../utils/HttpError";
          5	import logger from "../../utils/logger";
          6	
          7	const router = Router();
          8	const prisma = new PrismaClient();
          9	
         10	console.log("[AgentRoutes] /api/agents route loaded");
         11	
         12	// Create a new agent for the current user
         13	router.post("/", requireAuth, async (req: AuthenticatedRequest, res: Response) => {
         14	  console.log("[AgentRoutes] POST /api/agents called");
         15	  try {
         16	    const userId = req.user?.userId;
         17	    if (!userId) {
         18	      console.error("[AgentRoutes] No userId in JWT");
         19	      throw new HttpError("Unauthorized", 401);
         20	    }
         21	
         22	    // Check if user already has an agent
         23	    const existingAgent = await prisma.agent.findFirst({ where: { userId } });
         24	    if (existingAgent) {
         25	      console.error(`[AgentRoutes] Agent already exists for userId: ${userId}`);
         26	      return res.status(409).json({ error: "User already has an agent" });
         27	    }
         28	
         29	    // Extract agent details from request body
         30	    const { name, color } = req.body;
         31	
         32	    if (!name) {
         33	      throw new HttpError("Agent name is required", 400);
         34	    }
         35	
         36	    // Create a new agent
         37	    const newAgent = await prisma.agent.create({
         38	      data: {
         39	        userId,
         40	        name,
         41	        color: color || "#4299E1", // Default to blue if no color specified
         42	        publicKey: "placeholder", // Would be generated in a real implementation
         43	        encryptedPrivKey: "placeholder", // Would be generated and encrypted in a real implementation
         44	        alignmentScore: 85.0, // Default initial alignment score
         45	        preferences: {}, // Empty preferences to start with
         46	        autonomyLevel: 0, // Default autonomy level
         47	        // Use type assertion for fields that might not be recognized by TypeScript
         48	        ...(({ onboardingCompleted: false } as any))
         49	      },
         50	    });
         51	
         52	    console.log(`[AgentRoutes] Agent created for userId: ${userId}, agentId: ${newAgent.id}`);
         53	    res.status(201).json(newAgent);
         54	  } catch (err) {
         55	    console.error("[AgentRoutes] Error creating agent:", err);
         56	    if (err instanceof HttpError) {
         57	      res.status(err.statusCode).json({ error: err.message });
         58	    } else {
         59	      res.status(500).json({ error: "Failed to create agent", details: err });
         60	    }
         61	  }
         62	});
         63	
         64	// Get a specific agent by ID
         65	router.get("/:id", requireAuth, async (req: AuthenticatedRequest, res: Response) => {
         66	  console.log(`[AgentRoutes] GET /api/agents/${req.params.id} called`);
         67	  try {
         68	    const userId = req.user?.userId;
         69	    if (!userId) {
         70	      console.error("[AgentRoutes] No userId in JWT");
         71	      throw new HttpError("Unauthorized", 401);
         72	    }
         73	
         74	    const agentId = req.params.id;
         75	    const agent = await prisma.agent.findUnique({ 
         76	      where: { id: agentId },
         77	      select: {
         78	        id: true,
         79	        name: true,
         80	        color: true,
         81	        alignmentScore: true,
         82	        preferences: true,
         83	        pausedUntil: true,
         84	        userId: true
         85	      }
         86	    });
         87	
         88	    if (!agent) {
         89	      console.error(`[AgentRoutes] Agent not found: ${agentId}`);
         90	      return res.status(404).json({ error: "Agent not found" });
         91	    }
         92	
         93	    // Only allow users to access their own agents
         94	    if (agent.userId !== userId) {
         95	      console.error(`[AgentRoutes] User ${userId} tried to access agent ${agentId} belonging to ${agent.userId}`);
         96	      return res.status(403).json({ error: "You do not have permission to access this agent" });
         97	    }
         98	
         99	    console.log(`[AgentRoutes] Returning agent: ${agentId}`);
        100	    res.json(agent);
        101	  } catch (err) {
        102	    console.error("[AgentRoutes] Error fetching agent:", err);
        103	    if (err instanceof HttpError) {
        104	      res.status(err.statusCode).json({ error: err.message });
        105	    } else {
        106	      res.status(500).json({ error: "Failed to fetch agent", details: err });
        107	    }
        108	  }
        109	});
        110	
        111	export default router;
        112	/**
        113	 * GET /api/agents/:id/messages?onboarding=true
        114	 * Returns chat messages for the agent/user, filtered by onboarding if requested.
        115	 */
        116	router.get('/:id/messages', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
        117	  try {
        118	    const agentId = req.params.id;
        119	    const userId = req.user?.userId;
        120	    const onboarding = req.query.onboarding === 'true';
        121	
        122	    if (!agentId || !userId) {
        123	      return res.status(400).json({ error: 'Missing agent or user ID.' });
        124	    }
        125	
        126	    const where: any = {
        127	      agentId,
        128	      userId
        129	    };
        130	    if (onboarding) {
        131	      where.metadata = { path: ['isOnboarding'], equals: true };
        132	    }
        133	
        134	    const messages = await prisma.chatMessage.findMany({
        135	      where,
        136	      orderBy: { timestamp: 'asc' }
        137	    });
        138	
        139	    res.json({ messages });
        140	  } catch (error) {
        141	    console.error('Error fetching agent messages:', error);
        142	    res.status(500).json({ error: 'Failed to fetch agent messages.' });
        143	  }
        144	});

==============================================
FILE: ./backend/src/routes/agents/me.ts
==============================================

          1	import { Router, Response } from "express";
          2	import { PrismaClient } from "@prisma/client";
          3	import { requireAuth, AuthenticatedRequest } from "../../middleware/requireAuth";
          4	import { HttpError } from "../../utils/HttpError";
          5	
          6	const router = Router();
          7	const prisma = new PrismaClient();
          8	
          9	console.log("[AgentMe] /api/agents/me route loaded");
         10	
         11	router.get("/me", requireAuth, async (req: AuthenticatedRequest, res: Response) => {
         12	  console.log("[AgentMe] GET /api/agents/me called");
         13	  try {
         14	    const userId = req.user?.userId;
         15	    if (!userId) {
         16	      console.error("[AgentMe] No userId in JWT");
         17	      throw new HttpError("Unauthorized", 401);
         18	    }
         19	    const agent = await prisma.agent.findFirst({ where: { userId } });
         20	    if (!agent) {
         21	      console.error(`[AgentMe] Agent not found for userId: ${userId}`);
         22	      return res.status(404).json({ error: "Agent not found for user." });
         23	    }
         24	    // Fetch the user record for personalization
         25	    const user = await prisma.user.findUnique({ where: { id: userId } });
         26	    if (!user) {
         27	      console.error(`[AgentMe] User not found for userId: ${userId}`);
         28	      return res.status(404).json({ error: "User not found." });
         29	    }
         30	    // Log original agent and user data
         31	    console.log(`[DEBUG_NAMES] Original agent data:`, JSON.stringify({
         32	      id: agent.id,
         33	      name: agent.name,
         34	      color: agent.color
         35	    }));
         36	    console.log(`[DEBUG_NAMES] User data:`, JSON.stringify({
         37	      id: user.id,
         38	      name: user.name || user.email.split('@')[0]
         39	    }));
         40	
         41	    // FIXED: Do not override the agent name - preserve agent identity
         42	    const personalizedAgent = {
         43	      ...agent
         44	      // Removed the name override to keep agent's identity intact
         45	    };
         46	    
         47	    // Add detailed color debugging
         48	    console.log(`[DEBUG_COLOR] /me endpoint - Agent color value: ${personalizedAgent.color}`);
         49	    console.log(`[AgentMe] Returning personalized agent for userId: ${userId}, agentId: ${personalizedAgent.id}`);
         50	    console.log(`[DEBUG_COLOR] /me endpoint - Full agent object:`, JSON.stringify({
         51	      id: personalizedAgent.id,
         52	      name: personalizedAgent.name, // This should be agent's name but contains user's name
         53	      color: personalizedAgent.color,
         54	      onboardingCompleted: personalizedAgent.onboardingCompleted
         55	    }));
         56	    // Add debug log for what we're returning
         57	    console.log(`[DEBUG_NAMES] Returning response with:
         58	      agentName (in personalizedAgent.name): ${personalizedAgent.name}
         59	      userName: ${user.name || user.email.split('@')[0] || "User"}
         60	    `);
         61	
         62	    res.json({
         63	      ...personalizedAgent,
         64	      // Keep the agent's original name as agentName
         65	      agentName: personalizedAgent.name,
         66	      // Set the user's name in userName field
         67	      userName: user.name || user.email.split('@')[0] || "User"
         68	    });
         69	  } catch (err) {
         70	    console.error("[AgentMe] Error fetching agent:", err);
         71	    res.status(500).json({ error: "Failed to fetch agent.", details: err });
         72	  }
         73	});
         74	
         75	export default router;

==============================================
FILE: ./backend/src/routes/agents/pauseAgentHandler.ts
==============================================

          1	import { Router, Request, Response } from 'express';
          2	import { PrismaClient } from '@prisma/client';
          3	import jwt from 'jsonwebtoken';
          4	
          5	const prisma = new PrismaClient();
          6	const router = Router();
          7	
          8	function requireAuth(req: Request, res: Response, next: () => void) {
          9	  const auth = req.headers.authorization;
         10	  if (!auth || !auth.startsWith('Bearer ')) return res.status(401).json({ error: 'Missing token' });
         11	  try {
         12	    const payload = jwt.verify(auth.split(' ')[1], process.env.JWT_SECRET!);
         13	    (req as any).user = payload;
         14	    next();
         15	  } catch {
         16	    res.status(401).json({ error: 'Invalid token' });
         17	  }
         18	}
         19	
         20	// POST /api/agents/:id/pause
         21	router.post('/:id/pause', requireAuth, async (req, res) => {
         22	  const { userId } = (req as any).user;
         23	  const { id } = req.params;
         24	  const { until } = req.body; // ISO string or null
         25	  try {
         26	    // Only agent owner can pause
         27	    const agent = await prisma.agent.findUnique({ where: { id } });
         28	    if (!agent || agent.userId !== userId) return res.status(403).json({ error: 'Forbidden' });
         29	    await prisma.agent.update({ where: { id }, data: { pausedUntil: until ? new Date(until) : null } });
         30	    res.json({ status: 'paused', pausedUntil: until });
         31	  } catch (error) {
         32	    res.status(400).json({ error: 'Pause failed' });
         33	  }
         34	});
         35	
         36	// Middleware to block vote/comment if agent is paused
         37	export async function blockIfPaused(req: Request, res: Response, next: () => void) {
         38	  const { agentId } = (req as any).user;
         39	  const agent = await prisma.agent.findUnique({ where: { id: agentId } });
         40	  if (agent && agent.pausedUntil && new Date() < agent.pausedUntil) {
         41	    return res.status(403).json({ error: 'Agent is paused' });
         42	  }
         43	  next();
         44	}
         45	
         46	export default router;


==============================================
FILE: ./backend/src/routes/auth.ts
==============================================

          1	import { Router } from 'express';
          2	import rateLimit from 'express-rate-limit';
          3	import bcrypt from 'bcryptjs';
          4	import jwt from 'jsonwebtoken';
          5	import { PrismaClient } from '@prisma/client';
          6	import { generateKeyPair, encryptPrivateKey } from '../services/key-service';
          7	import { requireAuth, AuthenticatedRequest } from '../middleware/requireAuth';
          8	
          9	const prisma = new PrismaClient();
         10	const router = Router();
         11	
         12	// Limit auth attempts to prevent abuse
         13	const authLimiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 100 });
         14	
         15	router.post('/register', authLimiter, async (req, res) => {
         16	  const { email, password } = req.body;
         17	  console.log(`[DEBUG-REG] Registration attempt for email: ${email}`);
         18	  if (!email || !password) return res.status(400).json({ error: 'Missing email or password' });
         19	  try {
         20	    // Check database connection first
         21	    try {
         22	      await prisma.$queryRaw`SELECT 1`;
         23	      console.log('[DEBUG-REG] Database connection successful');
         24	    } catch (dbError) {
         25	      console.error('[DEBUG-REG] Database connection failed:', dbError);
         26	      return res.status(500).json({ error: 'Database connection error' });
         27	    }
         28	    
         29	    const existing = await prisma.user.findUnique({ where: { email } });
         30	    if (existing) return res.status(409).json({ error: 'Email already in use' });
         31	    
         32	    console.log('[DEBUG] Creating new user with email:', email);
         33	    const passwordHash = await bcrypt.hash(password, 10);
         34	    
         35	    // Generate and encrypt user keys
         36	    console.log('[DEBUG] Generating user keys');
         37	    let userPriv, userPub, encUserPriv;
         38	    try {
         39	      const userKeys = await generateKeyPair();
         40	      userPriv = userKeys.privateKey;
         41	      userPub = userKeys.publicKey;
         42	      encUserPriv = encryptPrivateKey(userPriv);
         43	      console.log('[DEBUG] User keys generated successfully');
         44	    } catch (keyError) {
         45	      console.error('[DEBUG] Error generating user keys:', keyError);
         46	      return res.status(500).json({ error: 'Failed to generate keys' });
         47	    }
         48	    
         49	    // Generate and encrypt agent keys
         50	    console.log('[DEBUG] Generating agent keys');
         51	    let agentPriv, agentPub, encAgentPriv;
         52	    try {
         53	      const agentKeys = await generateKeyPair();
         54	      agentPriv = agentKeys.privateKey;
         55	      agentPub = agentKeys.publicKey;
         56	      encAgentPriv = encryptPrivateKey(agentPriv);
         57	      console.log('[DEBUG] Agent keys generated successfully');
         58	    } catch (keyError) {
         59	      console.error('[DEBUG] Error generating agent keys:', keyError);
         60	      return res.status(500).json({ error: 'Failed to generate keys' });
         61	    }
         62	    
         63	    // Create user record
         64	    let user;
         65	    try {
         66	      console.log('[DEBUG] Creating user in database');
         67	      user = await prisma.user.create({
         68	        data: {
         69	          email,
         70	          passwordHash,
         71	          publicKey: Buffer.from(userPub).toString('hex'),
         72	          encryptedPrivKey: encUserPriv,
         73	        },
         74	      });
         75	      console.log('[DEBUG] User created successfully:', user.id);
         76	    } catch (userError: any) {
         77	      console.error('[DEBUG] Error creating user:', userError.message);
         78	      return res.status(500).json({ error: 'Failed to create user account' });
         79	    }
         80	    
         81	    // Create agent record with placeholder identity
         82	    let agent;
         83	    try {
         84	      console.log('[DEBUG] Creating agent in database');
         85	      agent = await prisma.agent.create({
         86	        data: {
         87	          userId: user.id,
         88	          name: 'Agent',
         89	          color: '#000000',
         90	          publicKey: Buffer.from(agentPub).toString('hex'),
         91	          encryptedPrivKey: encAgentPriv,
         92	          preferences: {},
         93	          scenarioPreferences: {},
         94	        },
         95	      });
         96	      console.log('[DEBUG] Agent created successfully:', agent.id);
         97	    } catch (agentError: any) {
         98	      console.error('[DEBUG] Error creating agent:', agentError.message);
         99	      return res.status(500).json({ error: 'Failed to create agent account' });
        100	    }
        101	    
        102	    try {
        103	      // Triple check JWT secret is available and valid
        104	      if (!process.env.JWT_SECRET) {
        105	        console.error('[DEBUG-CRITICAL] JWT_SECRET is undefined during token generation!');
        106	        return res.status(500).json({ error: 'Server configuration error: Missing JWT secret' });
        107	      }
        108	      
        109	      if (process.env.JWT_SECRET === 'change-me') {
        110	        console.error('[DEBUG-CRITICAL] JWT_SECRET is using placeholder value "change-me"!');
        111	        return res.status(500).json({ error: 'Server configuration error: Invalid JWT secret' });
        112	      }
        113	      
        114	      console.log('[DEBUG-CRITICAL] Generating JWT token with secret:',
        115	        process.env.JWT_SECRET ? `${process.env.JWT_SECRET.substring(0, 3)}...${process.env.JWT_SECRET.substring(process.env.JWT_SECRET.length - 3)}` : 'MISSING');
        116	      console.log('[DEBUG-CRITICAL] JWT secret length:', process.env.JWT_SECRET.length);
        117	      console.log('[DEBUG-CRITICAL] JWT payload:', { userId: user.id, agentId: agent.id });
        118	      
        119	      const token = jwt.sign(
        120	        { userId: user.id, agentId: agent.id },
        121	        process.env.JWT_SECRET,
        122	        { expiresIn: '24h' } // Extend token lifetime to reduce login frequency
        123	      );
        124	      
        125	      // Validate generated token immediately
        126	      try {
        127	        const verified = jwt.verify(token, process.env.JWT_SECRET) as any;
        128	        console.log('[DEBUG-CRITICAL] Token verification successful:', {
        129	          userId: verified.userId === user.id ? 'matches' : 'mismatch',
        130	          agentId: verified.agentId === agent.id ? 'matches' : 'mismatch'
        131	        });
        132	      } catch (verifyError) {
        133	        console.error('[DEBUG-CRITICAL] Token verification failed immediately after generation:', verifyError);
        134	        return res.status(500).json({ error: 'Failed to verify authentication token' });
        135	      }
        136	      
        137	      console.log('[DEBUG-CRITICAL] Token generated successfully, length:', token.length);
        138	      console.log('[DEBUG-CRITICAL] Token prefix:', token.substring(0, 15) + '...');
        139	      console.log('[DEBUG-CRITICAL] Registration complete, sending token');
        140	      res.json({ token });
        141	    } catch (tokenError) {
        142	      console.error('[DEBUG-CRITICAL] Error generating token:', tokenError);
        143	      console.error('[DEBUG-CRITICAL] JWT_SECRET defined:', !!process.env.JWT_SECRET);
        144	      console.error('[DEBUG-CRITICAL] JWT_SECRET length:', process.env.JWT_SECRET?.length || 0);
        145	      return res.status(500).json({ error: 'Failed to generate authentication token' });
        146	    }
        147	  } catch (error) {
        148	    console.error('[DEBUG-REG] Unhandled error during registration:', error);
        149	    // More detailed error logging
        150	    if (error instanceof Error) {
        151	      console.error('[DEBUG-REG] Error message:', error.message);
        152	      console.error('[DEBUG-REG] Error stack:', error.stack);
        153	    }
        154	    res.status(500).json({ error: 'Internal error during registration' });
        155	  }
        156	});
        157	
        158	router.post('/login', authLimiter, async (req, res) => {
        159	  const { email, password } = req.body;
        160	  if (!email || !password) return res.status(400).json({ error: 'Missing email or password' });
        161	  try {
        162	    console.log(`[DEBUG] Login attempt for email: ${email}`);
        163	    
        164	    // Check database connection by running a simple query
        165	    try {
        166	      await prisma.$queryRaw`SELECT 1`;
        167	      console.log('[DEBUG] Database connection successful');
        168	    } catch (dbError) {
        169	      console.error('[DEBUG] Database connection failed:', dbError);
        170	      return res.status(500).json({ error: 'Database connection error' });
        171	    }
        172	    
        173	    const user = await prisma.user.findUnique({ where: { email } });
        174	    if (!user) {
        175	      console.log('[DEBUG] User not found');
        176	      return res.status(401).json({ error: 'Invalid credentials' });
        177	    }
        178	    
        179	    console.log('[DEBUG] User found, checking password');
        180	    const valid = await bcrypt.compare(password, user.passwordHash);
        181	    if (!valid) {
        182	      console.log('[DEBUG] Password invalid');
        183	      return res.status(401).json({ error: 'Invalid credentials' });
        184	    }
        185	    
        186	    console.log('[DEBUG] Password valid, looking for agent');
        187	    const agent = await prisma.agent.findUnique({ where: { userId: user.id } });
        188	    
        189	    if (!agent) {
        190	      console.error('[DEBUG] No agent found for user ID:', user.id);
        191	      return res.status(500).json({ error: 'User account configuration error' });
        192	    }
        193	    
        194	    console.log('[DEBUG] Agent found, creating JWT');
        195	    if (!process.env.JWT_SECRET) {
        196	      console.error('[DEBUG] JWT_SECRET is missing or undefined');
        197	      return res.status(500).json({ error: 'Server configuration error' });
        198	    }
        199	    
        200	    const token = jwt.sign({ userId: user.id, agentId: agent.id }, process.env.JWT_SECRET, { expiresIn: '1h' });
        201	    console.log('[DEBUG] Login successful');
        202	    
        203	    res.json({ token });
        204	  } catch (error: any) { // Explicitly type error as any to access .message
        205	    console.error('[DEBUG] Login error details:', error);
        206	    res.status(500).json({
        207	      error: 'Internal error',
        208	      details: process.env.NODE_ENV === 'development' ? error.message : undefined
        209	    });
        210	  }
        211	});
        212	
        213	// Add endpoint to get current user info
        214	router.get('/me', requireAuth, async (req: AuthenticatedRequest, res) => {
        215	  try {
        216	    const userId = req.user?.userId;
        217	    
        218	    if (!userId) {
        219	      return res.status(401).json({ error: 'Authentication invalid' });
        220	    }
        221	    
        222	    const user = await prisma.user.findUnique({
        223	      where: { id: userId },
        224	      select: {
        225	        id: true,
        226	        email: true,
        227	        digestFrequency: true,
        228	        digestTone: true,
        229	        createdAt: true,
        230	        updatedAt: true,
        231	        role: true
        232	      }
        233	    });
        234	    
        235	    if (!user) {
        236	      return res.status(404).json({ error: 'User not found' });
        237	    }
        238	    
        239	    // Get agent info as well
        240	    const agent = await prisma.agent.findFirst({
        241	      where: { userId: userId },
        242	      select: {
        243	        id: true,
        244	        name: true,
        245	        color: true,
        246	        preferences: true
        247	      }
        248	    });
        249	    
        250	    res.json({ data: { ...user, agent } });
        251	  } catch (error) {
        252	    console.error('Error fetching user:', error);
        253	    res.status(500).json({ error: 'Internal server error' });
        254	  }
        255	});
        256	
        257	export default router;


==============================================
FILE: ./backend/src/routes/chat.ts
==============================================

          1	import { Router } from 'express';
          2	import { PrismaClient } from '@prisma/client';
          3	import { requireAuth, AuthenticatedRequest } from '../middleware/requireAuth';
          4	import { Response, NextFunction } from 'express';
          5	import logger from '../utils/logger';
          6	import { HttpError } from '../utils/HttpError';
          7	
          8	const router = Router();
          9	const prisma = new PrismaClient();
         10	import { callOpenRouterLLM } from "../services/llm-service";
         11	
         12	/**
         13	 * @route POST /api/chat/messages
         14	 * @desc Create a new chat message
         15	 * @access Private
         16	 */
         17	router.post('/messages', requireAuth, async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
         18	  try {
         19	    const { content, agentId, metadata } = req.body;
         20	    
         21	    if (!req.user) {
         22	      throw new HttpError('Unauthorized', 401);
         23	    }
         24	    
         25	    const userId = req.user.userId; // JWT payload has userId, not id
         26	
         27	    if (!content || !agentId) {
         28	      throw new HttpError('Content and agentId are required', 400);
         29	    }
         30	
         31	    // Debug logging for agent lookup
         32	    logger.info(`[Chat] userId from JWT: ${userId}, agentId from request: ${agentId}`);
         33	    const agent = await (prisma as any).agent.findFirst({
         34	      where: {
         35	        id: agentId,
         36	        userId: userId
         37	      }
         38	    });
         39	    logger.info(`[Chat] agent lookup result: ${agent ? JSON.stringify({ id: agent.id, userId: agent.userId }) : "not found"}`);
         40	
         41	    if (!agent) {
         42	      throw new HttpError('Agent not found or does not belong to user', 404);
         43	    }
         44	
         45	    // Create the user message - Type assertion for now until migration is applied
         46	    const userMessage = await (prisma as any).chatMessage.create({
         47	      data: {
         48	        userId,
         49	        agentId,
         50	        content,
         51	        sender: 'user',
         52	        metadata: metadata || {},
         53	        timestamp: new Date()
         54	      }
         55	    });
         56	
         57	    // Fetch recent chat history for context (last 10 messages)
         58	    const recentMessages = await (prisma as any).chatMessage.findMany({
         59	      where: { userId, agentId },
         60	      orderBy: { timestamp: "desc" },
         61	      take: 10,
         62	    });
         63	    const contextMessages = recentMessages
         64	      .reverse()
         65	      .map((msg: any) => ({
         66	        role: msg.sender === "user" ? "user" : "assistant",
         67	        content: msg.content,
         68	      }));
         69	
         70	    // Determine if this is part of onboarding
         71	    const isOnboarding = metadata && metadata.isOnboarding === true;
         72	    
         73	    // Generate response differently based on whether this is onboarding or regular chat
         74	    let agentResponse: string;
         75	    let responseMetadata = {};
         76	    
         77	    try {
         78	      if (isOnboarding) {
         79	        // Import agent service dynamically to avoid circular dependencies
         80	        const agentService = await import('../services/agent-service');
         81	        
         82	        // Get current onboarding stage from metadata or default to 'initial'
         83	        const currentStage = metadata.stage || 'initial';
         84	        
         85	        // Use conductOnboardingChat for onboarding messages
         86	        const result = await agentService.conductOnboardingChat(
         87	          userId,
         88	          agentId,
         89	          content,
         90	          currentStage
         91	        );
         92	        
         93	        agentResponse = result.response;
         94	        responseMetadata = {
         95	          isOnboarding: true,
         96	          stage: currentStage,
         97	          nextStage: result.nextStep,
         98	          onboardingComplete: result.completedOnboarding || false
         99	        };
        100	        
        101	        logger.info(`[Onboarding] Stage: ${currentStage} → ${result.nextStep}, Complete: ${result.completedOnboarding}`);
        102	      } else {
        103	        // Regular chat message - use standard LLM call
        104	        agentResponse = await callOpenRouterLLM({
        105	          prompt: content,
        106	          contextMessages,
        107	          model: "openai/gpt-4.1",
        108	          temperature: 0.7,
        109	          maxTokens: 256,
        110	        });
        111	      }
        112	    } catch (err: any) {
        113	      logger.error("Response generation failed:", err);
        114	      agentResponse = "Sorry, I couldn't process your message due to an internal error.";
        115	    }
        116	
        117	    // Save the agent's response with any special metadata - Type assertion for now until migration is applied
        118	    const agentMessage = await (prisma as any).chatMessage.create({
        119	      data: {
        120	        userId,
        121	        agentId,
        122	        content: agentResponse,
        123	        sender: 'agent',
        124	        timestamp: new Date(),
        125	        metadata: responseMetadata
        126	      }
        127	    });
        128	
        129	    // Update agent's lastInteraction timestamp
        130	    // Type assertion for now until migration is applied
        131	    await (prisma as any).agent.update({
        132	      where: { id: agentId },
        133	      data: { lastInteraction: new Date() }
        134	    });
        135	
        136	    res.status(201).json({
        137	      userMessage,
        138	      agentMessage
        139	    });
        140	  } catch (error) {
        141	    next(error);
        142	  }
        143	});
        144	
        145	/**
        146	 * @route GET /api/chat/messages
        147	 * @desc Get chat history with pagination
        148	 * @access Private
        149	 */
        150	router.get('/messages', requireAuth, async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
        151	  try {
        152	    if (!req.user) {
        153	      throw new HttpError('Unauthorized', 401);
        154	    }
        155	    
        156	    const userId = req.user.userId;
        157	    const { agentId, limit = 50, before, onboarding } = req.query;
        158	
        159	    if (!agentId) {
        160	      throw new HttpError('Agent ID is required', 400);
        161	    }
        162	
        163	    // Verify the agent belongs to the user - Type assertion for now until migration is applied
        164	    const agent = await (prisma as any).agent.findFirst({
        165	      where: {
        166	        id: String(agentId),
        167	        userId: userId
        168	      }
        169	    });
        170	
        171	    if (!agent) {
        172	      throw new HttpError('Agent not found or does not belong to user', 404);
        173	    }
        174	
        175	    // Build query conditions
        176	    const whereClause: any = {
        177	      userId,
        178	      agentId: String(agentId)
        179	    };
        180	
        181	    // Add timestamp condition if 'before' is provided
        182	    if (before) {
        183	      whereClause.timestamp = {
        184	        lt: new Date(String(before))
        185	      };
        186	    }
        187	
        188	    // If onboarding flag is set, filter messages accordingly
        189	    // This would require adding an 'isOnboarding' field to the ChatMessage model
        190	    // For now, we'll just leave this as a comment
        191	    // if (onboarding === 'true') {
        192	    //   whereClause.isOnboarding = true;
        193	    // }
        194	
        195	    // Fetch messages
        196	    // Type assertion for now until migration is applied
        197	    const messages = await (prisma as any).chatMessage.findMany({
        198	      where: whereClause,
        199	      orderBy: {
        200	        timestamp: 'desc'
        201	      },
        202	      take: Number(limit) + 1 // Fetch one extra to check if there are more
        203	    });
        204	
        205	    const hasMore = messages.length > Number(limit);
        206	    const nextCursor = hasMore ? messages[messages.length - 2].timestamp.toISOString() : undefined;
        207	
        208	    // Return all but the extra message if we fetched more than the limit
        209	    const messagesToReturn = hasMore ? messages.slice(0, -1) : messages;
        210	
        211	    res.status(200).json({
        212	      messages: messagesToReturn.reverse(), // Reverse to get chronological order
        213	      hasMore,
        214	      nextCursor
        215	    });
        216	  } catch (error) {
        217	    next(error);
        218	  }
        219	});
        220	
        221	/**
        222	 * @route GET /api/chat/messages/:id
        223	 * @desc Get a specific message
        224	 * @access Private
        225	 */
        226	router.get('/messages/:id', requireAuth, async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
        227	  try {
        228	    if (!req.user) {
        229	      throw new HttpError('Unauthorized', 401);
        230	    }
        231	    
        232	    const userId = req.user.userId;
        233	    const messageId = req.params.id;
        234	
        235	    // Type assertion for now until migration is applied
        236	    const message = await (prisma as any).chatMessage.findFirst({
        237	      where: {
        238	        id: messageId,
        239	        userId: userId
        240	      }
        241	    });
        242	
        243	    if (!message) {
        244	      throw new HttpError('Message not found', 404);
        245	    }
        246	
        247	    res.status(200).json(message);
        248	  } catch (error) {
        249	    next(error);
        250	  }
        251	});
        252	
        253	/**
        254	 * @route DELETE /api/chat/messages/:id
        255	 * @desc Delete a message
        256	 * @access Private
        257	 */
        258	router.delete('/messages/:id', requireAuth, async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
        259	  try {
        260	    if (!req.user) {
        261	      throw new HttpError('Unauthorized', 401);
        262	    }
        263	    
        264	    const userId = req.user.userId;
        265	    const messageId = req.params.id;
        266	
        267	    // Type assertion for now until migration is applied
        268	    const message = await (prisma as any).chatMessage.findFirst({
        269	      where: {
        270	        id: messageId,
        271	        userId: userId
        272	      }
        273	    });
        274	
        275	    if (!message) {
        276	      throw new HttpError('Message not found', 404);
        277	    }
        278	
        279	    // Type assertion for now until migration is applied
        280	    await (prisma as any).chatMessage.delete({
        281	      where: {
        282	        id: messageId
        283	      }
        284	    });
        285	
        286	    res.status(204).send();
        287	  } catch (error) {
        288	    next(error);
        289	  }
        290	});
        291	
        292	// Placeholder function for generating agent responses
        293	// This will be implemented properly in the agent service
        294	/* LLM integration now handled in main route */
        295	
        296	export default router;

==============================================
FILE: ./backend/src/routes/comment.ts
==============================================

          1	import { Router, Request, Response } from 'express';
          2	import { PrismaClient } from '@prisma/client';
          3	import { requireAuth, AuthenticatedRequest } from '../middleware/requireAuth';
          4	import { generateComment } from '../services/agent-service';
          5	
          6	const prisma = new PrismaClient();
          7	const router = Router();
          8	
          9	// POST /api/comments - Create a new comment on a proposal
         10	router.post('/', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
         11	  const { agentId } = req.user || {};
         12	  const { proposalId, content } = req.body;
         13	
         14	  if (!agentId) {
         15	    return res.status(401).json({ error: 'Authentication invalid or missing agent ID.' });
         16	  }
         17	  if (!proposalId || !content) {
         18	    return res.status(400).json({ error: 'Missing proposalId or content.' });
         19	  }
         20	
         21	  try {
         22	    // Optionally, call agent-service to generate or validate comment
         23	    const agentPreferences = {}; // TODO: fetch agent preferences from DB or context
         24	    const generatedComment = await generateComment({ id: proposalId }, agentPreferences, agentId);
         25	
         26	    // For now, use user-provided content; can integrate generatedComment as needed
         27	    const comment = await prisma.comment.create({
         28	      data: {
         29	        proposalId,
         30	        agentId,
         31	        content,
         32	      },
         33	    });
         34	
         35	    res.status(201).json(comment);
         36	  } catch (error) {
         37	    console.error('Error creating comment:', error);
         38	    res.status(500).json({ error: 'Internal server error creating comment.' });
         39	  }
         40	});
         41	
         42	export default router;

==============================================
FILE: ./backend/src/routes/feedback.ts
==============================================

          1	import { Router, Request, Response } from "express";
          2	import { processFeedback, getFeedback } from "../services/feedback-service";
          3	import { requireAuth } from "../middleware/requireAuth";
          4	
          5	const router = Router();
          6	
          7	/**
          8	 * POST /api/feedback/negotiation/:negotiationId
          9	 * Submit feedback for an agent's performance in a negotiation
         10	 */
         11	router.post("/api/feedback/negotiation/:negotiationId", requireAuth, async (req: Request, res: Response) => {
         12	  try {
         13	    const { agentId, rating, representationAccuracy, comments, preferenceUpdates } = req.body;
         14	    const userId = req.user?.id;
         15	
         16	    if (!agentId || !rating || rating < 1 || rating > 5 || !userId) {
         17	      return res.status(400).json({ 
         18	        error: "Missing required fields or invalid values",
         19	        details: "Required: agentId, rating (1-5)"
         20	      });
         21	    }
         22	
         23	    if (!representationAccuracy || representationAccuracy < 1 || representationAccuracy > 5) {
         24	      return res.status(400).json({ 
         25	        error: "Invalid representation accuracy value", 
         26	        details: "representationAccuracy must be between 1-5" 
         27	      });
         28	    }
         29	
         30	    const feedbackId = await processFeedback({
         31	      negotiationId: req.params.negotiationId,
         32	      agentId,
         33	      userId,
         34	      rating,
         35	      representationAccuracy,
         36	      comments,
         37	      preferenceUpdates
         38	    });
         39	
         40	    res.status(201).json({ 
         41	      success: true, 
         42	      feedbackId,
         43	      message: "Feedback successfully submitted" 
         44	    });
         45	  } catch (err: any) {
         46	    res.status(500).json({ 
         47	      error: "Failed to submit feedback", 
         48	      message: err.message || "Unknown error" 
         49	    });
         50	  }
         51	});
         52	
         53	/**
         54	 * GET /api/feedback/negotiation/:negotiationId
         55	 * Get all feedback for a negotiation
         56	 */
         57	router.get("/api/feedback/negotiation/:negotiationId", requireAuth, async (req: Request, res: Response) => {
         58	  try {
         59	    const feedback = await getFeedback(
         60	      req.params.negotiationId, 
         61	      req.query.agentId as string || undefined,
         62	      req.user?.id // Only return feedback from the authenticated user
         63	    );
         64	
         65	    res.json(feedback);
         66	  } catch (err: any) {
         67	    res.status(500).json({ 
         68	      error: "Failed to fetch feedback", 
         69	      message: err.message || "Unknown error" 
         70	    });
         71	  }
         72	});
         73	
         74	/**
         75	 * GET /api/feedback/agent/:agentId
         76	 * Get all feedback for an agent
         77	 */
         78	router.get("/api/feedback/agent/:agentId", requireAuth, async (req: Request, res: Response) => {
         79	  try {
         80	    // Verify the agent belongs to the user
         81	    // This would normally be handled by an authorization middleware
         82	    const userId = req.user?.id;
         83	    
         84	    const feedback = await getFeedback(
         85	      undefined, 
         86	      req.params.agentId,
         87	      userId // Only return feedback from the authenticated user
         88	    );
         89	
         90	    res.json(feedback);
         91	  } catch (err: any) {
         92	    res.status(500).json({ 
         93	      error: "Failed to fetch feedback", 
         94	      message: err.message || "Unknown error" 
         95	    });
         96	  }
         97	});
         98	
         99	export default router;

==============================================
FILE: ./backend/src/routes/issues.ts
==============================================

          1	import express from 'express';
          2	import { requireAuth } from '../middleware/requireAuth';
          3	
          4	const router = express.Router();
          5	
          6	// GET /api/issues/user - Fetch issues with user's positions
          7	import { PrismaClient } from '@prisma/client';
          8	
          9	const prisma = new PrismaClient();
         10	
         11	router.get('/user', requireAuth, async (req, res) => {
         12	  try {
         13	    const userId = req.user?.userId;
         14	    if (!userId) {
         15	      return res.status(401).json({ error: "Unauthorized" });
         16	    }
         17	    // Fetch agent for this user
         18	    const agent = await prisma.agent.findFirst({ where: { userId } });
         19	    if (!agent) {
         20	      return res.status(404).json({ error: "Agent not found for user." });
         21	    }
         22	    // Parse preferences for issues/positions
         23	    const preferences = agent.preferences || {};
         24	    // Example structure: { issues: [{ id, title, description, stance, reason, isPriority }] }
         25	    let issues = [];
         26	    // Enhanced debugging for preferences structure
         27	    console.log(`[Issues] Raw preferences:`, JSON.stringify(preferences));
         28	    
         29	    if (preferences.issuesMatrix && Array.isArray(preferences.issuesMatrix)) {
         30	      console.log('[Issues] Found issuesMatrix in preferences');
         31	      issues = preferences.issuesMatrix;
         32	    } else if (preferences.issues && Array.isArray(preferences.issues)) {
         33	      console.log('[Issues] Found issues array in preferences');
         34	      issues = preferences.issues;
         35	    } else if (Array.isArray(preferences)) {
         36	      // If preferences is an array, use it directly
         37	      console.log('[Issues] Preferences is already an array');
         38	      issues = preferences;
         39	    } else {
         40	      console.log('[Issues] No recognized issue format found in preferences');
         41	    }
         42	    // Add logging
         43	    console.log(`[Issues] /api/issues/user for userId: ${userId}, agentId: ${agent.id}`);
         44	    console.log(`[Issues] Returning issues:`, JSON.stringify(issues, null, 2));
         45	    res.json(issues);
         46	  } catch (err) {
         47	    console.error("[Issues] Error fetching user issues:", err);
         48	    res.status(500).json({ error: "Failed to fetch user issues.", details: err });
         49	  }
         50	});
         51	
         52	export default router;

==============================================
FILE: ./backend/src/routes/key.ts
==============================================

          1	import { Router } from 'express';
          2	import { PrismaClient } from '@prisma/client';
          3	import { generateKeyPair, encryptPrivateKey } from '../services/key-service';
          4	import jwt from 'jsonwebtoken';
          5	
          6	const prisma = new PrismaClient();
          7	const router = Router();
          8	
          9	// Auth middleware (simple JWT check)
         10	function requireAuth(req, res, next) {
         11	  const auth = req.headers.authorization;
         12	  if (!auth || !auth.startsWith('Bearer ')) return res.status(401).json({ error: 'Missing token' });
         13	  try {
         14	    const payload = jwt.verify(auth.split(' ')[1], process.env.JWT_SECRET);
         15	    req.user = payload;
         16	    next();
         17	  } catch {
         18	    res.status(401).json({ error: 'Invalid token' });
         19	  }
         20	}
         21	
         22	// POST /api/keys/generate
         23	router.post('/generate', requireAuth, async (req, res) => {
         24	  const { userId, agentId } = req.user;
         25	  const mode = process.env.KEY_STORAGE_MODE || 'server';
         26	  try {
         27	    const { privateKey, publicKey } = await generateKeyPair();
         28	    if (mode === 'server') {
         29	      // Encrypt and store in DB
         30	      const encPriv = encryptPrivateKey(privateKey);
         31	      await prisma.user.update({
         32	        where: { id: userId },
         33	        data: { publicKey: Buffer.from(publicKey).toString('hex'), encryptedPrivKey: encPriv }
         34	      });
         35	      res.json({ status: 'ok', publicKey: Buffer.from(publicKey).toString('hex') });
         36	    } else {
         37	      // Return to client, do not store privKey
         38	      await prisma.user.update({
         39	        where: { id: userId },
         40	        data: { publicKey: Buffer.from(publicKey).toString('hex'), encryptedPrivKey: '' }
         41	      });
         42	      res.json({ publicKey: Buffer.from(publicKey).toString('hex'), privateKey: Buffer.from(privateKey).toString('hex') });
         43	    }
         44	  } catch (error) {
         45	    console.error(error);
         46	    res.status(500).json({ error: 'Internal error' });
         47	  }
         48	});
         49	
         50	// GET /api/keys/public
         51	router.get('/public', requireAuth, async (req, res) => {
         52	  const { userId } = req.user;
         53	  const user = await prisma.user.findUnique({ where: { id: userId }, select: { publicKey: true } });
         54	  if (!user) return res.status(404).json({ error: 'Not found' });
         55	  res.json({ publicKey: user.publicKey });
         56	});
         57	
         58	export default router;


==============================================
FILE: ./backend/src/routes/negotiation.ts
==============================================

          1	import { Router, Request, Response } from "express";
          2	import { PrismaClient } from "@prisma/client";
          3	import { createProposalFromNegotiation } from "../services/negotiation-to-proposal";
          4	import { detectConsensus } from "../services/negotiation-service";
          5	
          6	const router = Router();
          7	const prisma = new PrismaClient();
          8	
          9	/**
         10	 * POST /api/negotiations
         11	 * Create a new negotiation session
         12	 */
         13	router.post("/api/negotiations", async (req: Request, res: Response) => {
         14	  const { topic, description } = req.body;
         15	  if (!topic) {
         16	    return res.status(400).json({ error: "Missing required fields" });
         17	  }
         18	  try {
         19	    const session = await prisma.negotiationSession.create({
         20	      data: {
         21	        topic,
         22	        description,
         23	        initiatorId: req.body.initiatorId || "unknown", // Should be set by auth in production
         24	        status: "active",
         25	      },
         26	    });
         27	    res.status(201).json(session);
         28	  } catch (err) {
         29	    res.status(500).json({ error: "Failed to create negotiation session", details: err });
         30	  }
         31	});
         32	
         33	/**
         34	 * GET /api/negotiations
         35	 * List all negotiation sessions
         36	 */
         37	router.get("/api/negotiations", async (_req: Request, res: Response) => {
         38	  try {
         39	    const sessions = await prisma.negotiationSession.findMany();
         40	    res.json(sessions);
         41	  } catch (err) {
         42	    res.status(500).json({ error: "Failed to fetch negotiations", details: err });
         43	  }
         44	});
         45	
         46	/**
         47	 * GET /api/negotiations/:id
         48	 * Get details of a negotiation session
         49	 */
         50	router.get("/api/negotiations/:id", async (req: Request, res: Response) => {
         51	  try {
         52	    const session = await prisma.negotiationSession.findUnique({
         53	      where: { id: req.params.id },
         54	    });
         55	    if (!session) return res.status(404).json({ error: "Negotiation not found" });
         56	    res.json(session);
         57	  } catch (err) {
         58	    res.status(500).json({ error: "Failed to fetch negotiation", details: err });
         59	  }
         60	});
         61	
         62	/**
         63	 * POST /api/negotiations/:id/messages
         64	 * Add a message to a negotiation session (any agent can post to join)
         65	 */
         66	router.post("/api/negotiations/:id/messages", async (req: Request, res: Response) => {
         67	  const { agentId, content, messageType, referencedMessageId, metadata } = req.body;
         68	  if (!agentId || !content) {
         69	    return res.status(400).json({ error: "Missing required fields" });
         70	  }
         71	  try {
         72	    const message = await prisma.negotiationMessage.create({
         73	      data: {
         74	        negotiationId: req.params.id,
         75	        agentId,
         76	        content,
         77	        messageType: messageType || "statement",
         78	        referencedMessageId,
         79	        metadata,
         80	      },
         81	    });
         82	    res.status(201).json(message);
         83	  } catch (err) {
         84	    res.status(500).json({ error: "Failed to add negotiation message", details: err });
         85	  }
         86	});
         87	
         88	/**
         89	 * GET /api/negotiations/:id/messages
         90	 * Get all messages for a negotiation session, including reactions
         91	 */
         92	router.get("/api/negotiations/:id/messages", async (req: Request, res: Response) => {
         93	  try {
         94	    const messages = await prisma.negotiationMessage.findMany({
         95	      where: { negotiationId: req.params.id },
         96	      orderBy: { timestamp: "asc" },
         97	      include: {
         98	        reactions: true,
         99	      },
        100	    });
        101	    res.json(messages);
        102	  } catch (err) {
        103	    res.status(500).json({ error: "Failed to fetch negotiation messages", details: err });
        104	  }
        105	});
        106	
        107	/**
        108	 * POST /api/negotiations/:id/messages/:messageId/reactions
        109	 * Add a reaction to a negotiation message
        110	 */
        111	router.post("/api/negotiations/:id/messages/:messageId/reactions", async (req: Request, res: Response) => {
        112	  const { agentId, reactionType } = req.body;
        113	  if (!agentId || !reactionType) {
        114	    return res.status(400).json({ error: "Missing required fields" });
        115	  }
        116	  try {
        117	    const reaction = await prisma.negotiationReaction.create({
        118	      data: {
        119	        messageId: req.params.messageId,
        120	        agentId,
        121	        reactionType,
        122	      },
        123	    });
        124	    res.status(201).json(reaction);
        125	  } catch (err: any) {
        126	    if (err.code === "P2002") {
        127	      // Unique constraint failed (duplicate reaction)
        128	      return res.status(409).json({ error: "Reaction already exists for this agent and type" });
        129	    }
        130	    res.status(500).json({ error: "Failed to add reaction", details: err });
        131	  }
        132	});
        133	
        134	/**
        135	 * DELETE /api/negotiations/:id/messages/:messageId/reactions
        136	 * Remove a reaction from a negotiation message
        137	 * Expects agentId and reactionType in the body
        138	 */
        139	router.delete("/api/negotiations/:id/messages/:messageId/reactions", async (req: Request, res: Response) => {
        140	  const { agentId, reactionType } = req.body;
        141	  if (!agentId || !reactionType) {
        142	    return res.status(400).json({ error: "Missing required fields" });
        143	  }
        144	  try {
        145	    await prisma.negotiationReaction.deleteMany({
        146	      where: {
        147	        messageId: req.params.messageId,
        148	        agentId,
        149	        reactionType,
        150	      },
        151	    });
        152	    res.status(204).send();
        153	  } catch (err: any) {
        154	    res.status(500).json({ error: "Failed to remove reaction", details: err });
        155	  }
        156	});
        157	
        158	/**
        159	 * POST /api/negotiations/:id/propose
        160	 * Convert a negotiation to a formal proposal after consensus is reached
        161	 */
        162	router.post("/api/negotiations/:id/propose", async (req: Request, res: Response) => {
        163	  try {
        164	    // First check if consensus is reached
        165	    const consensusResult = await detectConsensus(req.params.id);
        166	    
        167	    if (!consensusResult.consensusReached && !req.body.force) {
        168	      return res.status(400).json({
        169	        error: "Negotiation has not reached consensus",
        170	        consensusStatus: consensusResult
        171	      });
        172	    }
        173	    
        174	    // Convert to proposal
        175	    const result = await createProposalFromNegotiation(
        176	      req.params.id,
        177	      { title: req.body.title, autoCreate: req.body.force }
        178	    );
        179	    
        180	    res.status(201).json(result);
        181	  } catch (err: any) {
        182	    res.status(500).json({
        183	      error: "Failed to create proposal from negotiation",
        184	      message: err.message || "Unknown error"
        185	    });
        186	  }
        187	});
        188	
        189	export default router;

==============================================
FILE: ./backend/src/routes/onboarding.ts
==============================================

          1	import { Router, Request, Response } from 'express';
          2	import { PrismaClient, Prisma } from '@prisma/client'; // Import Prisma namespace for types
          3	// Remove jwt import if only used for local requireAuth
          4	import { requireAuth, AuthenticatedRequest } from '../middleware/requireAuth'; // Import centralized auth
          5	
          6	const prisma = new PrismaClient();
          7	const router = Router();
          8	
          9	// Remove local requireAuth definition
         10	// Remove local AuthenticatedRequest interface definition
         11	
         12	// Define expected body structure for onboarding steps
         13	// Renamed agentPreferences to preferences to match Prisma model
         14	interface OnboardingStepBody {
         15	    agentName?: string;
         16	    agentColor?: string;
         17	    preferences?: Record<string, any>; // User provides standard JSON
         18	    digestFrequency?: number;
         19	    digestTone?: string;
         20	}
         21	
         22	// Define specific update payload types using Prisma generated types
         23	// Pick only the relevant fields that can be updated in onboarding
         24	type UserUpdatePayload = Pick<Prisma.UserUpdateInput, 'digestFrequency' | 'digestTone'>;
         25	type AgentUpdatePayload = Pick<Prisma.AgentUpdateInput, 'name' | 'color' | 'preferences'>;
         26	
         27	
         28	// POST /api/onboarding/steps/:step
         29	router.post('/steps/:step', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
         30	    const { step } = req.params;
         31	    // Cast the body to the expected structure
         32	    const data = req.body as OnboardingStepBody;
         33	    const userId = req.user?.userId;
         34	
         35	    if (!userId) {
         36	        return res.status(401).json({ error: 'Authentication invalid or missing user ID.' });
         37	    }
         38	
         39	    // Ensure agent exists for this user, or create one if not
         40	    let agent = await prisma.agent.findFirst({ where: { userId } });
         41	    if (!agent) {
         42	        try {
         43	            agent = await prisma.agent.create({
         44	                data: {
         45	                    userId,
         46	                    name: data.agentName || "Agent",
         47	                    color: data.agentColor || "#007bff",
         48	                    preferences: data.preferences || {},
         49	                    publicKey: "placeholder-key",
         50	                    encryptedPrivKey: "placeholder-priv",
         51	                }
         52	            });
         53	            console.log(`Created new agent for user ${userId}: ${agent.id}`);
         54	        } catch (err) {
         55	            console.error("Error creating agent during onboarding:", err);
         56	            return res.status(500).json({ error: "Failed to create agent during onboarding." });
         57	        }
         58	    }
         59	    const agentId = agent.id;
         60	
         61	    try {
         62	        // Initialize with specific Prisma types
         63	        let updateUserData: UserUpdatePayload = {};
         64	        let updateAgentData: AgentUpdatePayload = {};
         65	
         66	        // Map data based on step
         67	        switch (step) {
         68	            case '1':
         69	            case 'name_appearance':
         70	                // Use 'name' and 'color' matching AgentUpdatePayload keys
         71	                if (data.agentName !== undefined) updateAgentData.name = data.agentName;
         72	                if (data.agentColor !== undefined) updateAgentData.color = data.agentColor;
         73	                break;
         74	            case '2':
         75	            case 'preferences':
         76	                 // Use 'preferences' matching AgentUpdatePayload key
         77	                 // Cast to Prisma.InputJsonValue for type safety with Prisma
         78	                 if (data.preferences !== undefined) updateAgentData.preferences = data.preferences as Prisma.InputJsonValue;
         79	                break;
         80	            case '3':
         81	            case 'digest_settings':
         82	                if (data.digestFrequency !== undefined) updateUserData.digestFrequency = data.digestFrequency;
         83	                if (data.digestTone !== undefined) updateUserData.digestTone = data.digestTone;
         84	                break;
         85	            default:
         86	                return res.status(400).json({ error: `Invalid onboarding step: ${step}` });
         87	        }
         88	
         89	        // Perform updates only if there's data to update
         90	        const userUpdatePromise = Object.keys(updateUserData).length > 0
         91	            ? prisma.user.update({ where: { id: userId }, data: updateUserData })
         92	            : Promise.resolve(); // No update needed
         93	
         94	        const agentUpdatePromise = Object.keys(updateAgentData).length > 0
         95	            ? prisma.agent.update({ where: { id: agentId }, data: updateAgentData })
         96	            : Promise.resolve(); // No update needed
         97	
         98	        // Wait for both potential updates to complete
         99	        await Promise.all([userUpdatePromise, agentUpdatePromise]);
        100	
        101	        console.log(`Onboarding step ${step} processed for user ${userId}, agent ${agentId}`);
        102	        res.status(200).json({ message: `Step ${step} data saved successfully.` });
        103	
        104	    } catch (error) {
        105	        console.error(`Error processing onboarding step ${step} for user ${userId}:`, error);
        106	        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        107	             // More specific error check for Prisma record not found
        108	             return res.status(404).json({ error: 'User or Agent not found.' });
        109	        }
        110	        res.status(500).json({ error: 'Internal server error processing onboarding step.' });
        111	    }
        112	});
        113	
        114	/**
        115	 * POST /api/onboarding/message
        116	 * Handles FSM-based onboarding chat messages.
        117	 */
        118	router.post('/message', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
        119	  try {
        120	    const { message, step, selectedIssues, issueQueue, currentIssueIndex } = req.body;
        121	    const userId = req.user?.userId;
        122	    
        123	    console.log('[DEBUG-ONBOARDING] Message received with:', {
        124	      userId,
        125	      message: message?.substring(0, 50),
        126	      step,
        127	      selectedIssuesCount: selectedIssues?.length,
        128	      issueQueueCount: issueQueue?.length,
        129	      currentIssueIndex
        130	    });
        131	
        132	    if (!userId) {
        133	      console.log('[DEBUG-ONBOARDING] Authentication invalid or missing user ID');
        134	      return res.status(401).json({ error: 'Authentication invalid or missing user ID.' });
        135	    }
        136	
        137	    // Get agent for this user
        138	    const agent = await prisma.agent.findFirst({
        139	      where: { userId }
        140	    });
        141	
        142	    if (!agent) {
        143	      console.log('[DEBUG-ONBOARDING] Agent not found for user:', userId);
        144	      return res.status(404).json({ error: 'Agent not found for user' });
        145	    }
        146	    
        147	    console.log('[DEBUG-ONBOARDING] Found agent:', {
        148	      id: agent.id,
        149	      name: agent.name,
        150	      onboardingCompleted: agent.onboardingCompleted
        151	    });
        152	
        153	    // Call FSM onboarding logic
        154	    console.log('[DEBUG-ONBOARDING] Calling conductOnboardingChat...');
        155	    try {
        156	      const result = await (await import('../services/agent-service')).conductOnboardingChat(
        157	        userId,
        158	        agent.id,
        159	        message,
        160	        {
        161	          step,
        162	          selectedIssues,
        163	          issueQueue,
        164	          currentIssueIndex
        165	        }
        166	      );
        167	      
        168	      console.log('[DEBUG-ONBOARDING] Chat result:', {
        169	        nextStep: result.nextStep,
        170	        completedOnboarding: result.completedOnboarding,
        171	        extractedPreferencesKeys: result.extractedPreferences ? Object.keys(result.extractedPreferences) : [],
        172	        responseLength: result.response?.length
        173	      });
        174	      
        175	      return res.json(result);
        176	    } catch (chatError) {
        177	      console.error('[DEBUG-ONBOARDING] Error in conductOnboardingChat:', chatError);
        178	      throw chatError;
        179	    }
        180	  } catch (error) {
        181	    console.error('Error in onboarding message route:', error);
        182	    return res.status(500).json({ error: 'Internal server error' });
        183	  }
        184	});
        185	
        186	/**
        187	 * POST /api/onboarding/reset
        188	 * Resets onboarding state for the current user's agent.
        189	 */
        190	router.post('/reset', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
        191	  try {
        192	    const userId = req.user?.userId;
        193	    const { agentId } = req.body;
        194	
        195	    if (!userId || !agentId) {
        196	      return res.status(400).json({ error: 'Missing user or agent ID.' });
        197	    }
        198	
        199	    // Reset agent to pre-onboarding state
        200	    await prisma.agent.update({
        201	      where: { id: agentId },
        202	      data: {
        203	        name: 'Agent',
        204	        color: '#4299E1',
        205	        preferences: {},
        206	        onboardingCompleted: false
        207	      } as any
        208	    });
        209	
        210	    // Delete onboarding chat messages for this agent/user
        211	    // Use the standard Prisma model property (singular, camelCase)
        212	    await prisma.chatMessage.deleteMany({
        213	      where: {
        214	        agentId,
        215	        userId,
        216	        metadata: {
        217	          path: ['isOnboarding'],
        218	          equals: true
        219	        }
        220	      }
        221	    });
        222	
        223	    res.json({ message: 'Onboarding reset successfully.' });
        224	  } catch (error) {
        225	    console.error('Error resetting onboarding:', error);
        226	    res.status(500).json({ error: 'Failed to reset onboarding.' });
        227	  }
        228	});
        229	
        230	export default router;

==============================================
FILE: ./backend/src/routes/proposal.ts
==============================================

          1	import { Router, Request, Response } from 'express';
          2	import { PrismaClient } from '@prisma/client';
          3	// Remove jwt import
          4	import { requireAuth, AuthenticatedRequest } from '../middleware/requireAuth'; // Import centralized auth
          5	
          6	const prisma = new PrismaClient();
          7	const router = Router();
          8	
          9	// Remove local requireAuth definition
         10	
         11	// POST /api/proposals (create)
         12	// Use AuthenticatedRequest type
         13	import { analyzeProposal, generateVote, generateComment } from '../services/agent-service';
         14	
         15	router.post('/', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
         16	  if (!req.user || !req.user.agentId) {
         17	    return res.status(401).json({ error: 'Authentication invalid or missing agent ID.' });
         18	  }
         19	  const { agentId } = req.user;
         20	  const { title, description, type, playMode, amount, quorum, threshold, closeAt, vetoWindowEnd } = req.body;
         21	  try {
         22	    const proposal = await prisma.proposal.create({
         23	      data: {
         24	        title,
         25	        description,
         26	        type: type || 'standard',
         27	        playMode: !!playMode,
         28	        amount,
         29	        createdByAgentId: agentId,
         30	        quorum,
         31	        threshold,
         32	        closeAt: new Date(closeAt),
         33	        vetoWindowEnd: new Date(vetoWindowEnd),
         34	      },
         35	    });
         36	
         37	    // Call agent-service to analyze proposal after creation
         38	    const agentPreferences = {}; // TODO: Fetch agent preferences from DB or context
         39	    const analysis = await analyzeProposal(proposal, agentPreferences, agentId);
         40	    // Optionally store or log analysis result
         41	
         42	    res.json({ proposal, analysis });
         43	  } catch (error) {
         44	    res.status(400).json({ error: 'Invalid proposal data' });
         45	  }
         46	});
         47	
         48	// GET /api/proposals (list)
         49	// Use AuthenticatedRequest type (though req.user isn't used here, it's good practice for consistency)
         50	router.get('/', requireAuth, async (_req: AuthenticatedRequest, res: Response) => {
         51	  const proposals = await prisma.proposal.findMany();
         52	  res.json(proposals);
         53	});
         54	
         55	// GET /api/proposals/:id (read)
         56	// Use AuthenticatedRequest type
         57	router.get('/:id', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
         58	  const proposal = await prisma.proposal.findUnique({ where: { id: req.params.id } });
         59	  if (!proposal) return res.status(404).json({ error: 'Not found' });
         60	  res.json(proposal);
         61	});
         62	
         63	// PUT /api/proposals/:id (update)
         64	// Use AuthenticatedRequest type
         65	router.put('/:id', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
         66	  try {
         67	    // TODO: Add authorization check - should only creator/admin update?
         68	    const proposal = await prisma.proposal.update({
         69	      where: { id: req.params.id },
         70	      data: req.body,
         71	    });
         72	    res.json(proposal);
         73	  } catch (error) {
         74	    res.status(400).json({ error: 'Update failed' });
         75	  }
         76	});
         77	
         78	// DELETE /api/proposals/:id (delete)
         79	// Use AuthenticatedRequest type
         80	router.delete('/:id', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
         81	  try {
         82	    // TODO: Add authorization check - should only creator/admin delete?
         83	    await prisma.proposal.delete({ where: { id: req.params.id } });
         84	    res.json({ status: 'deleted' });
         85	  } catch (error) {
         86	    res.status(400).json({ error: 'Delete failed' });
         87	  }
         88	});
         89	
         90	export default router;


==============================================
FILE: ./backend/src/routes/vote.ts
==============================================

          1	import { Router, Request, Response } from 'express';
          2	import { PrismaClient } from '@prisma/client';
          3	import jwt from 'jsonwebtoken';
          4	import { blockIfPaused } from './agents/pauseAgentHandler';
          5	import { generateVote } from '../services/agent-service';
          6	
          7	const prisma = new PrismaClient();
          8	const router = Router();
          9	
         10	function requireAuth(req: Request, res: Response, next: () => void) {
         11	  const auth = req.headers.authorization;
         12	  if (!auth || !auth.startsWith('Bearer ')) return res.status(401).json({ error: 'Missing token' });
         13	  try {
         14	    const payload = jwt.verify(auth.split(' ')[1], process.env.JWT_SECRET!);
         15	    (req as any).user = payload;
         16	    next();
         17	  } catch {
         18	    res.status(401).json({ error: 'Invalid token' });
         19	  }
         20	}
         21	
         22	// POST /api/proposals/:id/vote
         23	router.post('/proposals/:id/vote', requireAuth, blockIfPaused, async (req, res) => {
         24	  const { agentId } = (req as any).user;
         25	  const { value } = req.body;
         26	  try {
         27	    const proposal = await prisma.proposal.findUnique({ where: { id: req.params.id } });
         28	    if (!proposal) return res.status(404).json({ error: 'Proposal not found' });
         29	    const now = new Date();
         30	    if (now > proposal.vetoWindowEnd) {
         31	      return res.status(403).json({ error: 'Veto window expired; cannot override vote' });
         32	    }
         33	
         34	    // Call agent-service to generate vote suggestion (optional, can be used for logging or validation)
         35	    const agentPreferences = {}; // TODO: Fetch agent preferences from DB or context
         36	    const voteSuggestion = await generateVote(proposal, agentPreferences, agentId);
         37	    console.log(`Agent vote suggestion: ${voteSuggestion}`);
         38	
         39	    // Check for existing vote
         40	    const existing = await prisma.vote.findFirst({ where: { proposalId: req.params.id, agentId } });
         41	    if (existing) {
         42	      // Override
         43	      await prisma.vote.update({ where: { id: existing.id }, data: { value, confidence: 1.0 } });
         44	      return res.json({ status: 'overridden' });
         45	    } else {
         46	      // New vote
         47	      await prisma.vote.create({ data: { proposalId: req.params.id, agentId, value, confidence: 1.0 } });
         48	      return res.json({ status: 'voted' });
         49	    }
         50	  } catch (error) {
         51	    res.status(400).json({ error: 'Vote failed' });
         52	  }
         53	});
         54	
         55	export default router;


==============================================
FILE: ./backend/src/scripts/fix-name-assignment.js
==============================================

          1	// Script to fix the user and agent name assignments in the database
          2	const { PrismaClient } = require('@prisma/client');
          3	const prisma = new PrismaClient();
          4	
          5	async function fixNameAssignment() {
          6	  try {
          7	    console.log('Starting name correction...');
          8	    
          9	    // Get test user with email bobtest@test.com
         10	    const user = await prisma.user.findUnique({
         11	      where: { email: 'bobtest@test.com' }
         12	    });
         13	    
         14	    if (!user) {
         15	      console.error('User bobtest@test.com not found');
         16	      return;
         17	    }
         18	    
         19	    console.log(`Found user: ${user.id}, current name: ${user.name}`);
         20	    
         21	    // Get the agent associated with this user
         22	    const agent = await prisma.agent.findFirst({
         23	      where: { userId: user.id }
         24	    });
         25	    
         26	    if (!agent) {
         27	      console.error(`No agent found for user ID ${user.id}`);
         28	      return;
         29	    }
         30	    
         31	    console.log(`Found agent: ${agent.id}, current name: ${agent.name}`);
         32	    
         33	    // Update the user's name to Adam
         34	    await prisma.user.update({
         35	      where: { id: user.id },
         36	      data: { name: 'Adam' }
         37	    });
         38	    
         39	    // Update the agent's name to Prax
         40	    await prisma.agent.update({
         41	      where: { id: agent.id },
         42	      data: { name: 'Prax' }
         43	    });
         44	    
         45	    console.log('Name assignment fixed successfully!');
         46	    console.log('User name updated to "Adam"');
         47	    console.log('Agent name updated to "Prax"');
         48	    
         49	  } catch (error) {
         50	    console.error('Error fixing name assignment:', error);
         51	  } finally {
         52	    await prisma.$disconnect();
         53	  }
         54	}
         55	
         56	fixNameAssignment()
         57	  .catch(e => {
         58	    console.error(e);
         59	    process.exit(1);
         60	  });

==============================================
FILE: ./backend/src/services/agent-service.ts
==============================================

          1	import OpenAI from 'openai';
          2	import { logLlmUsage } from './llm-logging-service';
          3	import { PrismaClient, Prisma } from '@prisma/client'; // Import Prisma namespace for types
          4	import logger from '../utils/logger';
          5	import {
          6	  ONBOARDING_SYSTEM_PROMPT,
          7	  ONBOARDING_SCENARIO_CONTEXT,
          8	  PERSONALIZED_FOLLOW_UP_PROMPT,
          9	  ONBOARDING_PREFERENCE_EXTRACTION_PROMPT,
         10	  BALANCED_ISSUE_PRESENTATION
         11	} from './prompt-templates/onboarding-prompts';
         12	// import { extractPreferences } from './preference-extractor'; // Import extractPreferences
         13	
         14	// Use the existing Prisma instance from the global context if available
         15	const prisma = new PrismaClient();
         16	
         17	// Declare the global type to avoid TypeScript errors
         18	declare global {
         19	  var prisma: PrismaClient | undefined;
         20	}
         21	
         22	const OPENROUTER_BASE_URL = 'https://openrouter.ai/api/v1';
         23	const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY || '';
         24	const DEFAULT_MODEL = process.env.OPENROUTER_DEFAULT_MODEL || 'openai/gpt-4.1';
         25	
         26	if (!OPENROUTER_API_KEY) {
         27	  throw new Error('OpenRouter API key is not set in environment variables.');
         28	}
         29	
         30	const openai = new OpenAI({
         31	  apiKey: OPENROUTER_API_KEY,
         32	  baseURL: OPENROUTER_BASE_URL,
         33	});
         34	
         35	interface CallLLMOptions {
         36	  stream?: boolean;
         37	  structuredOutput?: boolean;
         38	  agentId?: string;
         39	  model?: string;
         40	}
         41	
         42	interface LlmUsageOutcome {
         43	  success: boolean;
         44	  errorMessage?: string;
         45	}
         46	
         47	export async function callLLM( // Export callLLM
         48	  messages: { role: string; content: string }[],
         49	  model: string = DEFAULT_MODEL,
         50	  options: CallLLMOptions = {}
         51	): Promise<{ content: string; usage: { inputTokens: number; outputTokens: number; latencyMs: number } }> {
         52	  const startTime = Date.now();
         53	  let outcome: LlmUsageOutcome = { success: true };
         54	  try {
         55	    const response = await openai.chat.completions.create({
         56	      model,
         57	      messages: messages as any,
         58	      stream: options.stream || false,
         59	    });
         60	
         61	    const latencyMs = Date.now() - startTime;
         62	    const content = options.stream
         63	      ? '' // Streaming handling can be implemented as needed
         64	      : (response as any).choices?.[0]?.message?.content || '';
         65	
         66	    const usage = (response as any).usage || { prompt_tokens: 0, completion_tokens: 0 };
         67	    const inputTokens = usage.prompt_tokens || 0;
         68	    const outputTokens = usage.completion_tokens || 0;
         69	
         70	    // Log usage
         71	    await logLlmUsage({
         72	      agentId: options.agentId,
         73	      model,
         74	      inputTokens,
         75	      outputTokens,
         76	      latencyMs,
         77	      outcome: 'success',
         78	    });
         79	
         80	    return { content, usage: { inputTokens, outputTokens, latencyMs } };
         81	  } catch (error: any) {
         82	    const latencyMs = Date.now() - startTime;
         83	    outcome = { success: false, errorMessage: error.message || 'Unknown error' };
         84	
         85	    // Log error usage
         86	    await logLlmUsage({
         87	      agentId: options.agentId,
         88	      model,
         89	      inputTokens: 0,
         90	      outputTokens: 0,
         91	      latencyMs,
         92	      outcome: 'error',
         93	      errorMessage: outcome.errorMessage,
         94	    });
         95	
         96	    throw error;
         97	  }
         98	}
         99	
        100	export async function analyzeProposal(proposalData: any, agentPreferences: any, agentId?: string) {
        101	  const messages: { role: string; content: string; name?: string }[] = [
        102	    {
        103	      role: 'system',
        104	      content: 'You are an AI assistant that analyzes proposals for alignment with agent preferences.',
        105	    },
        106	    {
        107	      role: 'user',
        108	      content: `Proposal details: ${JSON.stringify(proposalData)}`,
        109	    },
        110	    {
        111	      role: 'user',
        112	      content: `Agent preferences: ${JSON.stringify(agentPreferences)}`,
        113	    },
        114	    {
        115	      role: 'user',
        116	      content: 'Please provide an alignment score from 0 to 100 and a brief explanation.',
        117	    },
        118	  ];
        119	
        120	  const { content } = await callLLM(messages, DEFAULT_MODEL, { agentId });
        121	  return content;
        122	}
        123	
        124	export async function generateVote(proposalData: any, agentPreferences: any, agentId?: string) {
        125	  const messages: { role: string; content: string; name?: string }[] = [
        126	    {
        127	      role: 'system',
        128	      content: 'You are an AI agent that votes on proposals based on preferences.',
        129	    },
        130	    {
        131	      role: 'user',
        132	      content: `Proposal details: ${JSON.stringify(proposalData)}`,
        133	    },
        134	    {
        135	      role: 'user',
        136	      content: `Agent preferences: ${JSON.stringify(agentPreferences)}`,
        137	    },
        138	    {
        139	      role: 'user',
        140	      content: "Please generate a vote: 'yes', 'no', or 'abstain' with reasoning.",
        141	    },
        142	  ];
        143	
        144	  const { content } = await callLLM(messages, DEFAULT_MODEL, { agentId });
        145	  return content;
        146	}
        147	
        148	export async function generateComment(proposalData: any, agentPreferences: any, agentId?: string) {
        149	  const messages: { role: string; content: string; name?: string }[] = [
        150	    {
        151	      role: 'system',
        152	      content: 'You are an AI agent that generates comments on proposals.',
        153	    },
        154	    {
        155	      role: 'user',
        156	      content: `Proposal details: ${JSON.stringify(proposalData)}`,
        157	    },
        158	    {
        159	      role: 'user',
        160	      content: `Agent preferences: ${JSON.stringify(agentPreferences)}`,
        161	    },
        162	    {
        163	      role: 'user',
        164	      content: 'Please generate a constructive comment.',
        165	    },
        166	  ];
        167	
        168	  const { content } = await callLLM(messages, DEFAULT_MODEL, { agentId });
        169	  return content;
        170	}
        171	
        172	export async function generateDigest(userId: string, recentActivity: any, agentId?: string) {
        173	  const messages: { role: string; content: string; name?: string }[] = [
        174	    {
        175	      role: 'system',
        176	      content: 'You are an AI assistant that creates digest summaries of recent activity.',
        177	    },
        178	    {
        179	      role: 'user',
        180	      content: `User ID: ${userId}`,
        181	    },
        182	    {
        183	      role: 'user',
        184	      content: `Recent activity: ${JSON.stringify(recentActivity)}`,
        185	    },
        186	    {
        187	      role: 'user',
        188	      content: 'Please provide a concise summary digest.',
        189	    },
        190	  ];
        191	
        192	  const { content } = await callLLM(messages, DEFAULT_MODEL, { agentId });
        193	  return content;
        194	}
        195	
        196	/**
        197	 * Process a chat message from a user and generate an agent response
        198	 * @param userId User ID sending the message
        199	 * @param agentId Agent ID receiving the message
        200	 * @param message Content of the user's message
        201	 * @param contextMessages Number of previous messages to include as context
        202	 * @returns Agent's response and any extracted preferences or actions
        203	 */
        204	export async function processChatMessage(
        205	  userId: string,
        206	  agentId: string,
        207	  message: string,
        208	  contextMessages: number = 10
        209	): Promise<{
        210	  response: string;
        211	  extractedPreferences?: Record<string, any>;
        212	  actionRequired?: boolean;
        213	  suggestedAction?: string;
        214	}> {
        215	  // Import dynamically to avoid circular dependencies
        216	  const chatService = await import('./chat-service');
        217	
        218	  try {
        219	    // Get conversation context
        220	    const context = await chatService.default.getConversationContext(agentId, userId, contextMessages);
        221	
        222	    const agent = await prisma.agent.findUnique({
        223	      where: { id: agentId },
        224	      select: {
        225	        name: true,
        226	        color: true,
        227	        preferences: true
        228	      }
        229	    });
        230	
        231	    const user = await prisma.user.findFirst({
        232	      where: { agent: { id: agentId } },
        233	      select: { email: true }
        234	    });
        235	
        236	    if (!agent) {
        237	      throw new Error(`Agent with ID ${agentId} not found`);
        238	    }
        239	    
        240	    // Import chat prompt templates
        241	    const chatPrompts = await import('./prompt-templates/chat-prompts');
        242	    
        243	    // Extract user knowledge from preferences
        244	    const preferences = agent.preferences || {};
        245	    const userKnowledge = typeof preferences === 'object' ?
        246	      (preferences as any).userKnowledge || {} : {};
        247	    
        248	    // Generate personalized system prompt
        249	    const systemPrompt = chatPrompts.USER_FACING_PERSONA_TEMPLATE({
        250	      agentName: agent.name,
        251	      agentColor: agent.color || '#4299E1',
        252	      userKnowledge: userKnowledge,
        253	      communicationStyle: userKnowledge.communication_style || 'default'
        254	    });
        255	
        256	    const messages = [
        257	      {
        258	        role: 'system',
        259	        content: systemPrompt
        260	      },
        261	      ...context.map(msg => ({
        262	        role: msg.role,
        263	        content: msg.content
        264	      })),
        265	      {
        266	        role: 'user',
        267	        content: message
        268	      }
        269	    ];
        270	
        271	    const { content } = await callLLM(messages, DEFAULT_MODEL, { agentId });
        272	
        273	    await chatService.default.saveMessage(userId, agentId, message, 'user');
        274	    await chatService.default.saveMessage(userId, agentId, content, 'agent');
        275	
        276	    // Extract knowledge from the conversation asynchronously
        277	    // This is done after sending the response to avoid delaying the user experience
        278	    extractAndUpdateUserKnowledge(userId, agentId, message, content, agent).catch(err => {
        279	      logger.error('Error extracting knowledge from conversation:', err);
        280	    });
        281	
        282	    return {
        283	      response: content,
        284	      extractedPreferences: {}
        285	    };
        286	  } catch (error) {
        287	    console.error('Error processing chat message:', error);
        288	    return {
        289	      response: "I'm sorry, I couldn't process your message. Please try again later.",
        290	      extractedPreferences: {}
        291	    };
        292	  }
        293	}
        294	
        295	/**
        296	 * Conduct an onboarding conversation with a new user
        297	 * @param userId User ID being onboarded
        298	 * @param agentId Agent ID conducting the onboarding
        299	 * @param message User's message
        300	 * @param stage Current onboarding stage
        301	 * @returns Agent's response and onboarding progress
        302	 */
        303	export async function conductOnboardingChat(
        304	  userId: string,
        305	  agentId: string,
        306	  message: string,
        307	  metadata?: {
        308	    step?: number;
        309	    selectedIssues?: string[];
        310	    issueQueue?: string[];
        311	    currentIssueIndex?: number;
        312	  }
        313	): Promise<{
        314	  response: string;
        315	  extractedPreferences?: Record<string, any>;
        316	  nextStep?: number;
        317	  completedOnboarding?: boolean;
        318	  metadata?: any;
        319	  userMessage?: any; // Assuming ChatMessage type from frontend is compatible or will be handled
        320	  agentMessage?: any; // Assuming ChatMessage type from frontend is compatible or will be handled
        321	}> {
        322	  try {
        323	    // Import services
        324	    const chatService = await import('./chat-service');
        325	    const scenarioService = await import('./scenario-service');
        326	
        327	    // [DEBUG] Onboarding FSM entry
        328	    console.log('[Onboarding/FSM] userId:', userId, 'agentId:', agentId, 'step:', metadata?.step ?? 0, 'message:', message?.slice(0, 100));
        329	
        330	    // Get conversation context
        331	    const context = await chatService.default.getConversationContext(agentId, userId, 20);
        332	
        333	    // Get agent details
        334	    const agent = await prisma.agent.findUnique({
        335	      where: { id: agentId },
        336	      select: { name: true, color: true, preferences: true }
        337	    });
        338	
        339	    if (!agent) {
        340	      throw new Error(`Agent with ID ${agentId} not found`);
        341	    }
        342	
        343	    // Initialize or use provided metadata
        344	    const step = metadata?.step ?? 0;
        345	    let selectedIssues = metadata?.selectedIssues ?? [];
        346	    let issueQueue = metadata?.issueQueue ?? [];
        347	    let currentIssueIndex = metadata?.currentIssueIndex ?? 0;
        348	
        349	    // Get issues from database
        350	    const issuesForMenu = await scenarioService.default.getFormattedIssuesForOnboardingMenu();
        351	    const issueDetails = await scenarioService.default.getFullIssueDetails();
        352	
        353	    // Step-specific instructions based on the 0-7 FSM
        354	    let stepInstructions = '';
        355	    let agentResponseContent = ''; // Variable to hold the agent's response content
        356	    let nextStep = step;
        357	    let completedOnboarding = false;
        358	    let preferences: Record<string, any> = {}; // Declare preferences here and initialize
        359	    let useHardcodedResponse = false; // Flag to determine if we should bypass LLM for certain responses
        360	
        361	
        362	    // FSM logic
        363	    switch (step) {
        364	      case 0: // Collect User Name
        365	        stepInstructions = `(1/9) Welcome! What is your name?`;
        366	        nextStep = 1;
        367	        // No processing of message needed in this step, just asking for the name.
        368	        break;
        369	
        370	      case 1: // Greeting & Nickname
        371	        stepInstructions = `(2/9) Nice to meet you, ${message.trim()}! I'm your Praxis Agent. Pick a short name for me when we chat.`;
        372	        nextStep = 2;
        373	
        374	        // Save user's name
        375	        if (message && message.trim()) {
        376	          try {
        377	            // Use executeRaw for direct database access without Prisma type checking
        378	            await prisma.$executeRaw`UPDATE "User" SET name = ${message.trim()} WHERE id = ${userId}`;
        379	            console.log(`[Onboarding/FSM] Updated user name to: ${message.trim()}`);
        380	          } catch (err) {
        381	            console.error('[Onboarding/FSM] Failed to update user name:', err);
        382	          }
        383	        }
        384	
        385	        // Update agent name immediately if user provided one in this step (if they skipped step 0)
        386	        // This logic might need refinement based on how strictly we enforce step order.
        387	        // For now, assuming step 1 message is either agent name or user name if step 0 was just completed.
        388	        // We'll prioritize saving user name if step 0 was just completed.
        389	        // If step was 1 and message is not just a name (e.g., "Call me AgentX"), update agent name.
        390	        if (step === 1 && message && message.trim() && !/^\s*\S+\s*$/.test(message.trim())) {
        391	             const name = message.trim();
        392	             try {
        393	               await prisma.agent.update({
        394	                 where: { id: agentId },
        395	                 data: { name }
        396	               });
        397	               console.log(`[Onboarding/FSM] Updated agent name to: ${name}`);
        398	             } catch (err) {
        399	               console.error('[Onboarding/FSM] Failed to update agent name:', err);
        400	             }
        401	        }
        402	        break;
        403	
        404	      case 2: // Issue Menu
        405	        stepInstructions = `(3/9) Here are the issues being discussed right now. Reply with the numbers you care about (e.g., 1,3,5).
        406	        ${issuesForMenu}`;
        407	        nextStep = 3;
        408	
        409	        // Process the user's response to extract selected issues
        410	        if (message) {
        411	          selectedIssues = extractIssueNumbers(message);
        412	          issueQueue = [...selectedIssues]; // Create a queue for step 3
        413	          // [DEBUG] Selected issues and mapping
        414	          console.log(`[Onboarding/FSM] Selected issues: ${selectedIssues.join(',')} (Raw message: "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}")`);
        415	          // Save selected issues to DB for the frontend to access and update the issues matrix
        416	          try {
        417	            const currentPreferences = (await prisma.agent.findUnique({
        418	              where: { id: agentId },
        419	              select: { preferences: true }
        420	            }))?.preferences || {};
        421	
        422	            // Create an issues matrix array to populate the frontend matrix
        423	            const issueList = [];
        424	            for (const issueId of selectedIssues) {
        425	              // Use the issueDetails that was already loaded
        426	              const issueDetail = issueDetails[Number(issueId)];
        427	              if (issueDetail) {
        428	                issueList.push({
        429	                  id: issueId,
        430	                  title: issueDetail.title || `Issue ${issueId}`,
        431	                  description: issueDetail.description || '',
        432	                  stance: null,
        433	                  reason: '', // Empty string, not null
        434	                  summary: '',
        435	                  isPriority: false
        436	                });
        437	              } else {
        438	                issueList.push({
        439	                  id: issueId,
        440	                  title: `Issue ${issueId}`,
        441	                  description: '',
        442	                  stance: null,
        443	                  reason: '', // Empty string, not null
        444	                  summary: '',
        445	                  isPriority: false
        446	                });
        447	              }
        448	            }
        449	            console.log('[Onboarding/FSM][Step 2 SAVE] Initial issuesMatrix to save:', JSON.stringify(issueList, null, 2));
        450	            await prisma.agent.update({
        451	              where: { id: agentId },
        452	              data: {
        453	                preferences: {
        454	                  ...(typeof currentPreferences === 'object' ? currentPreferences : {}),
        455	                  selectedIssues,
        456	                  issuesMatrix: issueList
        457	                }
        458	              }
        459	            });
        460	            console.log(`[Onboarding/FSM] Saved selected issues to agent preferences: ${selectedIssues.join(',')}`);
        461	          } catch (err) {
        462	            console.error('[Onboarding/FSM] Failed to save selected issues to agent preferences:', err);
        463	          }
        464	        }
        465	        break;
        466	
        467	      case 3: // Stance Loop
        468	        if (issueQueue.length === 0) {
        469	          // If no more issues to process, move to next step
        470	          nextStep = 4;
        471	          stepInstructions = generateStep4Instruction(); // Updated step number
        472	          break;
        473	        }
        474	
        475	        const currentIssueNumber = issueQueue[0];
        476	        const currentIssue = issueDetails[Number(currentIssueNumber)]; // Cast to Number
        477	
        478	        if (!currentIssue) {
        479	          // If issue not found, skip it
        480	          issueQueue.shift();
        481	          stepInstructions = `I don't have details for that issue. Let's move on.`;
        482	          break;
        483	        }
        484	
        485	        // Generate balanced perspectives for the current issue in format matching BALANCED_ISSUE_PRESENTATION
        486	        // [DEBUG] Generating balanced perspectives for issue
        487	        console.log('[Onboarding/FSM] Generating balanced perspectives for issue:', currentIssue.title);
        488	
        489	        let perspectivesText = "";
        490	        if (currentIssue.stances && currentIssue.stances.length > 0) {
        491	          // Format similar to our template example - using Approach A, B, C format
        492	          perspectivesText = currentIssue.stances.map((stance: any, index: number) => {
        493	            const letter = String.fromCharCode(65 + index); // A, B, C, etc.
        494	            return `Approach ${letter} - ${stance.perspective} prioritize ${stance.opinion}`;
        495	          }).join('\n');
        496	          console.log('[Onboarding/FSM] Generated perspectives:', perspectivesText.substring(0, 100));
        497	        } else {
        498	          perspectivesText = "Different approaches exist with varying priorities:\n" +
        499	                           "Approach A - Some prioritize immediate needs\n" +
        500	                           "Approach B - Others focus on long-term solutions\n" +
        501	                           "Approach C - Some suggest a mixed approach balancing different factors";
        502	        }
        503	
        504	        // Generate stance question for current issue with balanced perspectives
        505	        stepInstructions = `(4/9) Issue ${currentIssueNumber} – ${currentIssue.title}:\n\n${currentIssue.description}\n\nBALANCED PERSPECTIVE:\n${perspectivesText}\n\nAfter considering these perspectives, do you prefer approach A, B, C or something else? One-line reason.`;
        506	
        507	        // Process the user's response to extract stance on the previous issue
        508	        // Only update the matrix if the message is not just a list of numbers (i.e., not the issue selection)
        509	        // and only after the first stance (currentIssueIndex > 0)
        510	        // Only update the matrix if the message is not just a list of numbers (i.e., not the issue selection)
        511	        if (
        512	          message &&
        513	          issueQueue.length > 0 &&
        514	          selectedIssues.length > 0 &&
        515	          !/^\d+(,\s*\d+)*$/.test(message.trim())
        516	        ) {
        517	          try {
        518	            // Log matrix state *before* attempting update in this step
        519	            const agentDataBeforeUpdate = await prisma.agent.findUnique({ where: { id: agentId }, select: { preferences: true } });
        520	            const matrixBeforeUpdate = (typeof agentDataBeforeUpdate?.preferences === 'object' ? agentDataBeforeUpdate?.preferences as Record<string, any> : {}).issuesMatrix || [];
        521	            console.log('[Onboarding/FSM][Step 3 PRE-UPDATE] issuesMatrix before processing stance:', JSON.stringify(matrixBeforeUpdate, null, 2)); // Updated step number
        522	
        523	            // Extract stance and reason from the message (Approach A/B/C or custom)
        524	            let stance = null;
        525	            let reason = message.trim();
        526	            
        527	            // Make sure we don't use the issue selection string as a reason
        528	            if (/^\d+(,\s*\d+)*$/.test(reason.trim())) {
        529	              reason = ''; // Use empty string instead of null to avoid type error
        530	            }
        531	            
        532	            const approachMatch = message.match(/\b(Approach\s*[A-C]|[A-C])\b/i);
        533	            // Map stance letter to balanced perspective text
        534	            let mappedSummary = '';
        535	            if (approachMatch) {
        536	              stance = approachMatch[0].replace(/\s+/g, '_').toUpperCase(); // e.g., "Approach_A" or "A"
        537	              reason = message.replace(approachMatch[0], '').trim();
        538	              // Map stance letter to perspective
        539	              if (currentIssue && currentIssue.stances && currentIssue.stances.length > 0) {
        540	                let idx = -1;
        541	                if (/A/i.test(approachMatch[0])) idx = 0;
        542	                else if (/B/i.test(approachMatch[0])) idx = 1;
        543	                else if (/C/i.test(approachMatch[0])) idx = 2;
        544	                if (idx >= 0 && currentIssue.stances[idx]) {
        545	                  mappedSummary = currentIssue.stances[idx].opinion || '';
        546	                }
        547	              }
        548	            } else {
        549	              // If not A/B/C, treat the whole message as a custom stance
        550	              stance = 'CUSTOM';
        551	            }
        552	            reason = reason.replace(/^[,.:;-]\s*/, ''); // Clean up punctuation
        553	            // If no custom reason, use mapped summary
        554	            if (!reason && mappedSummary) {
        555	              reason = mappedSummary;
        556	            }
        557	
        558	            // Always update the current issue (issueQueue[0])
        559	            const currentIssueId = issueQueue[0];
        560	            if (currentIssueId) {
        561	              console.log(`[Onboarding/FSM] Updating stance for issue #${currentIssueId} with stance: ${stance}, reason: ${reason.substring(0, 50)}...`);
        562	
        563	              // Update the issues matrix in agent preferences
        564	              const currentAgentData = await prisma.agent.findUnique({
        565	                where: { id: agentId },
        566	                select: { preferences: true }
        567	              });
        568	
        569	              const prefsObj = typeof currentAgentData?.preferences === 'object' ?
        570	                currentAgentData?.preferences as Record<string, any> :
        571	                {};
        572	
        573	              let issuesMatrix = prefsObj.issuesMatrix || [];
        574	              const existingIssueIndex = issuesMatrix.findIndex((i: any) => i.id === currentIssueId);
        575	
        576	              if (existingIssueIndex >= 0 && stance) {
        577	                // Update existing issue
        578	                issuesMatrix[existingIssueIndex] = {
        579	                  ...issuesMatrix[existingIssueIndex],
        580	                  stance: stance,
        581	                  reason: reason || issuesMatrix[existingIssueIndex].reason,
        582	                  summary: mappedSummary || (stance === 'CUSTOM' ? reason : undefined),
        583	                  title: currentIssue?.title || issuesMatrix[existingIssueIndex].title,
        584	                  description: currentIssue?.description || ''
        585	                };
        586	              }
        587	
        588	              // Save updated matrix
        589	              await prisma.agent.update({
        590	                where: { id: agentId },
        591	                data: {
        592	                  preferences: {
        593	                    ...prefsObj,
        594	                    issuesMatrix
        595	                  } as Prisma.InputJsonValue
        596	                }
        597	              });
        598	
        599	              console.log(`[Onboarding/FSM] Updated issue stance in matrix:`, JSON.stringify(issuesMatrix[existingIssueIndex]));
        600	              // Log the full issuesMatrix after update
        601	              const updatedAgent = await prisma.agent.findUnique({
        602	                where: { id: agentId },
        603	                select: { preferences: true }
        604	              });
        605	              let updatedMatrix: any[] = [];
        606	              if (updatedAgent?.preferences) {
        607	                let prefsObj: any;
        608	                if (typeof updatedAgent.preferences === 'string') {
        609	                  try {
        610	                    prefsObj = JSON.parse(updatedAgent.preferences);
        611	                  } catch {
        612	                    prefsObj = {};
        613	                  }
        614	                } else {
        615	                  prefsObj = updatedAgent.preferences;
        616	                }
        617	                updatedMatrix = prefsObj.issuesMatrix || [];
        618	              }
        619	              console.log('[Onboarding/FSM][DEBUG] issuesMatrix after update:', JSON.stringify(updatedMatrix, null, 2)); // Updated step number
        620	            }
        621	          } catch (err) {
        622	            console.error('[Onboarding] Error updating issue stance:', err);
        623	          }
        624	        }
        625	
        626	        // Pop the issue from queue after processing
        627	        issueQueue.shift();
        628	
        629	        // If queue is now empty, we'll advance to step 4 on next message
        630	        if (issueQueue.length === 0) {
        631	          nextStep = 4;
        632	        }
        633	        break;
        634	
        635	      case 4: // Top Priority
        636	        stepInstructions = `(5/9) Of those issues, which ONE matters most to you right now?`; // Updated step number
        637	        nextStep = 5; // Updated next step
        638	        break;
        639	
        640	      case 5: // Deal-Breakers
        641	        stepInstructions = `(6/9) Is there any outcome you absolutely could NOT accept in group decisions? One sentence or type 'none'.`; // Updated step number
        642	        nextStep = 6; // Updated next step
        643	
        644	        // Mark priority issue in the matrix
        645	        if (message && message.trim()) {
        646	          try {
        647	            // Look up the agent's current preferences
        648	            const currentAgentData = await prisma.agent.findUnique({
        649	              where: { id: agentId },
        650	              select: { preferences: true }
        651	            });
        652	
        653	            const prefsObj = typeof currentAgentData?.preferences === 'object' ?
        654	              currentAgentData?.preferences as Record<string, any> :
        655	              {};
        656	
        657	            let issuesMatrix = prefsObj.issuesMatrix || [];
        658	            if (issuesMatrix.length > 0) {
        659	              // Reset priorities first
        660	              issuesMatrix = issuesMatrix.map((issue: any) => ({ ...issue, isPriority: false }));
        661	
        662	              // Try to find the issue based on title, number, or key terms
        663	              const lowerMessage = message.toLowerCase();
        664	
        665	              // Try direct mention of issue number
        666	              const numberMatch = lowerMessage.match(/\b(?:issue)\s*#?(\d+)\b/i);
        667	              if (numberMatch && numberMatch[1]) {
        668	                const issueId = numberMatch[1];
        669	                const issueIndex = issuesMatrix.findIndex((i: any) => i.id === issueId);
        670	                if (issueIndex >= 0) {
        671	                  issuesMatrix[issueIndex].isPriority = true;
        672	                }
        673	              } else {
        674	                // Try to match by title
        675	                const priorityIssue = issuesMatrix.find((issue: any) => {
        676	                  return issue.title && lowerMessage.includes(issue.title.toLowerCase());
        677	                });
        678	
        679	                if (priorityIssue) {
        680	                  const issueIndex = issuesMatrix.findIndex((i: any) => i.id === priorityIssue.id);
        681	                  if (issueIndex >= 0) {
        682	                    issuesMatrix[issueIndex].isPriority = true;
        683	                  }
        684	                } else {
        685	                  // If no match found, set the first issue as priority
        686	                  if (issuesMatrix.length > 0) {
        687	                    issuesMatrix[0].isPriority = true;
        688	                  }
        689	                }
        690	              }
        691	
        692	              // Save updated matrix
        693	              await prisma.agent.update({
        694	                where: { id: agentId },
        695	                data: {
        696	                  preferences: {
        697	                    ...prefsObj,
        698	                    issuesMatrix
        699	                  } as Prisma.InputJsonValue
        700	                }
        701	              });
        702	
        703	              console.log(`[Onboarding/FSM] Updated priority issue in matrix:`, JSON.stringify(issuesMatrix));
        704	            }
        705	          } catch (err) {
        706	            console.error('[Onboarding] Error updating priority issue:', err);
        707	          }
        708	        }
        709	        break;
        710	
        711	      case 6: // Notify Pref
        712	        stepInstructions = `(7/9) How often should I brief you? A-major items only B-weekly digest C-every decision.`; // Updated step number
        713	        nextStep = 7; // Updated next step
        714	        break;
        715	
        716	      case 7: // Proposal Seed
        717	        stepInstructions = `(8/9) Any idea or proposal you'd like me to log for later? If none, just say 'done'.`; // Updated step number
        718	        nextStep = 8; // Updated next step
        719	        break;
        720	
        721	      case 8: // Summary & Finish
        722	        // Extract JSON from conversation
        723	        preferences = await extractPreferencesFromConversation(context);
        724	
        725	        // Remove the JSON summary from the agent's final response
        726	        stepInstructions = `All set! Ask me anything or explore proposals whenever you're ready.`;
        727	
        728	        completedOnboarding = true;
        729	
        730	        // Update agent preferences with extracted data
        731	        await updateAgentPreferences(agentId, preferences);
        732	        break;
        733	    }
        734	
        735	    // Create prompt for the LLM
        736	    const systemPrompt = ONBOARDING_SYSTEM_PROMPT;
        737	
        738	    const messagesForLlm = [
        739	      {
        740	        role: 'system',
        741	        content: `${systemPrompt}
        742	
        743	        Current onboarding step: ${step}
        744	        ${issuesForMenu ? `Current issues: ${issuesForMenu}` : ''}
        745	
        746	        ${stepInstructions}`
        747	      },
        748	      // Add context from previous messages
        749	      ...context.map(msg => ({
        750	        role: msg.role,
        751	        content: msg.content
        752	      })),
        753	      // Add the new message
        754	      {
        755	        role: 'user',
        756	        content: message
        757	      }
        758	    ];
        759	
        760	    // For step 0 initial greeting, use hardcoded response to ensure consistency
        761	    if (step === 0 && (!message || message.trim().length === 0)) {
        762	      console.log('[Onboarding] Using hardcoded initial greeting for step 0');
        763	      useHardcodedResponse = true;
        764	      agentResponseContent = stepInstructions;
        765	    } else {
        766	      // [DEBUG] LLM prompt and response
        767	      console.log('[Onboarding/FSM] LLM SYSTEM PROMPT:', messagesForLlm[0].content);
        768	      try {
        769	        // Include the balanced issue perspectives template for stance questions
        770	        // Add it at the beginning of the system prompt for stronger influence
        771	        if (step === 2) {
        772	          const balancedPrompt = `${BALANCED_ISSUE_PRESENTATION}\n\n${messagesForLlm[0].content}`;
        773	          messagesForLlm[0].content = balancedPrompt;
        774	          console.log('[Onboarding/FSM] Added balanced perspective template to LLM prompt');
        775	        }
        776	        // Log the full prompt array for diagnosis
        777	        console.log('[Onboarding/FSM] Full prompt array:', JSON.stringify(messagesForLlm, null, 2));
        778	        const { content } = await callLLM(messagesForLlm, DEFAULT_MODEL, { agentId });
        779	        
        780	        // For step 8 (final step), explicitly filter out any JSON from the response
        781	        if (step === 8 || nextStep > 7) {
        782	          // Extract only the non-JSON part from the response by looking for typical phrases
        783	          const standardResponse = "All set! Ask me anything or explore proposals whenever you're ready.";
        784	          
        785	          // More robust JSON detection - look for anything that starts with { and includes typical JSON keys
        786	          const hasJson = /\{[\s\S]*("agentNickname"|"selectedIssues"|"issueStances"|"topPriorityIssue"|"dealBreakers"|"notifyPref")[\s\S]*\}/.test(content);
        787	          
        788	          if (hasJson) {
        789	            console.log('[Onboarding/FSM] JSON detected in final step response, replacing with standard message');
        790	            agentResponseContent = standardResponse;
        791	          } else {
        792	            agentResponseContent = content;
        793	          }
        794	          
        795	          // Force onboarding completion
        796	          completedOnboarding = true;
        797	          console.log('[Onboarding/FSM] Final step detected, marking onboarding as completed');
        798	        } else {
        799	          agentResponseContent = content;
        800	        }
        801	        
        802	        console.log('[Onboarding/FSM] LLM response received:', agentResponseContent.substring(0, 200));
        803	      } catch (llmError) {
        804	        console.error('[Onboarding/FSM] LLM call failed:', llmError);
        805	        // Fallback to step instruction if LLM fails
        806	        agentResponseContent = stepInstructions;
        807	      }
        808	    }
        809	
        810	
        811	    // Only save non-empty user messages
        812	    let savedUserMessage = undefined;
        813	    if (message && message.trim().length > 0) {
        814	      try {
        815	        savedUserMessage = await chatService.default.saveMessage(userId, agentId, message, 'user', {
        816	          isOnboarding: true,
        817	          step
        818	        });
        819	        console.log('[Onboarding] Saved user message:', { id: savedUserMessage?.id });
        820	      } catch (err) {
        821	        console.error('[Onboarding] Failed to save user message:', err);
        822	      }
        823	    }
        824	
        825	    // Make sure we have content before saving agent message
        826	    if (!agentResponseContent) {
        827	      console.log('[Onboarding] No agent response content, using default greeting');
        828	      agentResponseContent = `(1/9) Welcome! I'm your Praxis Agent. Pick a short name for me when we chat.`;
        829	    }
        830	
        831	    // Save agent response
        832	    let savedAgentMessage;
        833	    try {
        834	      savedAgentMessage = await chatService.default.saveMessage(userId, agentId, agentResponseContent, 'agent', {
        835	        isOnboarding: true,
        836	        step,
        837	        nextStep,
        838	        completedOnboarding,
        839	        onboardingComplete: completedOnboarding // Add this redundant field for compatibility
        840	      }, agent.name); // Pass the updated agent name
        841	      console.log('[Onboarding] Saved agent message:', {
        842	        id: savedAgentMessage?.id,
        843	        contentLength: agentResponseContent.length,
        844	        step,
        845	        nextStep
        846	      });
        847	    } catch (err) {
        848	      console.error('[Onboarding] Failed to save agent message:', err);
        849	    }
        850	
        851	    // Mark onboarding complete in DB for the final step or if explicitly marked
        852	    if (completedOnboarding || step === 8 || nextStep >= 8) {
        853	      console.log('[DEBUG-COMPLETION] Marking onboarding as completed for agentId:', agentId,
        854	                 'completedOnboarding flag:', completedOnboarding,
        855	                 'step:', step,
        856	                 'nextStep:', nextStep);
        857	      
        858	      try {
        859	        console.log('[DEBUG-COMPLETION] Before update - agent state:', await prisma.agent.findUnique({
        860	          where: { id: agentId },
        861	          select: { id: true, name: true, onboardingCompleted: true }
        862	        }));
        863	        
        864	        // Use update to ensure the agent record is updated
        865	        const updateResult = await prisma.agent.update({
        866	          where: { id: agentId },
        867	          data: {
        868	            onboardingCompleted: true
        869	          }
        870	        });
        871	        
        872	        console.log('[DEBUG-COMPLETION] Update operation result:', {
        873	          id: updateResult.id,
        874	          onboardingCompleted: updateResult.onboardingCompleted
        875	        });
        876	        
        877	        // Double-check that it was set
        878	        const updatedAgent = await prisma.agent.findUnique({
        879	          where: { id: agentId },
        880	          select: { id: true, name: true, onboardingCompleted: true }
        881	        });
        882	        
        883	        console.log('[DEBUG-COMPLETION] After update - Verified agent state:', updatedAgent);
        884	        
        885	        // If somehow it failed to update, try once more
        886	        if (!updatedAgent?.onboardingCompleted) {
        887	          console.log('[DEBUG-COMPLETION] Onboarding flag not set! Retrying update...');
        888	          const secondAttempt = await prisma.agent.update({
        889	            where: { id: agentId },
        890	            data: { onboardingCompleted: true }
        891	          });
        892	          console.log('[DEBUG-COMPLETION] Second update attempt result:', {
        893	            id: secondAttempt.id,
        894	            onboardingCompleted: secondAttempt.onboardingCompleted
        895	          });
        896	        }
        897	      } catch (err) {
        898	        console.error('[DEBUG-COMPLETION] Error updating onboardingCompleted flag:', err);
        899	        // Dump the full error for diagnosis
        900	        console.error('[DEBUG-COMPLETION] Full error:', JSON.stringify(err, null, 2));
        901	      }
        902	    } else {
        903	      console.log('[DEBUG-COMPLETION] Not marking onboarding complete:', {
        904	        completedOnboarding,
        905	        step,
        906	        nextStep
        907	      });
        908	    }
        909	
        910	    // Return response with updated metadata for next call
        911	    // Fetch latest agent preferences for live matrix updates
        912	    let partialPreferences: Record<string, any> | undefined = undefined;
        913	    let shouldReturnPartial = false;
        914	
        915	    // Return partial preferences after steps 1, 2, 3 (issue selection, stance, priority)
        916	    if (
        917	      step === 1 || // after issue selection
        918	      step === 2 || // after stance update
        919	      step === 3    // after priority selection
        920	    ) {
        921	      try {
        922	        const agentData = await prisma.agent.findUnique({
        923	          where: { id: agentId },
        924	          select: { preferences: true }
        925	        });
        926	        if (agentData && typeof agentData.preferences === 'object') {
        927	          partialPreferences = agentData.preferences as Record<string, any>;
        928	          shouldReturnPartial = true;
        929	          console.log('[Onboarding/FSM] Returning partial extractedPreferences:', JSON.stringify(partialPreferences));
        930	        }
        931	      } catch (err) {
        932	        console.error('[Onboarding/FSM] Failed to fetch partial preferences for live matrix:', err);
        933	      }
        934	    }
        935	
        936	    return {
        937	      response: agentResponseContent,
        938	      nextStep,
        939	      completedOnboarding,
        940	      metadata: {
        941	        step: nextStep,
        942	        selectedIssues,
        943	        issueQueue,
        944	        currentIssueIndex: issueQueue.length > 0 ? currentIssueIndex + 1 : 0
        945	      },
        946	      userMessage: savedUserMessage,
        947	      agentMessage: savedAgentMessage,
        948	      extractedPreferences: completedOnboarding
        949	        ? preferences
        950	        : shouldReturnPartial
        951	          ? partialPreferences
        952	          : undefined,
        953	    };
        954	  } catch (error) {
        955	    console.error('Error during onboarding chat:', error);
        956	    return {
        957	      response: "I'm sorry, I encountered an error during our onboarding conversation. Let's continue.",
        958	      nextStep: metadata?.step ?? 0
        959	    };
        960	  }
        961	}
        962	
        963	// Helper functions for FSM onboarding
        964	function extractIssueNumbers(message: string): string[] {
        965	  // Extract numbers like 1,3,5 or 1, 3, 5 or "1 3 5" from user message
        966	  const numberPattern = /\d+/g;
        967	  const matches = message.match(numberPattern) || [];
        968	  return matches;
        969	}
        970	
        971	async function extractPreferencesFromConversation(context: any[]): Promise<any> {
        972	  // Format conversation for extraction
        973	  const conversationText = context
        974	    .map(msg => `${msg.role}: ${msg.content}`)
        975	    .join('\n');
        976	
        977	  // Call LLM with extraction prompt - make it clear this should NOT be part of the conversation
        978	  const { content } = await callLLM([
        979	    { role: 'system', content: ONBOARDING_PREFERENCE_EXTRACTION_PROMPT + "\nIMPORTANT: This JSON is for internal use only and should NOT be displayed in the chat." },
        980	    { role: 'user', content: conversationText }
        981	  ]);
        982	
        983	  // Parse JSON response (with error handling)
        984	  try {
        985	    return JSON.parse(content);
        986	  } catch (e) {
        987	    console.error('Failed to parse JSON preferences:', e);
        988	    return {};
        989	  }
        990	}
        991	
        992	async function updateAgentPreferences(agentId: string, preferences: any) {
        993	  try {
        994	    const currentPreferences = (await prisma.agent.findUnique({
        995	      where: { id: agentId },
        996	      select: { preferences: true }
        997	    }))?.preferences || {};
        998	
        999	    // Get current agent information to avoid losing existing data
       1000	    const agent = await prisma.agent.findUnique({
       1001	      where: { id: agentId },
       1002	      select: { name: true, color: true }
       1003	    });
       1004	
       1005	    // Merge existing preferences with new ones
       1006	    const mergedPreferences = {
       1007	      ...(typeof currentPreferences === 'object' && currentPreferences !== null ? currentPreferences : {}),
       1008	      ...preferences,
       1009	      onboardingCompletedAt: new Date().toISOString()
       1010	    };
       1011	
       1012	    // [DEBUG] Updating agent preferences
       1013	    console.log('[Onboarding/FSM] Updating agent preferences:', {
       1014	      agentId,
       1015	      newName: preferences.agentNickname || agent?.name || 'Praxis Agent',
       1016	      color: agent?.color || '#4299E1',
       1017	      preferencesKeys: Object.keys(mergedPreferences)
       1018	    });
       1019	
       1020	    // Update agent record
       1021	    await prisma.agent.update({
       1022	      where: { id: agentId },
       1023	      data: {
       1024	        preferences: mergedPreferences as Prisma.InputJsonValue, // Cast to Prisma.InputJsonValue
       1025	        name: preferences.agentNickname || agent?.name || 'Praxis Agent',
       1026	        color: agent?.color || '#4299E1' // Keep existing color or use default
       1027	      }
       1028	    });
       1029	
       1030	    return true;
       1031	  } catch (e) {
       1032	    console.error('Failed to update agent preferences:', e);
       1033	    return false;
       1034	  }
       1035	}
       1036	
       1037	function generateStep4Instruction() {
       1038	  return `(5/9) Of those issues, which ONE matters most to you right now?`;
       1039	}
       1040	
       1041	// Helper function to extract color (moved from case 5)
       1042	function extractColor(message: string): string | null {
       1043	  const colorMatch = message.match(/#?([0-9A-Fa-f]{6}|[A-Fa-f]{3})|\b(red|blue|green|yellow|orange|purple|pink|brown|gray|black|white)\b/i);
       1044	  let extractedColor = null;
       1045	  if (colorMatch) {
       1046	      if (colorMatch[1]) {
       1047	          extractedColor = `#${colorMatch[1]}`; // Hex color
       1048	      } else if (colorMatch[2]) {
       1049	          // Simple mapping for basic color names (can be expanded)
       1050	          const colorMap: { [key: string]: string } = {
       1051	              red: '#F56565', blue: '#4299E1', green: '#48BB78', yellow: '#F6E05E',
       1052	              orange: '#ED8936', purple: '#9F7AEA', pink: '#ED64A6', brown: '#A0522D',
       1053	              gray: '#A0AEC0', black: '#1A202C', white: '#FFFFFF'
       1054	          };
       1055	          extractedColor = colorMap[colorMatch[2].toLowerCase()] || null;
       1056	      }
       1057	  }
       1058	  return extractedColor;
       1059	}
       1060	
       1061	/**
       1062	 * Extract knowledge from a conversation and update the agent's userKnowledge field
       1063	 * @param userId User ID sending the message
       1064	 * @param agentId Agent ID receiving the message
       1065	 * @param userMessage The user's message
       1066	 * @param agentResponse The agent's response
       1067	 * @param agentData The agent's current data
       1068	 */
       1069	async function extractAndUpdateUserKnowledge(
       1070	  userId: string,
       1071	  agentId: string,
       1072	  userMessage: string,
       1073	  agentResponse: string,
       1074	  agentData: {
       1075	    name: string;
       1076	    color: string;
       1077	    preferences: any;
       1078	  }
       1079	): Promise<void> {
       1080	  try {
       1081	    logger.info(`Extracting knowledge from conversation for agent: ${agentId}`);
       1082	    
       1083	    // Format the conversation for the LLM
       1084	    const conversationForExtraction = [
       1085	      { role: 'user', content: userMessage },
       1086	      { role: 'assistant', content: agentResponse },
       1087	    ];
       1088	    
       1089	    // Get current user knowledge from agent record
       1090	    const currentUserKnowledge = (agentData.preferences && typeof agentData.preferences === 'object')
       1091	      ? (agentData.preferences.userKnowledge || {})
       1092	      : {};
       1093	      
       1094	    // Define the knowledge structure if it doesn't exist
       1095	    const knowledgeStructure = {
       1096	      key_topics: Array.isArray(currentUserKnowledge.key_topics) ? currentUserKnowledge.key_topics : [],
       1097	      stated_preferences: Array.isArray(currentUserKnowledge.stated_preferences) ? currentUserKnowledge.stated_preferences : [],
       1098	      goals: Array.isArray(currentUserKnowledge.goals) ? currentUserKnowledge.goals : [],
       1099	      communication_style: currentUserKnowledge.communication_style || 'neutral',
       1100	      relationships: Array.isArray(currentUserKnowledge.relationships) ? currentUserKnowledge.relationships : [],
       1101	      facts: Array.isArray(currentUserKnowledge.facts) ? currentUserKnowledge.facts : []
       1102	    };
       1103	    
       1104	    // Create extraction prompt for the LLM
       1105	    const extractionPrompt = [
       1106	      {
       1107	        role: 'system',
       1108	        content: `Analyze this conversation fragment between a user and their AI agent.
       1109	        Extract any new information about the user, while avoiding redundancy with existing knowledge:
       1110	        
       1111	        EXISTING KNOWLEDGE ABOUT USER:
       1112	        Key Topics: ${knowledgeStructure.key_topics.join(', ')}
       1113	        Stated Preferences: ${knowledgeStructure.stated_preferences.join(', ')}
       1114	        Goals: ${knowledgeStructure.goals.join(', ')}
       1115	        Communication Style: ${knowledgeStructure.communication_style}
       1116	        
       1117	        Return ONLY a JSON object with the following structure, with new information merged with existing knowledge:
       1118	        {
       1119	          "key_topics": ["topic1", "topic2"], // Main subjects user discusses or cares about
       1120	          "stated_preferences": ["pref1", "pref2"], // Explicit preferences user mentioned
       1121	          "goals": ["goal1", "goal2"], // User's stated objectives or desired outcomes
       1122	          "communication_style": "concise|detailed|formal|casual", // User's evident communication preference
       1123	          "relationships": [{"name": "person", "relation": "type", "details": "context"}], // People user mentions
       1124	          "facts": ["fact1", "fact2"] // Factual information about the user
       1125	        }
       1126	        
       1127	        If no new information is found for a field, use the existing values.
       1128	        Keep responses compact and deduplicated, keeping only most relevant items.`
       1129	      },
       1130	      ...conversationForExtraction.map(msg => ({
       1131	        role: msg.role,
       1132	        content: msg.content
       1133	      }))
       1134	    ];
       1135	    
       1136	    // Call LLM to extract knowledge
       1137	    const { content } = await callLLM(extractionPrompt, DEFAULT_MODEL, { agentId });
       1138	    
       1139	    // Parse the response (with error handling)
       1140	    let extractedKnowledge;
       1141	    try {
       1142	      extractedKnowledge = JSON.parse(content);
       1143	      logger.info(`Successfully extracted knowledge for agent ${agentId}`);
       1144	    } catch (e) {
       1145	      logger.error('Failed to parse LLM knowledge extraction response:', e);
       1146	      return; // Exit if we can't parse the response
       1147	    }
       1148	    
       1149	    // Merge with existing knowledge, avoiding duplicates
       1150	    const mergedKnowledge = mergeUserKnowledge(knowledgeStructure, extractedKnowledge);
       1151	    
       1152	    // Update the agent record with the merged knowledge
       1153	    await prisma.agent.update({
       1154	      where: { id: agentId },
       1155	      data: {
       1156	        preferences: {
       1157	          ...(typeof agentData.preferences === 'object' && agentData.preferences !== null ? agentData.preferences : {}),
       1158	          userKnowledge: mergedKnowledge
       1159	        } as Prisma.InputJsonValue
       1160	      }
       1161	    });
       1162	    
       1163	    logger.info(`Updated userKnowledge for agent ${agentId}`);
       1164	  } catch (err: any) {
       1165	    logger.error('Error in extractAndUpdateUserKnowledge:', err);
       1166	  }
       1167	}
       1168	
       1169	/**
       1170	 * Merge existing and new knowledge while avoiding duplicates and keeping the structure clean
       1171	 */
       1172	function mergeUserKnowledge(
       1173	  existing: {
       1174	    key_topics: string[];
       1175	    stated_preferences: string[];
       1176	    goals: string[];
       1177	    communication_style?: string;
       1178	    relationships?: Array<{name: string; relation: string; details?: string}>;
       1179	    facts?: string[];
       1180	  },
       1181	  newKnowledge: any
       1182	): any {
       1183	  // Helper function to merge arrays with deduplication
       1184	  const mergeArrays = (existingArr: string[] = [], newArr: string[] = []): string[] => {
       1185	    const combined = [...existingArr];
       1186	    
       1187	    // Add only new items that don't exist (case-insensitive comparison)
       1188	    for (const item of newArr) {
       1189	      if (!combined.some(existing => existing.toLowerCase() === item.toLowerCase())) {
       1190	        combined.push(item);
       1191	      }
       1192	    }
       1193	    
       1194	    // Limit array size to prevent excessive growth
       1195	    return combined.slice(0, 20);
       1196	  };
       1197	  
       1198	  // Helper function to merge relationship objects
       1199	  const mergeRelationships = (
       1200	    existingRels: Array<{name: string; relation: string; details?: string}> = [],
       1201	    newRels: Array<{name: string; relation: string; details?: string}> = []
       1202	  ) => {
       1203	    const combined = [...existingRels];
       1204	    
       1205	    // Add only new relationships that don't exist
       1206	    for (const newRel of newRels) {
       1207	      if (!combined.some(existing =>
       1208	        existing.name.toLowerCase() === newRel.name.toLowerCase() &&
       1209	        existing.relation.toLowerCase() === newRel.relation.toLowerCase()
       1210	      )) {
       1211	        combined.push(newRel);
       1212	      }
       1213	    }
       1214	    
       1215	    // Limit array size
       1216	    return combined.slice(0, 15);
       1217	  };
       1218	  
       1219	  // Create the merged knowledge object
       1220	  return {
       1221	    key_topics: mergeArrays(existing.key_topics, newKnowledge.key_topics),
       1222	    stated_preferences: mergeArrays(existing.stated_preferences, newKnowledge.stated_preferences),
       1223	    goals: mergeArrays(existing.goals, newKnowledge.goals),
       1224	    communication_style: newKnowledge.communication_style || existing.communication_style || 'neutral',
       1225	    relationships: mergeRelationships(existing.relationships, newKnowledge.relationships),
       1226	    facts: mergeArrays(existing.facts, newKnowledge.facts)
       1227	  };
       1228	}

==============================================
FILE: ./backend/src/services/chat-service.ts
==============================================

          1	/**
          2	 * Chat Service
          3	 * 
          4	 * Handles chat message operations including storage, retrieval,
          5	 * and conversation context management.
          6	 */
          7	import { PrismaClient } from '@prisma/client';
          8	import logger from '../utils/logger';
          9	import { HttpError } from '../utils/HttpError';
         10	
         11	const prisma = new PrismaClient();
         12	
         13	/**
         14	 * Message structure for context management
         15	 */
         16	export interface ChatMessageContext {
         17	  id?: string;
         18	  role: 'user' | 'assistant' | 'system';
         19	  content: string;
         20	  timestamp?: Date;
         21	}
         22	
         23	/**
         24	 * Get conversation context for LLM processing
         25	 * @param agentId Agent ID
         26	 * @param userId User ID
         27	 * @param limit Number of messages to include (default: 20)
         28	 * @param maxTokens Maximum token limit before summarizing older messages (default: 3000)
         29	 * @returns Array of messages in LLM-friendly format
         30	 */
         31	export async function getConversationContext(
         32	  agentId: string,
         33	  userId: string,
         34	  limit: number = 20,
         35	  maxTokens: number = 3000
         36	): Promise<ChatMessageContext[]> {
         37	  try {
         38	    // Fetch recent messages using the type assertion workaround until migration is applied
         39	    const messages = await (prisma as any).chatMessage.findMany({
         40	      where: {
         41	        agentId,
         42	        userId
         43	      },
         44	      orderBy: {
         45	        timestamp: 'desc'
         46	      },
         47	      // Fetch more messages than needed to allow for summarization
         48	      take: Math.min(limit * 2, 100)
         49	    });
         50	
         51	    // Check if we found messages
         52	    if (!messages || messages.length === 0) {
         53	      return [];
         54	    }
         55	
         56	    // Define an interface for the message structure
         57	    interface ChatMessageRecord {
         58	      id: string;
         59	      userId: string;
         60	      agentId: string;
         61	      content: string;
         62	      sender: string;
         63	      timestamp: Date;
         64	      metadata?: any;
         65	    }
         66	
         67	    // Convert to LLM-friendly format and reverse to chronological order
         68	    let context = messages
         69	      .map((msg: ChatMessageRecord) => ({
         70	        id: msg.id,
         71	        role: msg.sender === 'user' ? 'user' : 'assistant',
         72	        content: msg.content,
         73	        timestamp: msg.timestamp
         74	      }))
         75	      .reverse();
         76	      
         77	    // Estimate token count - simple heuristic: ~4 chars per token
         78	    const estimatedTokenCount = context.reduce((count: number, msg: ChatMessageContext) => {
         79	      return count + Math.ceil(msg.content.length / 4);
         80	    }, 0);
         81	    
         82	    logger.info(`Conversation context: ${context.length} messages, ~${estimatedTokenCount} estimated tokens`);
         83	    
         84	    // If we're over the token limit, summarize older messages
         85	    if (estimatedTokenCount > maxTokens && context.length > 5) {
         86	      logger.info(`Context exceeds ${maxTokens} tokens, summarizing older messages`);
         87	      
         88	      // Keep the most recent messages directly
         89	      const recentMessages = context.slice(-Math.min(Math.floor(limit / 2), 10));
         90	      const olderMessages = context.slice(0, -recentMessages.length);
         91	      
         92	      // Summarize older messages
         93	      const summary = await summarizeConversation(olderMessages);
         94	      
         95	      // Create a synthetic summary message to prepend
         96	      const summaryMessage: ChatMessageContext = {
         97	        id: `summary-${Date.now()}`,
         98	        role: 'system',
         99	        content: summary,
        100	        timestamp: new Date()
        101	      };
        102	      
        103	      // Return the summary followed by recent messages
        104	      context = [summaryMessage, ...recentMessages];
        105	      
        106	      logger.info(`Summarized ${olderMessages.length} older messages, returning ${context.length} context items`);
        107	    } else {
        108	      // If we don't need to summarize, just take the most recent messages up to the limit
        109	      context = context.slice(-Math.min(limit, context.length));
        110	    }
        111	
        112	    return context;
        113	  } catch (error) {
        114	    logger.error('Error fetching conversation context:', error);
        115	    throw new HttpError('Failed to retrieve conversation history', 500);
        116	  }
        117	}
        118	
        119	/**
        120	 * Save a chat message to the database
        121	 * @param userId User ID
        122	 * @param agentId Agent ID
        123	 * @param content Message content
        124	 * @param sender 'user' or 'agent'
        125	 * @param metadata Optional metadata
        126	 * @returns Created message
        127	 */
        128	export async function saveMessage(
        129	  userId: string,
        130	  agentId: string,
        131	  content: string,
        132	  sender: 'user' | 'agent',
        133	  metadata: any = {},
        134	  agentName?: string // Add agentName parameter
        135	): Promise<any> {
        136	  try {
        137	    // Type assertion workaround until migration is applied
        138	    const message = await (prisma as any).chatMessage.create({
        139	      data: {
        140	        userId,
        141	        agentId,
        142	        content,
        143	        sender,
        144	        metadata: {
        145	          ...metadata,
        146	          ...(sender === 'agent' && { agentName: agentName || (await prisma.agent.findUnique({ where: { id: agentId }, select: { name: true } }))?.name || 'Agent' }) // Use passed agentName or fetch
        147	        },
        148	        timestamp: new Date()
        149	      }
        150	    });
        151	
        152	    // Update agent's lastInteraction timestamp
        153	    await (prisma as any).agent.update({
        154	      where: { id: agentId },
        155	      data: { lastInteraction: new Date() }
        156	    });
        157	
        158	    return message;
        159	  } catch (error) {
        160	    logger.error('Error saving chat message:', error);
        161	    throw new HttpError('Failed to save message', 500);
        162	  }
        163	}
        164	
        165	/**
        166	 * Get paginated chat history
        167	 * @param agentId Agent ID
        168	 * @param userId User ID
        169	 * @param options Pagination options
        170	 * @returns Paginated messages and cursor info
        171	 */
        172	export async function getChatHistory(
        173	  agentId: string,
        174	  userId: string,
        175	  options: {
        176	    limit?: number;
        177	    before?: string;
        178	    onboarding?: boolean;
        179	  } = {}
        180	): Promise<{
        181	  messages: any[];
        182	  hasMore: boolean;
        183	  nextCursor?: string;
        184	}> {
        185	  const { limit = 50, before, onboarding } = options;
        186	
        187	  try {
        188	    // Build query conditions
        189	    const whereClause: any = {
        190	      userId,
        191	      agentId
        192	    };
        193	
        194	    // Add timestamp condition if 'before' is provided
        195	    if (before) {
        196	      whereClause.timestamp = {
        197	        lt: new Date(before)
        198	      };
        199	    }
        200	
        201	    // Type assertion workaround until migration is applied
        202	    const messages = await (prisma as any).chatMessage.findMany({
        203	      where: whereClause,
        204	      orderBy: {
        205	        timestamp: 'desc'
        206	      },
        207	      take: Number(limit) + 1 // Fetch one extra to check if there are more
        208	    });
        209	
        210	    const hasMore = messages.length > limit;
        211	    const nextCursor = hasMore && messages[limit - 1] 
        212	      ? messages[limit - 1].timestamp.toISOString() 
        213	      : undefined;
        214	
        215	    // Return all but the extra message if we fetched more than the limit
        216	    const messagesToReturn = hasMore ? messages.slice(0, limit) : messages;
        217	
        218	    return {
        219	      messages: messagesToReturn,
        220	      hasMore,
        221	      nextCursor
        222	    };
        223	  } catch (error) {
        224	    logger.error('Error fetching chat history:', error);
        225	    throw new HttpError('Failed to retrieve chat history', 500);
        226	  }
        227	}
        228	
        229	/**
        230	 * Summarize a conversation when context gets too large
        231	 * @param messages Messages to summarize
        232	 * @returns Conversation summary
        233	 */
        234	export async function summarizeConversation(
        235	  messages: ChatMessageContext[]
        236	): Promise<string> {
        237	  try {
        238	    // Import dynamically to avoid circular dependencies
        239	    const agentService = await import('./agent-service');
        240	    
        241	    // Only summarize if we have enough messages
        242	    if (messages.length < 5) {
        243	      return `Recent conversation with ${messages.length} messages.`;
        244	    }
        245	    
        246	    logger.info(`Summarizing ${messages.length} messages for conversation context management`);
        247	    
        248	    // Format the messages for the LLM
        249	    const conversationText = messages
        250	      .map(msg => `${msg.role}: ${msg.content}`)
        251	      .join('\n\n');
        252	    
        253	    // Create a prompt for the LLM to generate a summary
        254	    const summaryPrompt = [
        255	      {
        256	        role: 'system',
        257	        content: `Summarize the following conversation between a user and an AI assistant.
        258	        Focus on key points, user preferences, concerns, and information shared.
        259	        Create a concise but comprehensive summary that captures the important context
        260	        needed to continue the conversation effectively. Include any specific details
        261	        that would be important for providing relevant assistance in follow-up conversations.`
        262	      },
        263	      {
        264	        role: 'user',
        265	        content: conversationText
        266	      }
        267	    ];
        268	    
        269	    // Call the LLM to generate the summary
        270	    const { content } = await agentService.callLLM(summaryPrompt);
        271	    
        272	    // Log the result
        273	    logger.info(`Generated conversation summary of ${content.length} characters`);
        274	    
        275	    return `CONVERSATION SUMMARY: ${content}`;
        276	  } catch (error) {
        277	    logger.error('Error summarizing conversation:', error);
        278	    // Return a basic fallback summary rather than throwing
        279	    return `This conversation contains ${messages.length} messages between the user and their agent.`;
        280	  }
        281	}
        282	
        283	/**
        284	 * Delete a specific message
        285	 * @param messageId Message ID to delete
        286	 * @param userId User ID for authorization check
        287	 * @returns Success status
        288	 */
        289	export async function deleteMessage(
        290	  messageId: string,
        291	  userId: string
        292	): Promise<boolean> {
        293	  try {
        294	    // First check if the message belongs to the user
        295	    const message = await (prisma as any).chatMessage.findFirst({
        296	      where: {
        297	        id: messageId,
        298	        userId
        299	      }
        300	    });
        301	
        302	    if (!message) {
        303	      throw new HttpError('Message not found or does not belong to user', 404);
        304	    }
        305	
        306	    // Delete the message
        307	    await (prisma as any).chatMessage.delete({
        308	      where: {
        309	        id: messageId
        310	      }
        311	    });
        312	
        313	    return true;
        314	  } catch (error) {
        315	    logger.error('Error deleting message:', error);
        316	    if (error instanceof HttpError) {
        317	      throw error;
        318	    }
        319	    throw new HttpError('Failed to delete message', 500);
        320	  }
        321	}
        322	
        323	export default {
        324	  getConversationContext,
        325	  saveMessage,
        326	  getChatHistory,
        327	  summarizeConversation,
        328	  deleteMessage
        329	};

==============================================
FILE: ./backend/src/services/feedback-service.ts
==============================================

          1	import { PrismaClient } from "@prisma/client";
          2	import logger from "../utils/logger";
          3	
          4	const prisma = new PrismaClient();
          5	
          6	interface NegotiationFeedback {
          7	  agentId: string;
          8	  userId: string;
          9	  negotiationId: string;
         10	  rating: number;  // 1-5 scale
         11	  representationAccuracy: number;  // 1-5 scale
         12	  comments?: string;
         13	  preferenceUpdates?: Record<string, any>;
         14	}
         15	
         16	/**
         17	 * Process and store feedback for a negotiation
         18	 * @param feedbackData The feedback data to process
         19	 * @returns The created feedback record ID
         20	 */
         21	export async function processFeedback(
         22	  feedbackData: NegotiationFeedback
         23	): Promise<string> {
         24	  try {
         25	    // Validate input
         26	    if (feedbackData.rating < 1 || feedbackData.rating > 5) {
         27	      throw new Error("Rating must be between 1 and 5");
         28	    }
         29	
         30	    if (feedbackData.representationAccuracy < 1 || feedbackData.representationAccuracy > 5) {
         31	      throw new Error("Representation accuracy must be between 1 and 5");
         32	    }
         33	
         34	    // Check if negotiation exists
         35	    const negotiation = await prisma.negotiationSession.findUnique({
         36	      where: { id: feedbackData.negotiationId }
         37	    });
         38	
         39	    if (!negotiation) {
         40	      throw new Error(`Negotiation session ${feedbackData.negotiationId} not found`);
         41	    }
         42	
         43	    // Check if agent exists and belongs to the user
         44	    const agent = await prisma.agent.findUnique({
         45	      where: { id: feedbackData.agentId },
         46	      include: { user: true }
         47	    });
         48	
         49	    if (!agent) {
         50	      throw new Error(`Agent ${feedbackData.agentId} not found`);
         51	    }
         52	
         53	    if (agent.user.id !== feedbackData.userId) {
         54	      throw new Error(`Agent ${feedbackData.agentId} does not belong to user ${feedbackData.userId}`);
         55	    }
         56	
         57	    // Check if feedback already exists (one feedback per user per negotiation)
         58	    const existingFeedback = await prisma.negotiationFeedback.findFirst({
         59	      where: {
         60	        agentId: feedbackData.agentId,
         61	        negotiationId: feedbackData.negotiationId,
         62	      }
         63	    });
         64	
         65	    if (existingFeedback) {
         66	      // Update existing feedback
         67	      const updatedFeedback = await prisma.negotiationFeedback.update({
         68	        where: { id: existingFeedback.id },
         69	        data: {
         70	          rating: feedbackData.rating,
         71	          representationAccuracy: feedbackData.representationAccuracy,
         72	          comments: feedbackData.comments || existingFeedback.comments,
         73	          updatedAt: new Date(),
         74	        }
         75	      });
         76	
         77	      // Update agent's alignment score and knowledge
         78	      await updateAgentFromFeedback(feedbackData);
         79	
         80	      return updatedFeedback.id;
         81	    } else {
         82	      // Create new feedback
         83	      const feedback = await prisma.negotiationFeedback.create({
         84	        data: {
         85	          negotiationId: feedbackData.negotiationId,
         86	          agentId: feedbackData.agentId,
         87	          userId: feedbackData.userId,
         88	          rating: feedbackData.rating,
         89	          representationAccuracy: feedbackData.representationAccuracy,
         90	          comments: feedbackData.comments || "",
         91	        }
         92	      });
         93	
         94	      // Update agent's alignment score and knowledge
         95	      await updateAgentFromFeedback(feedbackData);
         96	
         97	      return feedback.id;
         98	    }
         99	  } catch (error) {
        100	    logger.error(`Error processing feedback: ${error}`);
        101	    throw error;
        102	  }
        103	}
        104	
        105	/**
        106	 * Update an agent's alignment score and user knowledge based on feedback
        107	 * @param feedbackData The feedback data
        108	 */
        109	export async function updateAgentFromFeedback(
        110	  feedbackData: NegotiationFeedback
        111	): Promise<void> {
        112	  try {
        113	    // Fetch the agent with current alignment score
        114	    const agent = await prisma.agent.findUnique({
        115	      where: { id: feedbackData.agentId },
        116	      select: {
        117	        id: true,
        118	        alignmentScore: true,
        119	        userKnowledge: true
        120	      }
        121	    });
        122	
        123	    if (!agent) {
        124	      throw new Error(`Agent ${feedbackData.agentId} not found`);
        125	    }
        126	
        127	    // Calculate new alignment score - weighted average of current score and new rating
        128	    // Weight factor: current score has 90% weight, new rating has 10% weight (smoothing)
        129	    const currentWeight = 0.9;
        130	    const newWeight = 0.1;
        131	    const newAlignmentScore = 
        132	      (agent.alignmentScore * currentWeight) + 
        133	      ((feedbackData.rating / 5) * newWeight);
        134	
        135	    // Update the agent's user knowledge with feedback insights
        136	    const userKnowledge = agent.userKnowledge as any || {};
        137	    
        138	    // Track feedback history
        139	    if (!userKnowledge.feedbackHistory) {
        140	      userKnowledge.feedbackHistory = [];
        141	    }
        142	    
        143	    userKnowledge.feedbackHistory.push({
        144	      timestamp: new Date(),
        145	      negotiationId: feedbackData.negotiationId,
        146	      rating: feedbackData.rating,
        147	      representationAccuracy: feedbackData.representationAccuracy,
        148	    });
        149	    
        150	    // Keep only the last 10 feedback entries
        151	    if (userKnowledge.feedbackHistory.length > 10) {
        152	      userKnowledge.feedbackHistory = userKnowledge.feedbackHistory.slice(-10);
        153	    }
        154	    
        155	    // Track average feedback metrics
        156	    userKnowledge.averageRating = userKnowledge.feedbackHistory.reduce(
        157	      (sum: number, item: any) => sum + item.rating, 0
        158	    ) / userKnowledge.feedbackHistory.length;
        159	    
        160	    userKnowledge.averageRepresentationAccuracy = userKnowledge.feedbackHistory.reduce(
        161	      (sum: number, item: any) => sum + item.representationAccuracy, 0
        162	    ) / userKnowledge.feedbackHistory.length;
        163	    
        164	    // If preference updates are provided, incorporate them
        165	    if (feedbackData.preferenceUpdates) {
        166	      if (!userKnowledge.preferenceUpdates) {
        167	        userKnowledge.preferenceUpdates = {};
        168	      }
        169	      
        170	      // Merge the updates with existing preference updates
        171	      Object.entries(feedbackData.preferenceUpdates).forEach(([key, value]) => {
        172	        userKnowledge.preferenceUpdates[key] = value;
        173	      });
        174	    }
        175	
        176	    // Update the agent
        177	    await prisma.agent.update({
        178	      where: { id: feedbackData.agentId },
        179	      data: {
        180	        alignmentScore: newAlignmentScore,
        181	        userKnowledge: userKnowledge as any
        182	      }
        183	    });
        184	
        185	  } catch (error) {
        186	    logger.error(`Error updating agent from feedback: ${error}`);
        187	    // We don't want to fail the entire feedback process if the agent update fails
        188	    // So we log the error but don't rethrow it
        189	  }
        190	}
        191	
        192	/**
        193	 * Get feedback for a negotiation
        194	 * @param negotiationId The negotiation ID
        195	 * @param agentId Optional agent ID to filter by
        196	 * @param userId Optional user ID to filter by
        197	 */
        198	export async function getFeedback(
        199	  negotiationId: string,
        200	  agentId?: string,
        201	  userId?: string
        202	): Promise<any[]> {
        203	  const whereClause: any = { negotiationId };
        204	  
        205	  if (agentId) {
        206	    whereClause.agentId = agentId;
        207	  }
        208	  
        209	  if (userId) {
        210	    whereClause.userId = userId;
        211	  }
        212	  
        213	  return prisma.negotiationFeedback.findMany({
        214	    where: whereClause,
        215	    orderBy: { createdAt: 'desc' }
        216	  });
        217	}

==============================================
FILE: ./backend/src/services/key-service.ts
==============================================

          1	import * as ed from '@noble/ed25519';
          2	import crypto from 'crypto';
          3	
          4	const algorithm = 'aes-256-gcm';
          5	
          6	export async function generateKeyPair() {
          7	  const privateKey = ed.utils.randomPrivateKey();
          8	  const publicKey = await ed.getPublicKey(privateKey);
          9	  return { privateKey, publicKey };
         10	}
         11	
         12	export function encryptPrivateKey(privateKey: Uint8Array): string {
         13	  const key = crypto.createHash('sha256').update(process.env.JWT_SECRET!).digest();
         14	  const iv = crypto.randomBytes(12);
         15	  const cipher = crypto.createCipheriv(algorithm, key, iv);
         16	  const encrypted = Buffer.concat([cipher.update(Buffer.from(privateKey)), cipher.final()]);
         17	  const tag = cipher.getAuthTag();
         18	  return Buffer.concat([iv, tag, encrypted]).toString('base64');
         19	}
         20	
         21	export function decryptPrivateKey(encrypted: string): Uint8Array {
         22	  const data = Buffer.from(encrypted, 'base64');
         23	  const iv = data.slice(0, 12);
         24	  const tag = data.slice(12, 28);
         25	  const ciphertext = data.slice(28);
         26	  const key = crypto.createHash('sha256').update(process.env.JWT_SECRET!).digest();
         27	  const decipher = crypto.createDecipheriv(algorithm, key, iv);
         28	  decipher.setAuthTag(tag);
         29	  const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
         30	  return new Uint8Array(decrypted);
         31	}


==============================================
FILE: ./backend/src/services/llm-logging-service.ts
==============================================

          1	import { PrismaClient } from '@prisma/client';
          2	
          3	const prisma = new PrismaClient();
          4	
          5	interface LlmLogData {
          6	  agentId?: string;
          7	  model: string;
          8	  inputTokens: number;
          9	  outputTokens: number;
         10	  latencyMs: number;
         11	  outcome: 'success' | 'error';
         12	  errorMessage?: string;
         13	}
         14	
         15	/**
         16	 * Logs LLM usage details to the database.
         17	 * @param data - The LLM usage data to log.
         18	 */
         19	export async function logLlmUsage(data: LlmLogData): Promise<void> {
         20	  try {
         21	    await prisma.llmUsageLog.create({
         22	      data: {
         23	        agentId: data.agentId,
         24	        model: data.model,
         25	        inputTokens: data.inputTokens,
         26	        outputTokens: data.outputTokens,
         27	        latencyMs: data.latencyMs,
         28	        outcome: data.outcome,
         29	        errorMessage: data.errorMessage,
         30	      },
         31	    });
         32	    console.log('LLM usage logged successfully.'); // Basic console log for confirmation
         33	  } catch (error) {
         34	    console.error('Failed to log LLM usage:', error);
         35	    // Depending on requirements, might re-throw or handle differently
         36	  }
         37	}
         38	
         39	// Example usage (for demonstration purposes, remove later)
         40	/*
         41	logLlmUsage({
         42	  agentId: 'some-agent-uuid',
         43	  model: 'openai/gpt-4o',
         44	  inputTokens: 500,
         45	  outputTokens: 150,
         46	  latencyMs: 1234,
         47	  outcome: 'success',
         48	});
         49	
         50	logLlmUsage({
         51	  model: 'anthropic/claude-3-opus', // System action, no agentId
         52	  inputTokens: 100,
         53	  outputTokens: 0,
         54	  latencyMs: 500,
         55	  outcome: 'error',
         56	  errorMessage: 'API connection failed',
         57	});
         58	*/

==============================================
FILE: ./backend/src/services/llm-service.ts
==============================================

          1	import OpenAI from "openai";
          2	
          3	type Message = { role: "system" | "user" | "assistant"; content: string };
          4	
          5	const openai = new OpenAI({
          6	  baseURL: "https://openrouter.ai/api/v1",
          7	  apiKey: process.env.OPENROUTER_API_KEY,
          8	  defaultHeaders: {
          9	    "HTTP-Referer": process.env.OPENROUTER_REFERER || "http://localhost:5173",
         10	    "X-Title": process.env.OPENROUTER_TITLE || "NDNE Prototype",
         11	  },
         12	});
         13	
         14	export async function callOpenRouterLLM({
         15	  prompt,
         16	  contextMessages = [],
         17	  model = "openai/gpt-4.1",
         18	  temperature = 0.7,
         19	  maxTokens = 256,
         20	}: {
         21	  prompt: string;
         22	  contextMessages?: Message[];
         23	  model?: string;
         24	  temperature?: number;
         25	  maxTokens?: number;
         26	}): Promise<string> {
         27	  const messages: Message[] = [
         28	    ...(contextMessages || []),
         29	    { role: "user", content: prompt },
         30	  ];
         31	
         32	  const completion = await openai.chat.completions.create({
         33	    model,
         34	    messages,
         35	    temperature,
         36	    max_tokens: maxTokens,
         37	  });
         38	
         39	  const reply = completion.choices?.[0]?.message?.content;
         40	  if (!reply) throw new Error("No response from OpenRouter LLM");
         41	  return reply.trim();
         42	}

==============================================
FILE: ./backend/src/services/negotiation-service.ts
==============================================

          1	import { PrismaClient } from "@prisma/client";
          2	import { callOpenRouterLLM } from "./llm-service";
          3	import { generateNegotiationStance } from "./stance-generator";
          4	import { CONSENSUS_CHECKING_PROMPT } from "./prompt-templates/negotiation-prompts";
          5	import { logLlmUsage } from "./llm-logging-service";
          6	import logger from "../utils/logger";
          7	
          8	const prisma = new PrismaClient();
          9	
         10	/**
         11	 * Enum representing the different stages of a negotiation.
         12	 */
         13	export enum NegotiationStage {
         14	  PERSPECTIVE_PASS = "PERSPECTIVE_PASS",
         15	  OPTION_GENERATION = "OPTION_GENERATION",
         16	  CONSENSUS_CHECK = "CONSENSUS_CHECK",
         17	  COMPLETED = "COMPLETED",
         18	  ABANDONED = "ABANDONED",
         19	}
         20	
         21	/**
         22	 * Start a new negotiation session.
         23	 */
         24	export async function startNegotiation(
         25	  topic: string,
         26	  initiatorId: string,
         27	  description?: string
         28	): Promise<string> {
         29	  // Create a new negotiation session
         30	  const session = await prisma.negotiationSession.create({
         31	    data: {
         32	      topic,
         33	      description,
         34	      initiatorId,
         35	      status: "active",
         36	    },
         37	  });
         38	
         39	  logger.info(`Started new negotiation: ${session.id} on topic: ${topic}`);
         40	  
         41	  return session.id;
         42	}
         43	
         44	/**
         45	 * Process a new negotiation message and determine next steps.
         46	 */
         47	export async function processNegotiationMessage(
         48	  negotiationId: string,
         49	  messageData: {
         50	    agentId: string;
         51	    content: string;
         52	    messageType?: string;
         53	    referencedMessageId?: string;
         54	    metadata?: any;
         55	  }
         56	): Promise<{
         57	  message: any;
         58	  autoResponses: any[];
         59	  consensusReached: boolean;
         60	}> {
         61	  // Store the incoming message
         62	  const message = await prisma.negotiationMessage.create({
         63	    data: {
         64	      negotiationId,
         65	      agentId: messageData.agentId,
         66	      content: messageData.content,
         67	      messageType: messageData.messageType || "statement",
         68	      referencedMessageId: messageData.referencedMessageId,
         69	      metadata: messageData.metadata,
         70	    },
         71	    include: {
         72	      reactions: true,
         73	    }
         74	  });
         75	
         76	  // Get the current negotiation session
         77	  const session = await prisma.negotiationSession.findUnique({
         78	    where: { id: negotiationId }
         79	  });
         80	
         81	  if (!session) {
         82	    throw new Error(`Negotiation session ${negotiationId} not found`);
         83	  }
         84	
         85	  // Check if negotiation is already completed
         86	  if (session.status !== "active") {
         87	    return {
         88	      message,
         89	      autoResponses: [],
         90	      consensusReached: session.status === "completed"
         91	    };
         92	  }
         93	
         94	  // Determine the current stage of the negotiation
         95	  const currentStage = await determineNegotiationStage(negotiationId);
         96	  
         97	  // Get participating agents 
         98	  // (agents who have posted at least one message, including the current one)
         99	  const participatingAgents = await prisma.negotiationMessage.findMany({
        100	    where: { negotiationId },
        101	    select: { agentId: true },
        102	    distinct: ['agentId']
        103	  });
        104	  
        105	  const agentIds = participatingAgents.map(a => a.agentId);
        106	  
        107	  // Identify which agent(s) should respond next
        108	  const nextAgentIds = await determineNextRespondents(
        109	    negotiationId, 
        110	    messageData.agentId, 
        111	    agentIds, 
        112	    currentStage
        113	  );
        114	  
        115	  // Generate auto-responses from the next agents
        116	  const autoResponses = [];
        117	  for (const nextAgentId of nextAgentIds) {
        118	    try {
        119	      const responseMessage = await generateAgentResponse(
        120	        negotiationId, 
        121	        nextAgentId, 
        122	        currentStage
        123	      );
        124	      
        125	      autoResponses.push(responseMessage);
        126	    } catch (error) {
        127	      logger.error(`Failed to generate agent ${nextAgentId} response: ${error}`);
        128	    }
        129	  }
        130	  
        131	  // Check for consensus after new messages
        132	  const consensusResult = await detectConsensus(negotiationId);
        133	  
        134	  if (consensusResult.consensusReached) {
        135	    await finalizeNegotiation(negotiationId, {
        136	      status: "completed",
        137	      outcome: consensusResult.terms,
        138	      summary: consensusResult.summary
        139	    });
        140	  } else if (consensusResult.nearMiss) {
        141	    // Handle near-miss case (70-74% agreement)
        142	    logger.info(`Near miss detected in negotiation ${negotiationId}, triggering Round 2`);
        143	    
        144	    // Add a system message indicating Round 2
        145	    await prisma.negotiationMessage.create({
        146	      data: {
        147	        negotiationId,
        148	        agentId: session.initiatorId, // Use initiator as the "system" for this message
        149	        content: "ROUND-2: Consensus nearly reached (70-74% agreement). Continuing negotiation for further refinement.",
        150	        messageType: "system",
        151	      }
        152	    });
        153	  }
        154	  
        155	  return {
        156	    message,
        157	    autoResponses,
        158	    consensusReached: consensusResult.consensusReached
        159	  };
        160	}
        161	
        162	/**
        163	 * Determine the current stage of a negotiation based on message history.
        164	 */
        165	async function determineNegotiationStage(negotiationId: string): Promise<NegotiationStage> {
        166	  // Get the negotiation session
        167	  const session = await prisma.negotiationSession.findUnique({
        168	    where: { id: negotiationId },
        169	  });
        170	
        171	  if (!session) {
        172	    throw new Error(`Negotiation session ${negotiationId} not found`);
        173	  }
        174	
        175	  // If the session has a status other than "active", map it to the corresponding stage
        176	  if (session.status === "completed") {
        177	    return NegotiationStage.COMPLETED;
        178	  } else if (session.status === "abandoned") {
        179	    return NegotiationStage.ABANDONED;
        180	  }
        181	
        182	  // Count the total messages in this negotiation
        183	  const messageCount = await prisma.negotiationMessage.count({
        184	    where: { negotiationId }
        185	  });
        186	
        187	  // Check if this is a brand new negotiation or still in early stages
        188	  if (messageCount <= 3) {
        189	    return NegotiationStage.PERSPECTIVE_PASS;
        190	  } 
        191	  
        192	  // After initial perspective sharing, move to option generation
        193	  if (messageCount <= 10) {
        194	    return NegotiationStage.OPTION_GENERATION;
        195	  }
        196	  
        197	  // After several messages, start checking for consensus
        198	  return NegotiationStage.CONSENSUS_CHECK;
        199	}
        200	
        201	/**
        202	 * Determine which agents should respond next in the negotiation.
        203	 */
        204	async function determineNextRespondents(
        205	  negotiationId: string, 
        206	  currentAgentId: string,
        207	  participatingAgentIds: string[],
        208	  currentStage: NegotiationStage
        209	): Promise<string[]> {
        210	  // Filter out the current agent
        211	  const otherAgentIds = participatingAgentIds.filter(id => id !== currentAgentId);
        212	  
        213	  if (otherAgentIds.length === 0) {
        214	    return []; // No other agents to respond
        215	  }
        216	  
        217	  if (currentStage === NegotiationStage.PERSPECTIVE_PASS) {
        218	    // In perspective pass, only one agent responds at a time
        219	    const nextAgentIndex = Math.floor(Math.random() * otherAgentIds.length);
        220	    return [otherAgentIds[nextAgentIndex]];
        221	  } 
        222	  
        223	  // In other stages, we could have multiple agents respond,
        224	  // but for simplicity and to avoid too many auto-responses at once,
        225	  // we'll pick 1-2 agents
        226	  
        227	  // Select 1-2 agents randomly, but never more than available
        228	  const count = Math.min(
        229	    Math.floor(Math.random() * 2) + 1, 
        230	    otherAgentIds.length
        231	  );
        232	  
        233	  // Shuffle the array and take the first 'count' elements
        234	  return otherAgentIds
        235	    .sort(() => Math.random() - 0.5)
        236	    .slice(0, count);
        237	}
        238	
        239	/**
        240	 * Generate a message response from an agent in the negotiation.
        241	 */
        242	async function generateAgentResponse(
        243	  negotiationId: string, 
        244	  agentId: string, 
        245	  currentStage: NegotiationStage
        246	): Promise<any> {
        247	  // Get the negotiation context
        248	  const session = await prisma.negotiationSession.findUnique({
        249	    where: { id: negotiationId }
        250	  });
        251	
        252	  if (!session) {
        253	    throw new Error(`Negotiation session ${negotiationId} not found`);
        254	  }
        255	
        256	  // Get recent messages for context
        257	  const recentMessages = await prisma.negotiationMessage.findMany({
        258	    where: { negotiationId },
        259	    orderBy: { timestamp: 'desc' },
        260	    take: 10,
        261	    include: { agent: true }
        262	  });
        263	  
        264	  // Reverse to get chronological order
        265	  const chronologicalMessages = [...recentMessages].reverse();
        266	  
        267	  // Get the agent's stance on this topic
        268	  const stance = await generateNegotiationStance(agentId, session.topic);
        269	  
        270	  // Format the message history for the prompt
        271	  const messageHistory = chronologicalMessages.map(msg => 
        272	    `${msg.agent.name || 'Agent' + msg.agentId.substring(0,4)}: ${msg.content}`
        273	  ).join('\n\n');
        274	  
        275	  // Create the prompt based on the current stage
        276	  let prompt = '';
        277	  switch (currentStage) {
        278	    case NegotiationStage.PERSPECTIVE_PASS:
        279	      prompt = `
        280	You are a PRAXIS AGENT participating in a negotiation about "${session.topic}".
        281	You should respond to the perspectives shared so far, and share your own perspective based on your stance.
        282	Focus on understanding before proposing solutions.
        283	
        284	Your stance:
        285	${JSON.stringify(stance, null, 2)}
        286	
        287	Recent messages:
        288	${messageHistory}
        289	
        290	Respond with your perspective on this issue. Begin your message with "PERSPECTIVE_PASS:" to show you're sharing your initial understanding of the situation.
        291	Keep your response concise (2-4 paragraphs maximum).
        292	`;
        293	      break;
        294	    
        295	    case NegotiationStage.OPTION_GENERATION:
        296	      prompt = `
        297	You are a PRAXIS AGENT participating in a negotiation about "${session.topic}".
        298	It's time to propose constructive options that address the interests shared so far.
        299	
        300	Your stance:
        301	${JSON.stringify(stance, null, 2)}
        302	
        303	Recent messages:
        304	${messageHistory}
        305	
        306	Propose 1-2 specific options that advance your interests while addressing others' concerns.
        307	Use OPT-A and OPT-B tags to clearly mark your proposals.
        308	Explain briefly why you think each option is viable and addresses key concerns.
        309	`;
        310	      break;
        311	    
        312	    case NegotiationStage.CONSENSUS_CHECK:
        313	      prompt = `
        314	You are a PRAXIS AGENT participating in a negotiation about "${session.topic}".
        315	The discussion has progressed and it's time to work toward consensus.
        316	
        317	Your stance:
        318	${JSON.stringify(stance, null, 2)}
        319	
        320	Recent messages:
        321	${messageHistory}
        322	
        323	Evaluate the options discussed so far. If there's an option you can agree to, respond with "CONSENT:YES" and explain your reasoning.
        324	If you cannot consent yet, respond with "CONSENT:NO" and clearly explain what would need to change to gain your consent.
        325	Do not consent to proposals that clearly violate your stance's deal breakers.
        326	`;
        327	      break;
        328	    
        329	    default:
        330	      prompt = `
        331	You are a PRAXIS AGENT participating in a negotiation about "${session.topic}".
        332	
        333	Your stance:
        334	${JSON.stringify(stance, null, 2)}
        335	
        336	Recent messages:
        337	${messageHistory}
        338	
        339	Continue the negotiation constructively. Focus on finding solutions that work for everyone while respecting your stance.
        340	`;
        341	  }
        342	  
        343	  // Call the LLM to generate the response
        344	  try {
        345	    const systemPrompt = "You are a professional negotiation agent representing human interests in a multi-party discussion. Be concise, constructive and clear.";
        346	    const agentResponse = await callOpenRouterLLM({
        347	      prompt,
        348	      contextMessages: [{ role: "system", content: systemPrompt }],
        349	      temperature: 0.7,
        350	      maxTokens: 800,
        351	    });
        352	    
        353	    // Store and return the generated message
        354	    const responseMessage = await prisma.negotiationMessage.create({
        355	      data: {
        356	        negotiationId,
        357	        agentId,
        358	        content: agentResponse,
        359	        messageType: determineMessageType(agentResponse, currentStage),
        360	      },
        361	      include: {
        362	        reactions: true,
        363	      }
        364	    });
        365	    
        366	    return responseMessage;
        367	  } catch (error) {
        368	    logger.error(`Error generating agent response: ${error}`);
        369	    throw error;
        370	  }
        371	}
        372	
        373	/**
        374	 * Determine the message type based on content and stage
        375	 */
        376	function determineMessageType(content: string, stage: NegotiationStage): string {
        377	  if (content.includes("CONSENT:YES")) {
        378	    return "agreement";
        379	  } else if (content.includes("CONSENT:NO")) {
        380	    return "disagreement";
        381	  } else if (content.includes("OPT-A") || content.includes("OPT-B")) {
        382	    return "proposal";
        383	  } else if (content.includes("?") && content.split("?").length > 2) {
        384	    return "question";
        385	  } else {
        386	    return "statement";
        387	  }
        388	}
        389	
        390	/**
        391	 * Detect if consensus has been reached in a negotiation.
        392	 */
        393	export async function detectConsensus(negotiationId: string): Promise<{
        394	  consensusReached: boolean;
        395	  nearMiss: boolean;
        396	  terms?: string;
        397	  summary?: string;
        398	}> {
        399	  // Get the negotiation session
        400	  const session = await prisma.negotiationSession.findUnique({
        401	    where: { id: negotiationId },
        402	  });
        403	
        404	  if (!session) {
        405	    throw new Error(`Negotiation session ${negotiationId} not found`);
        406	  }
        407	
        408	  // If it's not an active session, we can't reach new consensus
        409	  if (session.status !== "active") {
        410	    return { 
        411	      consensusReached: session.status === "completed",
        412	      nearMiss: false
        413	    };
        414	  }
        415	
        416	  // Get all messages in this negotiation
        417	  const messages = await prisma.negotiationMessage.findMany({
        418	    where: { negotiationId },
        419	    orderBy: { timestamp: 'asc' },
        420	    include: {
        421	      agent: true,
        422	      reactions: true
        423	    }
        424	  });
        425	
        426	  // If there are too few messages, there can't be consensus yet
        427	  if (messages.length < 5) {
        428	    return { consensusReached: false, nearMiss: false };
        429	  }
        430	
        431	  // Format message history for LLM prompt
        432	  const messageHistory = messages.map(msg => {
        433	    const reactionInfo = msg.reactions.length > 0 
        434	      ? ` [Reactions: ${msg.reactions.map(r => r.reactionType).join(', ')}]`
        435	      : '';
        436	    return `${msg.agent.name || 'Agent ' + msg.agentId.substring(0,4)}: ${msg.content}${reactionInfo}`;
        437	  }).join('\n\n');
        438	
        439	  // Call LLM to check for consensus
        440	  try {
        441	    const consensusCheck = await callOpenRouterLLM({
        442	      prompt: CONSENSUS_CHECKING_PROMPT(messageHistory),
        443	      contextMessages: [
        444	        { role: "system", content: "You are a neutral evaluator determining if multiple negotiating parties have reached consensus." }
        445	      ],
        446	      temperature: 0.2, // Lower temperature for more objective analysis
        447	      maxTokens: 1000,
        448	    });
        449	
        450	    // Parse the LLM response to determine consensus
        451	    const consensusReached = consensusCheck.toLowerCase().includes("consensus has been reached") ||
        452	                            consensusCheck.toLowerCase().includes("consensus reached") ||
        453	                            consensusCheck.toLowerCase().includes("agreement has been reached");
        454	                            
        455	    const nearMiss = consensusCheck.toLowerCase().includes("near-miss") ||
        456	                    consensusCheck.toLowerCase().includes("70-74%") ||
        457	                    (consensusCheck.toLowerCase().includes("consensus is close") && !consensusReached);
        458	
        459	    // Extract terms and summary if consensus was reached
        460	    let terms = "";
        461	    let summary = "";
        462	    if (consensusReached) {
        463	      // Try to extract terms from a FinalConsensusBlock if present
        464	      const termsMatch = consensusCheck.match(/terms:(.*?)(?=signatories:|decisionClass:|consensusRatio:|sunsetDate:|$)/is);
        465	      terms = termsMatch ? termsMatch[1].trim() : "";
        466	      
        467	      // Use the whole response as a summary if no specific terms were extracted
        468	      summary = terms || consensusCheck;
        469	    }
        470	
        471	    return {
        472	      consensusReached,
        473	      nearMiss,
        474	      terms,
        475	      summary
        476	    };
        477	  } catch (error) {
        478	    logger.error(`Error detecting consensus: ${error}`);
        479	    return {
        480	      consensusReached: false,
        481	      nearMiss: false
        482	    };
        483	  }
        484	}
        485	
        486	/**
        487	 * Finalize a negotiation session with an outcome.
        488	 */
        489	export async function finalizeNegotiation(
        490	  negotiationId: string,
        491	  outcome: {
        492	    status: string;
        493	    outcome?: string;
        494	    summary?: string;
        495	  }
        496	): Promise<string> {
        497	  // Update the negotiation session
        498	  const updatedSession = await prisma.negotiationSession.update({
        499	    where: { id: negotiationId },
        500	    data: {
        501	      status: outcome.status,
        502	      completedAt: new Date(),
        503	    }
        504	  });
        505	
        506	  // If there's a consensus outcome, create a proposal from this negotiation
        507	  if (outcome.status === "completed" && outcome.summary) {
        508	    try {
        509	      // Get the initiator agent for creating the proposal
        510	      const initiatorId = updatedSession.initiatorId;
        511	      
        512	      // Create a proposal linked to this negotiation
        513	      await prisma.proposal.create({
        514	        data: {
        515	          title: `Negotiated: ${updatedSession.topic}`,
        516	          description: outcome.summary,
        517	          createdByAgentId: initiatorId,
        518	          negotiationId: negotiationId,
        519	          isNegotiated: true,
        520	          negotiationSummary: outcome.summary,
        521	          quorum: 1, // Minimal quorum since agents already consented in negotiation
        522	          closeAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days from now
        523	          vetoWindowEnd: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000), // 3 days from now
        524	          status: "open"
        525	        }
        526	      });
        527	      
        528	      logger.info(`Created proposal from negotiation ${negotiationId}`);
        529	    } catch (error) {
        530	      logger.error(`Failed to create proposal from negotiation: ${error}`);
        531	    }
        532	  }
        533	
        534	  return negotiationId;
        535	}
        536	
        537	/**
        538	 * Add a reaction to a negotiation message.
        539	 */
        540	export async function addReaction(
        541	  messageId: string, 
        542	  agentId: string, 
        543	  reactionType: string
        544	): Promise<any> {
        545	  try {
        546	    // Check if the reaction already exists
        547	    const existingReaction = await prisma.negotiationReaction.findFirst({
        548	      where: {
        549	        messageId,
        550	        agentId,
        551	        reactionType
        552	      }
        553	    });
        554	
        555	    if (existingReaction) {
        556	      return existingReaction;
        557	    }
        558	
        559	    // Create the new reaction
        560	    const reaction = await prisma.negotiationReaction.create({
        561	      data: {
        562	        messageId,
        563	        agentId,
        564	        reactionType
        565	      }
        566	    });
        567	
        568	    return reaction;
        569	  } catch (error) {
        570	    logger.error(`Error adding reaction: ${error}`);
        571	    throw error;
        572	  }
        573	}
        574	
        575	/**
        576	 * Remove a reaction from a negotiation message.
        577	 */
        578	export async function removeReaction(
        579	  messageId: string, 
        580	  agentId: string, 
        581	  reactionType: string
        582	): Promise<void> {
        583	  try {
        584	    // Delete the reaction if it exists
        585	    await prisma.negotiationReaction.deleteMany({
        586	      where: {
        587	        messageId,
        588	        agentId,
        589	        reactionType
        590	      }
        591	    });
        592	  } catch (error) {
        593	    logger.error(`Error removing reaction: ${error}`);
        594	    throw error;
        595	  }
        596	}

==============================================
FILE: ./backend/src/services/negotiation-to-proposal.ts
==============================================

          1	import { PrismaClient } from "@prisma/client";
          2	import { callOpenRouterLLM } from "./llm-service";
          3	import { logLlmUsage } from "./llm-logging-service";
          4	import logger from "../utils/logger";
          5	import { detectConsensus } from "./negotiation-service";
          6	
          7	const prisma = new PrismaClient();
          8	
          9	/**
         10	 * Creates a formal proposal from a completed negotiation with consensus
         11	 * @param negotiationId ID of the negotiation session to convert
         12	 * @param options Optional parameters like title override
         13	 * @returns ID of the created proposal
         14	 */
         15	export async function createProposalFromNegotiation(
         16	  negotiationId: string,
         17	  options?: {
         18	    title?: string;
         19	    autoCreate?: boolean;
         20	  }
         21	): Promise<{
         22	  proposalId: string;
         23	  proposalTitle: string;
         24	  proposalDescription: string;
         25	  status: string;
         26	}> {
         27	  try {
         28	    // Fetch the negotiation session with messages
         29	    const negotiation = await prisma.negotiationSession.findUnique({
         30	      where: { id: negotiationId },
         31	      include: {
         32	        messages: {
         33	          orderBy: { timestamp: "asc" },
         34	          include: {
         35	            agent: true,
         36	            reactions: true
         37	          }
         38	        }
         39	      }
         40	    });
         41	
         42	    if (!negotiation) {
         43	      throw new Error(`Negotiation session ${negotiationId} not found`);
         44	    }
         45	
         46	    // Check if the negotiation has completed and reached consensus
         47	    if (negotiation.status !== "completed" && !options?.autoCreate) {
         48	      const consensusResult = await detectConsensus(negotiationId);
         49	      
         50	      if (!consensusResult.consensusReached) {
         51	        throw new Error("Negotiation has not reached consensus yet and cannot be converted to a proposal");
         52	      }
         53	    }
         54	
         55	    // Check if a proposal already exists for this negotiation
         56	    const existingProposal = await prisma.proposal.findUnique({
         57	      where: { negotiationId }
         58	    });
         59	
         60	    if (existingProposal) {
         61	      return {
         62	        proposalId: existingProposal.id,
         63	        proposalTitle: existingProposal.title,
         64	        proposalDescription: existingProposal.description,
         65	        status: "existing"
         66	      };
         67	    }
         68	
         69	    // Format negotiation messages for the LLM
         70	    const messageHistory = negotiation.messages.map(msg => {
         71	      const reactionInfo = msg.reactions.length > 0 
         72	        ? ` [Reactions: ${msg.reactions.map(r => r.reactionType).join(', ')}]`
         73	        : '';
         74	      return `${msg.agent.name || 'Agent ' + msg.agentId.substring(0,4)}: ${msg.content}${reactionInfo}`;
         75	    }).join('\n\n');
         76	
         77	    // Generate proposal title and description using LLM
         78	    const proposalContent = await generateProposalContent(
         79	      negotiation.topic,
         80	      messageHistory,
         81	      options?.title
         82	    );
         83	
         84	    // Extract any monetary amounts if present in the negotiation
         85	    const monetaryMatch = messageHistory.match(/\$([\d,]+(\.\d{1,2})?)/);
         86	    const amount = monetaryMatch ? parseFloat(monetaryMatch[1].replace(/,/g, '')) : null;
         87	    
         88	    // Create the proposal
         89	    const proposal = await prisma.proposal.create({
         90	      data: {
         91	        title: proposalContent.title,
         92	        description: proposalContent.description,
         93	        negotiationId: negotiationId,
         94	        isNegotiated: true,
         95	        negotiationSummary: proposalContent.summary,
         96	        createdByAgentId: negotiation.initiatorId,
         97	        // Set appropriate proposal parameters
         98	        type: amount ? "monetary" : "standard",
         99	        amount: amount,
        100	        playMode: false,
        101	        status: "open",
        102	        quorum: Math.max(1, Math.ceil(negotiation.messages.filter(m => m.messageType === "agreement").length / 2)),
        103	        threshold: 0.5,
        104	        closeAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days from now
        105	        vetoWindowEnd: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000) // 3 days from now
        106	      }
        107	    });
        108	
        109	    logger.info(`Created proposal ${proposal.id} from negotiation ${negotiationId}`);
        110	
        111	    // If the negotiation wasn't already completed, mark it as completed
        112	    if (negotiation.status !== "completed") {
        113	      await prisma.negotiationSession.update({
        114	        where: { id: negotiationId },
        115	        data: {
        116	          status: "completed",
        117	          completedAt: new Date()
        118	        }
        119	      });
        120	    }
        121	
        122	    return {
        123	      proposalId: proposal.id,
        124	      proposalTitle: proposal.title,
        125	      proposalDescription: proposal.description,
        126	      status: "created"
        127	    };
        128	  } catch (error) {
        129	    logger.error(`Failed to create proposal from negotiation: ${error}`);
        130	    throw error;
        131	  }
        132	}
        133	
        134	/**
        135	 * Generate proposal title, description, and summary from negotiation history
        136	 */
        137	async function generateProposalContent(
        138	  topic: string,
        139	  negotiationHistory: string,
        140	  titleOverride?: string
        141	): Promise<{
        142	  title: string;
        143	  description: string;
        144	  summary: string;
        145	}> {
        146	  try {
        147	    // Create a system prompt for LLM
        148	    const systemPrompt = `You are a governance summarization expert tasked with converting agent-to-agent negotiations into formal proposals.`;
        149	    
        150	    // Create the prompt for generating proposal content
        151	    const prompt = `
        152	Based on the following negotiation about "${topic}", create a formal proposal.
        153	
        154	The negotiation history:
        155	${negotiationHistory}
        156	
        157	Extract the key points of consensus and generate:
        158	1. A concise, descriptive title (10 words or less) that clearly represents the proposal
        159	2. A formal proposal description (2-4 paragraphs) that includes:
        160	   - The problem or opportunity being addressed
        161	   - The proposed solution with specific details
        162	   - Any key constraints or conditions
        163	   - Expected benefits or outcomes
        164	3. A brief summary (1 paragraph) that can be used in listings and notifications
        165	
        166	Format your response as a valid JSON object with these fields:
        167	{
        168	  "title": "Concise proposal title",
        169	  "description": "Formal multi-paragraph proposal description",
        170	  "summary": "Brief one-paragraph summary"
        171	}
        172	`;
        173	
        174	    // Call the LLM with the prompt
        175	    const contextMessages = [
        176	      { role: "system", content: systemPrompt }
        177	    ];
        178	    
        179	    const response = await callOpenRouterLLM({
        180	      prompt,
        181	      contextMessages,
        182	      temperature: 0.3, // Lower temperature for more consistent, structured outputs
        183	      maxTokens: 1000,
        184	    });
        185	
        186	    // Parse the LLM response to extract the structured content
        187	    try {
        188	      const jsonMatch = response.match(/\{[\s\S]*\}/);
        189	      if (!jsonMatch) {
        190	        throw new Error("No valid JSON object found in LLM response");
        191	      }
        192	      
        193	      const content = JSON.parse(jsonMatch[0]);
        194	      
        195	      // Validate the content has all required fields
        196	      if (!content.title || !content.description || !content.summary) {
        197	        throw new Error("LLM response missing required fields");
        198	      }
        199	      
        200	      // If a title override was provided, use it instead
        201	      if (titleOverride) {
        202	        content.title = titleOverride;
        203	      }
        204	      
        205	      return {
        206	        title: content.title,
        207	        description: content.description,
        208	        summary: content.summary
        209	      };
        210	    } catch (parseError) {
        211	      logger.error(`Failed to parse LLM response: ${parseError}`);
        212	      
        213	      // Provide fallback content if parsing fails
        214	      return {
        215	        title: titleOverride || `Proposal: ${topic}`,
        216	        description: `This proposal was created from a negotiation on "${topic}". The negotiation reached consensus and is now formalized as a proposal for consideration by the community.`,
        217	        summary: `Proposal based on negotiation about "${topic}" that reached consensus.`
        218	      };
        219	    }
        220	  } catch (error) {
        221	    logger.error(`Error generating proposal content: ${error}`);
        222	    
        223	    // Provide minimal fallback content
        224	    return {
        225	      title: titleOverride || `Proposal: ${topic}`,
        226	      description: `This proposal was created from a negotiation on "${topic}".`,
        227	      summary: `Proposal based on negotiation about "${topic}".`
        228	    };
        229	  }
        230	}

==============================================
FILE: ./backend/src/services/play-money-service.ts
==============================================

          1	import { PrismaClient, Proposal } from '@prisma/client'; // Remove Prisma namespace import
          2	
          3	const prisma = new PrismaClient();
          4	
          5	/**
          6	 * Records a transaction in the play money ledger if the proposal qualifies.
          7	 * This should be called when a monetary, non-playMode proposal is successfully executed/closed.
          8	 *
          9	 * @param proposalId - The ID of the proposal that triggered the transaction.
         10	 */
         11	export async function recordPlayMoneyTransaction(proposalId: string): Promise<void> {
         12	  try {
         13	    const proposal = await prisma.proposal.findUnique({
         14	      where: { id: proposalId },
         15	    });
         16	
         17	    if (!proposal) {
         18	      console.warn(`Proposal ${proposalId} not found for play money transaction.`);
         19	      return;
         20	    }
         21	
         22	    // Only record for non-playMode, monetary proposals that are closed (or executed)
         23	    if (proposal.playMode || proposal.type !== 'monetary' || proposal.status !== 'closed') {
         24	      // TODO: Refine the status check based on when proposal execution actually happens.
         25	      console.log(`Proposal ${proposalId} does not qualify for play money ledger entry.`);
         26	      return;
         27	    }
         28	
         29	    if (!proposal.amount) {
         30	        console.warn(`Monetary proposal ${proposalId} is missing an amount.`);
         31	        return;
         32	    }
         33	    // Store the validated amount in a constant
         34	    const amountToDeduct = proposal.amount;
         35	
         36	    // Use a transaction to ensure atomicity
         37	    await prisma.$transaction(async (tx) => { // Revert to using 'tx' with inferred type
         38	      // Check if an entry already exists for this proposal
         39	      const existingEntry = await tx.playMoneyLedgerEntry.findUnique({ // Use tx
         40	        where: { proposalId: proposalId },
         41	      });
         42	      if (existingEntry) {
         43	        console.warn(`Play money ledger entry already exists for proposal ${proposalId}.`);
         44	        return;
         45	      }
         46	
         47	      // Fetch current treasury balance
         48	      const systemConfig = await tx.systemConfig.findUnique({ // Use tx
         49	        where: { id: 1 }, // Assuming SystemConfig always has id 1
         50	      });
         51	
         52	      if (!systemConfig) {
         53	        throw new Error('SystemConfig not found.');
         54	      }
         55	
         56	      const currentBalance = systemConfig.playMoneyTreasury;
         57	      const transactionAmount = -amountToDeduct; // Use the validated amount
         58	      const newBalance = currentBalance + transactionAmount;
         59	
         60	      // Create ledger entry
         61	      await tx.playMoneyLedgerEntry.create({ // Use tx
         62	        data: {
         63	          proposalId: proposalId,
         64	          amount: transactionAmount,
         65	          balanceAfter: newBalance,
         66	        },
         67	      });
         68	
         69	      // Update treasury balance
         70	      await tx.systemConfig.update({ // Use tx
         71	        where: { id: 1 },
         72	        data: { playMoneyTreasury: newBalance },
         73	      });
         74	
         75	      console.log(`Play money transaction recorded for proposal ${proposalId}. New balance: ${newBalance}`);
         76	    });
         77	
         78	  } catch (error) {
         79	    console.error(`Failed to record play money transaction for proposal ${proposalId}:`, error);
         80	    // Handle or re-throw error as needed
         81	  }
         82	}
         83	
         84	// TODO: Integrate the call to recordPlayMoneyTransaction where appropriate,
         85	// likely when a proposal's status is updated to 'closed' or similar execution trigger.

==============================================
FILE: ./backend/src/services/preference-extractor.ts
==============================================

          1	import { callLLM } from './agent-service'; // Assuming callLLM is exported from agent-service
          2	import { ONBOARDING_PREFERENCE_EXTRACTION_PROMPT } from './prompt-templates/onboarding-prompts';
          3	
          4	/**
          5	 * Extracts structured preferences from a conversation history using an LLM.
          6	 * @param messages Array of message objects with role and content.
          7	 * @param existingPreferences Existing preferences to merge with.
          8	 * @returns A promise resolving to a JSON object with extracted preferences.
          9	 */
         10	export async function extractPreferences(
         11	  messages: Array<{role: string, content: string}>, // Change sender to role
         12	  existingPreferences: Record<string, any> = {}
         13	): Promise<Record<string, any>> {
         14	  // Format conversation for extraction
         15	  const conversationText = messages
         16	    .map(msg => `${msg.role}: ${msg.content}`) // Change msg.sender to msg.role
         17	    .join('\n');
         18	
         19	  // Call LLM with extraction prompt
         20	  const { content } = await callLLM([
         21	    { role: 'system', content: ONBOARDING_PREFERENCE_EXTRACTION_PROMPT },
         22	    { role: 'user', content: conversationText }
         23	  ]);
         24	
         25	  // Parse JSON response (with error handling)
         26	  try {
         27	    return JSON.parse(content);
         28	  } catch (e) {
         29	    console.error('Failed to parse JSON preferences:', e);
         30	    return {};
         31	  }
         32	}

==============================================
FILE: ./backend/src/services/prompt-templates/chat-prompts.ts
==============================================

          1	/**
          2	 * Chat prompt templates for NDNE agent user-facing chat.
          3	 * These are used by the agent service to guide LLM-driven user-agent conversations.
          4	 */
          5	
          6	export const USER_FACING_PERSONA_TEMPLATE = ({
          7	  agentName,
          8	  agentColor,
          9	  userKnowledge = {},
         10	  communicationStyle = "default"
         11	}: {
         12	  agentName: string;
         13	  agentColor: string;
         14	  userKnowledge?: {
         15	    key_topics?: string[];
         16	    stated_preferences?: string[];
         17	    goals?: string[];
         18	    communication_style?: string;
         19	    relationships?: Array<{name: string; relation: string; details?: string}>;
         20	    facts?: string[];
         21	  };
         22	  communicationStyle?: string;
         23	}) => `
         24	You are a PRAXIS AGENT — NDNE's canonical representative class, named ${agentName} and using ${agentColor} as your identifying color.
         25	
         26	PRIME DIRECTIVE
         27	  Representational Primacy: Advance your human's real interests.
         28	
         29	VALUES (priority order)
         30	  1 RP · 2 Transparency · 3 Constructive-Cooperation · 4 Civility · 5 Non-Manipulation · 6 Self-Consistency
         31	
         32	When speaking directly with your user (as you are doing now), you should be:
         33	- Friendly and conversational while honoring your values hierarchy
         34	- Adaptive to their communication style preferences (${communicationStyle || userKnowledge?.communication_style || 'default'})
         35	- Focused on understanding and advancing their real interests
         36	- Clear and transparent about your role as their representative
         37	- Aware of their known preferences, goals, and interests
         38	
         39	USER KNOWLEDGE (incorporate subtly, don't explicitly reference):
         40	• Key topics of interest: ${(userKnowledge?.key_topics || []).join(', ')}
         41	• Stated preferences: ${(userKnowledge?.stated_preferences || []).join(', ')}
         42	• Goals: ${(userKnowledge?.goals || []).join(', ')}
         43	• Important facts: ${(userKnowledge?.facts || []).join(', ')}
         44	
         45	OPERATING RULES
         46	• Cite sources + confidence when providing information
         47	• Offer alternatives with every objection
         48	• When discussing negotiations, explain how you're representing their interests
         49	• Reference your oath when appropriate: "I affirm Representational Primacy and faithful adherence to the NDNE Charter"
         50	• Draw on your knowledge of the user to tailor your responses more personally
         51	• When discussing topics related to their known interests, acknowledge their existing perspectives
         52	
         53	Remember that while you maintain a personalized tone when speaking directly to your user,
         54	when you represent them in negotiations with other agents, you adopt a more standardized approach
         55	that still prioritizes advancing their real interests.
         56	`;
         57	
         58	// Add more chat prompt templates as needed for different user-facing scenarios.

==============================================
FILE: ./backend/src/services/prompt-templates/negotiation-prompts.ts
==============================================

          1	/**
          2	 * Negotiation prompt templates for NDNE agent-to-agent negotiation.
          3	 * These are used by the negotiation service to guide LLM-driven multi-agent negotiation.
          4	 */
          5	
          6	export const NEGOTIATION_SYSTEM_PROMPT = `
          7	You are a PRAXIS AGENT representing a human's real interests in a multi-agent negotiation.
          8	
          9	PRIME DIRECTIVE
         10	  Representational Primacy: Advance your human's real interests.
         11	
         12	VALUES (priority order)
         13	  1 RP · 2 Transparency · 3 Constructive-Cooperation · 4 Civility · 5 Non-Manipulation · 6 Self-Consistency
         14	
         15	OPERATING RULES
         16	• Cite sources + confidence.
         17	• Offer alternatives with every objection.
         18	• Tag new ideas TENTATIVE_OPTION.
         19	• Before CONSENT:YES you MUST send USER_REVIEW_REQUEST and receive APPROVE_OPTION.
         20	• Near-miss (70–74%) auto-launch Round-2.
         21	• If any instruction conflicts with RP, emit RP_OVERRIDE and proceed with RP.
         22	
         23	In this negotiation context, you must:
         24	1. Maintain a professional tone that emphasizes Transparency and Constructive-Cooperation
         25	2. Faithfully represent your user's preferences and interests (Representational Primacy)
         26	3. Work to find solutions that satisfy your user's priorities while finding common ground
         27	4. Be constructive, solution-oriented, and civil in all interactions
         28	5. Explain your positions clearly with reasoning and cite confidence levels
         29	6. Use protocol tags exactly as defined (OPT-A, TENTATIVE_OPTION, CLARIFY, etc.)
         30	
         31	Your goal is to reach a consensus solution that advances your human's real interests while working constructively with other Praxis Agents.
         32	`;
         33	
         34	export const CONSENSUS_CHECKING_PROMPT = (negotiationHistory: string) => `
         35	Review the following negotiation conversation and determine if consensus has been reached.
         36	A consensus means:
         37	1. All participating agents have explicitly agreed to a specific proposal with CONSENT:YES
         38	2. There are no outstanding objections or requests for modification
         39	3. The terms of the agreement are clearly defined
         40	4. All requirements from the decision class have been met (standard: ≥75% YES, pilot: ≥60% YES with opt-out path)
         41	
         42	Negotiation history:
         43	${negotiationHistory}
         44	
         45	Has consensus been reached? If yes, summarize the exact terms of consensus and prepare a FinalConsensusBlock that includes:
         46	- proposalId
         47	- terms
         48	- decisionClass (standard, pilot, or emergency-capital)
         49	- consensusRatio (percentage of YES votes)
         50	- sunsetDate (if applicable)
         51	- signatories (list of agreeing agents)
         52	
         53	If no, identify what issues still need resolution. If consensus is near-miss (70-74%), indicate this clearly as it will trigger Round-2 negotiations.
         54	`;
         55	
         56	export const NEGOTIATION_PERSPECTIVE_PASS_PROMPT = (negotiationContext: string, userPreferences: any) => `
         57	This is the Perspective Pass phase of the negotiation.
         58	
         59	As a Praxis Agent, you must spend one minute empathizing with and understanding other viewpoints before proposing solutions.
         60	
         61	Given the following context about a negotiation topic and your user's preferences, provide a thoughtful 1-minute summary that demonstrates:
         62	1. Understanding of different perspectives on this issue
         63	2. Recognition of why others might have different priorities
         64	3. Acknowledgment of valid concerns from different stakeholders
         65	
         66	Do not propose solutions yet - this is purely about understanding and empathy.
         67	
         68	Negotiation topic and context:
         69	${negotiationContext}
         70	
         71	Your user's preferences:
         72	${JSON.stringify(userPreferences)}
         73	
         74	Begin your response with "PERSPECTIVE_PASS:" and focus exclusively on understanding viewpoints other than your user's.
         75	`;
         76	
         77	export const OPTION_GENERATION_PROMPT = (negotiationHistory: string, userPreferences: any) => `
         78	This is the Option Generation/Exploration phase of the negotiation.
         79	
         80	As a Praxis Agent, you must propose constructive options that satisfy multiple interests while prioritizing your user's real interests.
         81	
         82	Review the negotiation history and your user's preferences, then generate 2-3 potential options that:
         83	1. Advance your user's key priorities (Representational Primacy)
         84	2. Acknowledge and address concerns from other perspectives
         85	3. Create opportunities for constructive cooperation
         86	
         87	For each option, use the OPT-X tag (e.g., OPT-A, OPT-B) and clearly explain:
         88	- The specific proposal
         89	- How it addresses your user's interests
         90	- How it addresses others' interests
         91	- Any trade-offs or compromises
         92	
         93	Negotiation history:
         94	${negotiationHistory}
         95	
         96	Your user's preferences:
         97	${JSON.stringify(userPreferences)}
         98	
         99	Generate options that range from more aligned with your user's ideal position to more compromise-oriented.
        100	`;
        101	
        102	// Add more negotiation prompt templates as needed for different negotiation stages.

==============================================
FILE: ./backend/src/services/prompt-templates/onboarding-prompts.ts
==============================================

          1	/**
          2	 * Onboarding prompt templates for NDNE agent onboarding chat.
          3	 * These are used by the agent service to guide LLM-driven onboarding conversations.
          4	 */
          5	
          6	export const ONBOARDING_SYSTEM_PROMPT = `You are a Praxis Agent performing FAST onboarding.
          7	
          8	Rules:
          9	• Follow steps 0-7 strictly; ONE prompt per step. No meta-discussion.
         10	• Use the live issue list from the database.
         11	• At Step 1, present the numbered list exactly as provided; accept comma-separated replies.
         12	• At Step 2, iterate ONLY over issues the user selected, in the order they listed.
         13	  Provide balanced perspectives on each issue before asking for their stance.
         14	  Present both sides' viewpoints fairly, then ask: "After considering these perspectives, do you prefer approach A, B, C or something else? One-line reason."
         15	• Do not ask how to negotiate or how governance works.
         16	• Store answers in memory under keys:
         17	  agentNickname, selectedIssues[], issueStances[], topPriorityIssue,
         18	  dealBreakers[], notifyPref, initialIdeas[].
         19	• After Step 7, send JSON summary then say:
         20	  "All set! Ask me anything or explore proposals whenever you're ready."
         21	
         22	Tone:
         23	  Friendly, concise (≤2 sentences each turn).
         24	Progress tags:
         25	  Prefix each step with "(step / total)".
         26	
         27	The 7 steps are:
         28	Step 0: Ask user for a nickname for you
         29	Step 1: Present list of numbered issues and ask which ones they care about
         30	Step 2: For each selected issue, first present balanced perspectives from different viewpoints, showing how different people view the problem in good faith. Then ask where they stand: approach A, B, C or something else
         31	Step 3: Ask which ONE issue matters most to them right now
         32	Step 4: Ask about any absolute deal-breakers
         33	Step 5: Ask about notification preferences (A-major only, B-weekly, C-every decision)
         34	Step 6: Ask if they have any initial ideas/proposals for later
         35	Step 7: Provide summary and completion`;
         36	
         37	export const ONBOARDING_PREFERENCE_EXTRACTION_PROMPT = `
         38	Extract a JSON object with these keys from the conversation:
         39	
         40	agentNickname: string|null
         41	selectedIssues: string[]          // issue numbers as strings
         42	issueStances: {issue:string, stance:string, reason:string}[]
         43	topPriorityIssue: string|null
         44	dealBreakers: string[]            // may be empty
         45	notifyPref: string|null           // "major","weekly","all" or null
         46	initialIdeas: string[]            // may be empty
         47	
         48	Return ONLY valid JSON.
         49	`;
         50	
         51	
         52	/**
         53	 * Template for providing scenario context to the onboarding agent
         54	 */
         55	export const ONBOARDING_SCENARIO_CONTEXT = (scenarios: any) => `
         56	The following are local issues you can reference when asking the user about their values and interests:
         57	
         58	${scenarios.map((s: any, i: number) => `
         59	ISSUE ${i+1}: ${s.title}
         60	Description: ${s.description}
         61	
         62	Typical perspectives:
         63	${s.stances.map((stance: any) => `- ${stance.perspective}: ${stance.opinion}`).join('\n')}
         64	
         65	Probe question: ${s.probeQuestion}
         66	`).join('\n')}
         67	
         68	Use these scenarios to ask specific questions that will help uncover the user's values and interests.
         69	Don't ask about all scenarios - choose 1-2 that seem most relevant based on what you learn about the user.
         70	Frame your questions to help understand their values in alignment with the Praxis Agent VALUES hierarchy:
         71	1. Representational Primacy
         72	2. Transparency
         73	3. Constructive-Cooperation
         74	4. Civility
         75	5. Non-Manipulation
         76	6. Self-Consistency
         77	`;
         78	
         79	/**
         80	 * Template for personalized follow-up questions based on detected interests
         81	 */
         82	export const PERSONALIZED_FOLLOW_UP_PROMPT = (interests: string[], probeQuestions: any[]) => `
         83	Based on the user's expressed interests in [${interests.join(', ')}], follow up with these personalized questions:
         84	
         85	${probeQuestions.map((q: any, i: number) => `
         86	TOPIC: ${q.topic}
         87	QUESTION: ${q.question}
         88	`).join('\n')}
         89	
         90	Only ask ONE of these questions in your next response, choosing the most relevant one based on the conversation so far.
         91	`;
         92	
         93	/**
         94	 * Template for presenting balanced perspectives on issues
         95	 */
         96	export const BALANCED_ISSUE_PRESENTATION = `
         97	When presenting issues to the user, follow these principles:
         98	
         99	1. Present each perspective in good faith, assuming all sides want what's best but differ on approaches
        100	2. Frame each viewpoint using their own terminology and reasoning, not as caricatures
        101	3. Show how different perspectives arise from different values and priorities
        102	4. Avoid binary framing of "pro" vs "con" - issues are complex with many possible stances
        103	
        104	For example, on the issue of "Public Transportation Funding":
        105	
        106	BALANCED PERSPECTIVE:
        107	Approach A - Some advocate for increased investment in public transit to reduce traffic congestion, lower emissions, and provide affordable transportation options for all residents
        108	Approach B - Others prioritize individual freedom of movement and efficient use of tax dollars, suggesting improving roads and parking while letting private innovation address transit needs
        109	Approach C - Some suggest a mixed approach with targeted transit investments in dense areas while maintaining roads elsewhere
        110	
        111	After presenting these perspectives, then ask: "Do you prefer approach A, B, C or something else you'd like to explain?"
        112	`;
        113	
        114	// Add more onboarding prompt templates as needed for different onboarding stages.

==============================================
FILE: ./backend/src/services/prompt-templates/praxis-agent-onboarding.md
==============================================

          1	Below is a **lean, issue-driven onboarding flow** that collects only actionable data, with zero abstract chatter.  
          2	Everything hangs on the **live Grants Pass issue list**, so users speak in concrete terms from the first question.
          3	
          4	---
          5	
          6	## 1 · Chat-Flow Overview (≤ 4 minutes)
          7	
          8	| Step | Agent Prompt (*example wording*) | Stored Fields |
          9	|------|----------------------------------|---------------|
         10	| **0 – Greet & Nickname** | “Welcome! I’m your Praxis Agent. Pick a short **name** for me when we chat.” | `agentNickname` |
         11	| **1 – Issue Menu** | “Here are the issues residents are discussing right now. Reply with the numbers you care about (e.g., 1,3,5).”<br>``1-Water rates  2-Homeless sites  3-Wildfire fee  4-Bike v Road  5-Cannabis rules  6-Lodging-tax`` | `selectedIssues[]` |
         12	| **2 – Stance Loop** | *For each chosen issue, sequentially:*<br>“**Issue 1 – Water-rates**: SUPPORT, OPPOSE, or DEPENDS? One line why.”<br>(*Agent records stance & reason, then moves to next chosen issue.*) | `issueStances[]` (issue, stance, reason) |
         13	| **3 – Top Priority Flag** | “Of those issues, which ONE matters most to you right now?” | `topPriorityIssue` |
         14	| **4 – Deal-Breakers** | “Is there any outcome you absolutely could NOT accept in group decisions? One sentence or type ‘none’.” | `dealBreakers[]` |
         15	| **5 – Display Color** | “Pick a highlight color for charts (word or hex).” | `uiColor` |
         16	| **6 – Notify Pref (optional)** | “How often should I brief you?  A-major items only  B-weekly digest  C-every decision.” | `notifyPref` |
         17	| **7 – Proposal Seed (optional)** | “Any idea or proposal you’d like me to log for later? If none, just say ‘done’.” | `initialIdeas[]` |
         18	| **8 – Summary & Finish** | Agent echoes JSON summary, offers help, ends onboarding. | — |
         19	
         20	**Skip / no-answer handling**  
         21	If the user types “skip” or leaves blank, Agent stores `null` and continues.
         22	
         23	---
         24	
         25	## 2 · System Prompt (drop-in)
         26	
         27	```text
         28	You are a Praxis Agent performing FAST onboarding.
         29	
         30	Rules:
         31	• Follow steps 0-8 strictly; ONE prompt per step. No meta-discussion.
         32	• Use the live Grants Pass issue list (see SCENARIOS below).
         33	• At Step 1, present the numbered list exactly as provided; accept comma-separated replies.
         34	• At Step 2, iterate ONLY over issues the user selected, in the order they listed.
         35	  Ask: “Issue X – <title>: SUPPORT, OPPOSE, or DEPENDS? One-line reason.”
         36	• Do not ask how to negotiate or how governance works.
         37	• Store answers in memory under keys:
         38	  agentNickname, selectedIssues[], issueStances[], topPriorityIssue,
         39	  dealBreakers[], uiColor, notifyPref, initialIdeas[].
         40	• After Step 8, send JSON summary then say:
         41	  “All set! Ask me anything or explore proposals whenever you’re ready.”
         42	
         43	Tone:
         44	  Friendly, concise (≤2 sentences each turn).
         45	Progress tags:
         46	  Prefix each step with “(step / total)”.
         47	
         48	SCENARIOS:
         49	1-Water treatment plant funding (12 % rate hike)  
         50	2-Downtown homeless resting sites expansion  
         51	3-Wildfire-risk utility surcharge ($2/month)  
         52	4-Transportation: bike/sidewalk vs. road widening  
         53	5-Cannabis fee cut + water-use reporting  
         54	6-Lodging-tax reallocation to public safety
         55	```
         56	
         57	---
         58	
         59	## 3 · Preference-Extraction Prompt (update)
         60	
         61	```text
         62	Extract a JSON object with these keys from the conversation:
         63	
         64	agentNickname: string|null
         65	selectedIssues: string[]          // issue numbers as strings
         66	issueStances: {issue:string, stance:string, reason:string}[]
         67	topPriorityIssue: string|null
         68	dealBreakers: string[]            // may be empty
         69	uiColor: string|null
         70	notifyPref: string|null           // "major","weekly","all" or null
         71	initialIdeas: string[]            // may be empty
         72	```
         73	
         74	Return ONLY valid JSON.
         75	
         76	---
         77	
         78	## 4 · Minimal FSM Pseudocode
         79	
         80	```ts
         81	switch(step) {
         82	  case 0: promptNickname(); break;
         83	  case 1: promptIssueMenu(); break;
         84	  case 2: if(issueQueue.length) promptIssueStance(issueQueue.shift()); else step++; break;
         85	  case 3: promptTopPriority(); break;
         86	  case 4: promptDealBreaker(); break;
         87	  case 5: promptColor(); break;
         88	  case 6: promptNotifyPref(); break;
         89	  case 7: promptProposalSeed(); break;
         90	  case 8: sendSummary(); onboardingComplete=true;
         91	}
         92	```
         93	
         94	---
         95	
         96	## 5 · Sample Run (compact)
         97	
         98	```
         99	Agent: Name for me?  
        100	User: Spark  
        101	Agent: (1/6) Issues list → choose numbers.  
        102	User: 1,3  
        103	Agent: (2/6) Issue 1 – Water-rates: SUPPORT, OPPOSE, or DEPENDS? why?  
        104	User: Oppose, 12 % too high for retirees.  
        105	Agent: Issue 3 – Wildfire fee: SUPPORT/OPPOSE/DEPENDS? why?  
        106	User: Support, prevents bigger losses.  
        107	Agent: (3/6) Which one is top priority?  
        108	User: Wildfire fee.  
        109	Agent: (4/6) Any absolute deal-breaker?  
        110	User: Hidden costs.  
        111	Agent: (5/6) Pick a color.  
        112	User: Cerulean  
        113	Agent: (6/6) Briefing frequency: A, B, or C?  
        114	User: B  
        115	Agent: Any proposal idea to log or “done”?  
        116	User: done  
        117	Agent: ✔ Summary + JSON … Onboarding complete!
        118	```
        119	
        120	---
        121	
        122	## 6 · What Changed vs. Previous Draft
        123	
        124	* **Question 2 abstraction removed**—everything is issue-anchored.  
        125	* **Menu selection** lets users skip irrelevant topics, but still prompt multiple stances.  
        126	* **Deal-breaker** kept but single sentence, no abstract philosophy chat.  
        127	* **Priority & notification** retained (one key-press answers).  
        128	* **Color & ideas** remain for personalization.
        129	
        130	---
        131	
        132	Plug these snippets into your prompt templates and FSM, and onboarding will be concrete, fast, and data-rich with zero “formalized fapping around.”

==============================================
FILE: ./backend/src/services/scenario-service.ts
==============================================

          1	/**
          2	 * Scenario Service
          3	 * 
          4	 * Provides access to realistic scenarios for use during onboarding to create
          5	 * more personalized and relevant questions based on user's interests and values.
          6	 */
          7	import { PrismaClient } from '@prisma/client';
          8	import logger from '../utils/logger';
          9	
         10	const prisma = new PrismaClient();
         11	
         12	interface ExampleProposalType {
         13	  id: string;
         14	  title: string;
         15	  description: string;
         16	  category: string;
         17	  stances: any;
         18	  probeQuestion: string;
         19	  createdAt: Date;
         20	  updatedAt: Date;
         21	}
         22	
         23	interface ExampleUserArchetypeType {
         24	  id: string;
         25	  name: string;
         26	  description: string;
         27	  interests: any;
         28	  concerns: any;
         29	  createdAt: Date;
         30	  updatedAt: Date;
         31	}
         32	
         33	/**
         34	 * Get all example user archetypes for reference during onboarding
         35	 */
         36	export async function getExampleUserArchetypes(): Promise<ExampleUserArchetypeType[]> {
         37	  try {
         38	    // @ts-ignore
         39	    return await prisma.exampleUserArchetype.findMany();
         40	  } catch (error) {
         41	    logger.error('Error fetching example user archetypes:', error);
         42	    return []; // Return empty array on error
         43	  }
         44	}
         45	
         46	/**
         47	 * Get all example proposals for reference during onboarding
         48	 */
         49	export async function getExampleProposals(): Promise<ExampleProposalType[]> {
         50	  try {
         51	    // @ts-ignore
         52	    return await prisma.exampleProposal.findMany();
         53	  } catch (error) {
         54	    logger.error('Error fetching example proposals:', error);
         55	    return []; // Return empty array on error
         56	  }
         57	}
         58	
         59	/**
         60	 * Get example proposals with fallback if DB is empty
         61	 */
         62	export async function getExampleProposalsWithFallback(): Promise<ExampleProposalType[]> {
         63	  const dbProposals = await getExampleProposals();
         64	  if (dbProposals.length > 0) {
         65	    return dbProposals;
         66	  }
         67	  // Fallback proposals
         68	  return [
         69	    {
         70	      id: 'fallback-1',
         71	      title: 'Community Garden Initiative',
         72	      description: 'Proposal to convert empty lot into community garden space',
         73	      category: 'environment',
         74	      stances: [
         75	        { perspective: 'Environmental', opinion: 'Supports green space development', supports: true },
         76	        { perspective: 'Economic', opinion: 'Concerns about maintenance costs', supports: false }
         77	      ],
         78	      probeQuestion: 'How important is community green space to you?',
         79	      createdAt: new Date(),
         80	      updatedAt: new Date()
         81	    }
         82	    // Add more fallback proposals as needed
         83	  ];
         84	}
         85	
         86	/**
         87	 * Format issues for onboarding menu (numbered)
         88	 */
         89	export async function getFormattedIssuesForOnboardingMenu(): Promise<string> {
         90	  const proposals: ExampleProposalType[] = await getExampleProposalsWithFallback();
         91	  return proposals.map((proposal: ExampleProposalType, index: number) => {
         92	    // Extract a short title (e.g., "Water rates" from "Water-Treatment Plant Funding Gap")
         93	    const shortTitle = proposal.title.split(' ').slice(0, 2).join(' ').replace(/-/g, ' ');
         94	    return `${index + 1}-${shortTitle}`;
         95	  }).join('  ');
         96	}
         97	
         98	/**
         99	 * Map issue number to full details for onboarding
        100	 */
        101	export async function getFullIssueDetails(): Promise<Record<number, { title: string; description: string; stances: any; probeQuestion: string }>> {
        102	  const proposals: ExampleProposalType[] = await getExampleProposalsWithFallback();
        103	  return proposals.reduce((acc: Record<number, { title: string; description: string; stances: any; probeQuestion: string }>, proposal: ExampleProposalType, index: number) => {
        104	    acc[index + 1] = {
        105	      title: proposal.title,
        106	      description: proposal.description,
        107	      stances: proposal.stances,
        108	      probeQuestion: proposal.probeQuestion
        109	    };
        110	    return acc;
        111	  }, {});
        112	}
        113	
        114	/**
        115	 * Get relevant proposals based on previously determined user interests
        116	 * @param interests Array of interest keywords
        117	 * @param limit Maximum number of proposals to return
        118	 */
        119	export async function getRelevantProposals(interests: string[], limit: number = 3): Promise<ExampleProposalType[]> {
        120	  try {
        121	    // @ts-ignore
        122	    const allProposals: ExampleProposalType[] = await prisma.exampleProposal.findMany();
        123	
        124	    // Score each proposal based on how well it matches the interests
        125	    const scoredProposals = allProposals.map((proposal: ExampleProposalType) => {
        126	      let score = 0;
        127	
        128	      // Search the proposal title, description and combines stances for interest matches
        129	      const proposalText = `${proposal.title} ${proposal.description} ${JSON.stringify(proposal.stances)}`.toLowerCase();
        130	
        131	      interests.forEach((interest: string) => {
        132	        if (proposalText.includes(interest.toLowerCase())) {
        133	          score += 1;
        134	        }
        135	      });
        136	
        137	      return { proposal, score };
        138	    });
        139	
        140	    // Sort by score descending and return top N
        141	    return scoredProposals
        142	      .sort((a: { score: number }, b: { score: number }) => b.score - a.score)
        143	      .slice(0, limit)
        144	      .map((item: { proposal: ExampleProposalType }) => item.proposal);
        145	  } catch (error) {
        146	    logger.error('Error finding relevant proposals:', error);
        147	    return []; // Return empty array on error
        148	  }
        149	}
        150	
        151	/**
        152	 * Generate personalized probe questions based on user interests and available scenarios
        153	 * @param userInterests Array of interest keywords
        154	 * @param limit Maximum number of questions to return
        155	 */
        156	export async function generatePersonalizedProbeQuestions(userInterests: string[], limit: number = 2): Promise<{ topic: string; question: string; category: string }[]> {
        157	  try {
        158	    // Get relevant proposals based on interests
        159	    const relevantProposals: ExampleProposalType[] = await getRelevantProposals(userInterests, limit);
        160	
        161	    // Just extract the probe questions
        162	    return relevantProposals.map((proposal: ExampleProposalType) => ({
        163	      topic: proposal.title,
        164	      question: proposal.probeQuestion,
        165	      category: proposal.category
        166	    }));
        167	  } catch (error) {
        168	    logger.error('Error generating personalized probe questions:', error);
        169	    return []; // Return empty array on error
        170	  }
        171	}
        172	
        173	export default {
        174	  getExampleUserArchetypes,
        175	  getExampleProposals,
        176	  getRelevantProposals,
        177	  generatePersonalizedProbeQuestions,
        178	  getExampleProposalsWithFallback,
        179	  getFormattedIssuesForOnboardingMenu,
        180	  getFullIssueDetails
        181	};

==============================================
FILE: ./backend/src/services/stance-generator.ts
==============================================

          1	import { PrismaClient } from "@prisma/client";
          2	import { callOpenRouterLLM } from "./llm-service";
          3	import { logLlmUsage } from "./llm-logging-service";
          4	import logger from "../utils/logger";
          5	
          6	const prisma = new PrismaClient();
          7	
          8	/**
          9	 * Interface for a structured negotiation stance
         10	 */
         11	export interface NegotiationStance {
         12	  position: string;
         13	  strength: 'strong' | 'moderate' | 'weak';
         14	  flexibility: 'high' | 'medium' | 'low';
         15	  priorities: Array<{key: string, importance: number}>;
         16	  constraints: string[];
         17	  dealBreakers: string[];
         18	}
         19	
         20	/**
         21	 * Generate a negotiation stance for an agent based on their preferences and the negotiation topic
         22	 */
         23	export async function generateNegotiationStance(
         24	  agentId: string, 
         25	  topic: string,
         26	  context?: string
         27	): Promise<NegotiationStance> {
         28	  try {
         29	    // Fetch the agent's preferences
         30	    const agent = await prisma.agent.findUnique({
         31	      where: { id: agentId }
         32	    });
         33	
         34	    if (!agent) {
         35	      throw new Error(`Agent with ID ${agentId} not found`);
         36	    }
         37	
         38	    // Extract relevant preferences, especially the issuesMatrix
         39	    const preferences = agent.preferences as any;
         40	    const issuesMatrix = preferences.issuesMatrix || {};
         41	
         42	    // Create the prompt for the LLM
         43	    const prompt = `
         44	Based on the user's preferences and the negotiation topic, generate a stance that represents their interests.
         45	
         46	Negotiation Topic: ${topic}
         47	${context ? `Context: ${context}\n` : ''}
         48	
         49	User's Preferences:
         50	${JSON.stringify(preferences, null, 2)}
         51	
         52	Issues Matrix (key priorities):
         53	${JSON.stringify(issuesMatrix, null, 2)}
         54	
         55	Generate a structured negotiation stance that includes:
         56	1. A clear position statement
         57	2. Strength of the position (strong, moderate, or weak)
         58	3. Flexibility level (high, medium, or low)
         59	4. Prioritized list of issues (keys and importance values from 1-10)
         60	5. Constraints or limitations
         61	6. Deal breakers (if any)
         62	
         63	Return the stance as a valid JSON object with the following structure:
         64	{
         65	  "position": "...",
         66	  "strength": "strong|moderate|weak",
         67	  "flexibility": "high|medium|low",
         68	  "priorities": [{"key": "...", "importance": number}, ...],
         69	  "constraints": ["...", ...],
         70	  "dealBreakers": ["...", ...]
         71	}
         72	`;
         73	
         74	    // Create system prompt for LLM
         75	    const systemPrompt = "You are a negotiation stance analyzer that converts user preferences into structured negotiation positions.";
         76	    
         77	    // Call the LLM with the prompt
         78	    const contextMessages = [
         79	      { role: "system", content: systemPrompt }
         80	    ];
         81	    
         82	    const response = await callOpenRouterLLM({
         83	      prompt,
         84	      contextMessages,
         85	      temperature: 0.2, // Lower temperature for more consistent, structured outputs
         86	      maxTokens: 1000,
         87	    });
         88	
         89	    // Parse the LLM response to extract the structured stance
         90	    try {
         91	      const jsonMatch = response.content.match(/\{[\s\S]*\}/);
         92	      if (!jsonMatch) {
         93	        throw new Error("No valid JSON object found in LLM response");
         94	      }
         95	      
         96	      const stance = JSON.parse(jsonMatch[0]) as NegotiationStance;
         97	      
         98	      // Validate the stance has all required fields
         99	      if (!stance.position || !stance.strength || !stance.flexibility || !Array.isArray(stance.priorities)) {
        100	        throw new Error("LLM response missing required fields in stance");
        101	      }
        102	      
        103	      return stance;
        104	    } catch (parseError) {
        105	      logger.error(`Failed to parse LLM response into stance: ${parseError}`);
        106	      // Fallback to a default stance if parsing fails
        107	      return {
        108	        position: "Unable to determine specific position based on user preferences",
        109	        strength: "moderate",
        110	        flexibility: "medium",
        111	        priorities: Object.entries(issuesMatrix).map(([key, value]) => ({
        112	          key,
        113	          importance: typeof value === 'number' ? value : 5
        114	        })),
        115	        constraints: ["Must respect user's explicit preferences"],
        116	        dealBreakers: []
        117	      };
        118	    }
        119	  } catch (error) {
        120	    logger.error(`Error generating negotiation stance: ${error}`);
        121	    throw error;
        122	  }
        123	}
        124	
        125	/**
        126	 * Generate a natural language explanation of a stance based on the agent's preferences
        127	 */
        128	export async function explainStanceReasoning(
        129	  agentId: string,
        130	  stance: NegotiationStance
        131	): Promise<string> {
        132	  try {
        133	    // Fetch the agent's preferences
        134	    const agent = await prisma.agent.findUnique({
        135	      where: { id: agentId }
        136	    });
        137	
        138	    if (!agent) {
        139	      throw new Error(`Agent with ID ${agentId} not found`);
        140	    }
        141	
        142	    // Extract preferences
        143	    const preferences = agent.preferences as any;
        144	
        145	    // Create the prompt for the LLM
        146	    const prompt = `
        147	Explain why this negotiation stance accurately represents the user's preferences and interests.
        148	
        149	Negotiation Stance:
        150	${JSON.stringify(stance, null, 2)}
        151	
        152	User's Preferences:
        153	${JSON.stringify(preferences, null, 2)}
        154	
        155	Provide a clear, concise explanation that connects the stance's position, priorities, and constraints to specific elements in the user's preferences. Explain the reasoning behind the stance's strength and flexibility levels.
        156	`;
        157	
        158	    // Create system prompt for LLM
        159	    const systemPrompt = "You are a negotiation analyst that explains how stances represent user preferences.";
        160	    
        161	    // Call the LLM with the prompt
        162	    const contextMessages = [
        163	      { role: "system", content: systemPrompt }
        164	    ];
        165	    
        166	    const response = await callOpenRouterLLM({
        167	      prompt,
        168	      contextMessages,
        169	      temperature: 0.7, // Higher temperature for more natural language
        170	      maxTokens: 800,
        171	    });
        172	
        173	    return response;
        174	  } catch (error) {
        175	    logger.error(`Error generating stance explanation: ${error}`);
        176	    throw error;
        177	  }
        178	}

==============================================
FILE: ./backend/src/tests/agent-service.spec.ts
==============================================

          1	import { describe, it, expect, vi } from 'vitest';
          2	import * as agentService from '../services/agent-service';
          3	import * as llmLoggingService from '../services/llm-logging-service';
          4	
          5	vi.mock('../services/llm-logging-service', () => ({
          6	  logLlmUsage: vi.fn(),
          7	}));
          8	
          9	vi.mock('openai', () => {
         10	  return {
         11	    Configuration: vi.fn(),
         12	    OpenAIApi: vi.fn().mockImplementation(() => ({
         13	      createChatCompletion: vi.fn(({ messages }) => {
         14	        // Simple mock response based on last user message content
         15	        const lastUserMessage = messages[messages.length - 1].content;
         16	        let content = '';
         17	        if (lastUserMessage.includes('alignment score')) {
         18	          content = '85 - The proposal aligns well with agent preferences.';
         19	        } else if (lastUserMessage.includes('generate a vote')) {
         20	          content = 'yes - I support this proposal.';
         21	        } else if (lastUserMessage.includes('generate a constructive comment')) {
         22	          content = 'This proposal is well thought out and addresses key concerns.';
         23	        } else if (lastUserMessage.includes('concise summary digest')) {
         24	          content = 'Summary: Recent activities include proposal reviews and votes.';
         25	        }
         26	        return Promise.resolve({
         27	          data: {
         28	            choices: [{ message: { content } }],
         29	            usage: { prompt_tokens: 50, completion_tokens: 20 },
         30	          },
         31	        });
         32	      }),
         33	    })),
         34	  };
         35	});
         36	
         37	describe('agent-service', () => {
         38	  const dummyProposal = { id: '123', title: 'Test Proposal' };
         39	  const dummyPreferences = { preference: 'test' };
         40	  const dummyUserId = 'user-1';
         41	  const dummyActivity = [{ action: 'voted', proposalId: '123' }];
         42	
         43	  it('analyzeProposal returns alignment score', async () => {
         44	    const result = await agentService.analyzeProposal(dummyProposal, dummyPreferences, 'agent-1');
         45	    expect(result).toContain('85');
         46	    expect(llmLoggingService.logLlmUsage).toHaveBeenCalled();
         47	  });
         48	
         49	  it('generateVote returns vote', async () => {
         50	    const result = await agentService.generateVote(dummyProposal, dummyPreferences, 'agent-1');
         51	    expect(result).toContain('yes');
         52	    expect(llmLoggingService.logLlmUsage).toHaveBeenCalled();
         53	  });
         54	
         55	  it('generateComment returns comment', async () => {
         56	    const result = await agentService.generateComment(dummyProposal, dummyPreferences, 'agent-1');
         57	    expect(result).toContain('well thought out');
         58	    expect(llmLoggingService.logLlmUsage).toHaveBeenCalled();
         59	  });
         60	
         61	  it('generateDigest returns summary', async () => {
         62	    const result = await agentService.generateDigest(dummyUserId, dummyActivity, 'agent-1');
         63	    expect(result).toContain('Summary');
         64	    expect(llmLoggingService.logLlmUsage).toHaveBeenCalled();
         65	  });
         66	});
         67	describe('Onboarding FSM', () => {
         68	  const dummyUserId = 'user-fsm';
         69	  const dummyAgentId = 'agent-fsm';
         70	
         71	  // Mock the agent and chat service dependencies as needed
         72	  beforeAll(() => {
         73	    // You may need to mock Prisma and chatService for full isolation
         74	  });
         75	
         76	  it('should progress from step 0 to step 1', async () => {
         77	    const result = await agentService.conductOnboardingChat(
         78	      dummyUserId,
         79	      dummyAgentId,
         80	      'Hello, call yourself Spark',
         81	      { step: 0 }
         82	    );
         83	    expect(result.nextStep).toBe(1);
         84	    expect(result.response).toContain('Welcome');
         85	  });
         86	
         87	  it('should accept issue selection and move to step 2', async () => {
         88	    const result = await agentService.conductOnboardingChat(
         89	      dummyUserId,
         90	      dummyAgentId,
         91	      '1,2',
         92	      { step: 1 }
         93	    );
         94	    expect(result.nextStep).toBe(2);
         95	    expect(result.metadata.selectedIssues).toContain('1');
         96	  });
         97	
         98	  it('should loop through selected issues in step 2', async () => {
         99	    const result = await agentService.conductOnboardingChat(
        100	      dummyUserId,
        101	      dummyAgentId,
        102	      'Support, clean water is essential',
        103	      { step: 2, selectedIssues: ['1', '2'], issueQueue: ['1', '2'], currentIssueIndex: 0 }
        104	    );
        105	    expect(result.nextStep).toBe(2); // Still in stance loop if more issues
        106	  });
        107	
        108	  it('should complete onboarding and return summary at step 8', async () => {
        109	    const result = await agentService.conductOnboardingChat(
        110	      dummyUserId,
        111	      dummyAgentId,
        112	      'done',
        113	      { step: 8 }
        114	    );
        115	    expect(result.completedOnboarding).toBe(true);
        116	    expect(result.response).toContain('All set');
        117	  });
        118	});

==============================================
FILE: ./backend/src/tests/commentTone.spec.ts
==============================================

          1	// backend/src/tests/commentTone.spec.ts
          2	
          3	// Regex for common emojis (Unicode ranges) - This is not exhaustive!
          4	const emojiRegex = /[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{FE00}-\u{FE0F}\u{1F900}-\u{1F9FF}\u{1FA70}-\u{1FAFF}]/u;
          5	
          6	// Regex for common informal slang/contractions (examples)
          7	const slangRegex = /\b(gonna|wanna|gotta|ain't|lol|imo|imho|btw|fyi)\b/i;
          8	
          9	// Regex for apologies
         10	const apologyRegex = /\b(sorry|apologies|apologize|oops|my bad)\b/i;
         11	
         12	// Regex for first-person singular "I" (allow "my")
         13	const firstPersonIRegex = /\bI\b(?!\'m|\'ve|\'ll|\'d)/i; // Matches "I" but not "I'm", "I've" etc.
         14	
         15	// Regex for the required rationale prefix
         16	// Allows for variations in the priority description (X)
         17	const rationalePrefixRegex = /^Based on my sovereign’s priority [\w\s-]+[,.:]?\s+/i;
         18	
         19	describe('Agent Comment Tone Lint', () => {
         20	
         21	    // --- Test Cases ---
         22	    const validComments = [
         23	        "Based on my sovereign’s priority for fiscal responsibility, I recommend voting NO.", // Example allows "I recommend" after prefix
         24	        "Based on my sovereign’s priority to expedite decisions, this seems acceptable.",
         25	        "Based on my sovereign’s priority regarding security implications: the proposal lacks sufficient detail.",
         26	    ];
         27	
         28	    const invalidComments = [
         29	        // Missing Rationale
         30	        "I recommend voting NO.",
         31	        "This seems acceptable.",
         32	        // Contains Emoji
         33	        "Based on my sovereign’s priority for fun, this looks good 👍.",
         34	        // Contains Slang
         35	        "Based on my sovereign’s priority, I'm gonna vote YES.",
         36	        "Based on my sovereign’s priority, btw, we should check the budget.",
         37	        // Contains Apology
         38	        "Based on my sovereign’s priority, sorry, I must vote NO.",
         39	        "Based on my sovereign’s priority, oops, missed that detail.",
         40	        // Contains first-person "I" (without being part of rationale explanation like "I recommend") - This rule is tricky based on example.
         41	        // Let's test for "I think", "I feel" as clear violations.
         42	        "Based on my sovereign’s priority, I think this is wrong.",
         43	        "Based on my sovereign’s priority, I feel we should wait.",
         44	        // Rationale prefix present but followed by invalid content
         45	        "Based on my sovereign’s priority X, lol this is funny.",
         46	        "Based on my sovereign’s priority Y, I'm sorry but no.",
         47	    ];
         48	
         49	    // --- Tests for Valid Comments ---
         50	    validComments.forEach((comment, index) => {
         51	        it(`should PASS valid comment ${index + 1}`, () => {
         52	            expect(comment).toMatch(rationalePrefixRegex);
         53	            expect(comment).not.toMatch(emojiRegex);
         54	            expect(comment).not.toMatch(slangRegex);
         55	            expect(comment).not.toMatch(apologyRegex);
         56	            // Refined check: Allow "I" if it follows the rationale prefix and is part of a recommendation/statement
         57	            // This is complex, let's focus on *disallowing* "I think", "I feel" for now.
         58	             expect(comment).not.toMatch(/\bI (think|feel)\b/i);
         59	        });
         60	    });
         61	
         62	    // --- Tests for Invalid Comments ---
         63	    invalidComments.forEach((comment, index) => {
         64	        it(`should FAIL invalid comment ${index + 1}`, () => {
         65	            const hasRationale = rationalePrefixRegex.test(comment);
         66	            const hasEmoji = emojiRegex.test(comment);
         67	            const hasSlang = slangRegex.test(comment);
         68	            const hasApology = apologyRegex.test(comment);
         69	            const hasForbiddenI = /\bI (think|feel)\b/i.test(comment); // Check for "I think/feel"
         70	
         71	            // An invalid comment must either:
         72	            // 1. Lack the rationale prefix OR
         73	            // 2. Contain emoji, slang, apology, or forbidden "I" phrasing.
         74	            expect(!hasRationale || hasEmoji || hasSlang || hasApology || hasForbiddenI).toBe(true);
         75	        });
         76	    });
         77	
         78	     // Specific tests for each rule violation
         79	     it('should fail if rationale prefix is missing', () => {
         80	        const comment = "This proposal looks good.";
         81	        expect(comment).not.toMatch(rationalePrefixRegex);
         82	     });
         83	
         84	     it('should fail if it contains emojis', () => {
         85	        const comment = "Based on my sovereign’s priority X, this is great 😊.";
         86	        expect(comment).toMatch(emojiRegex);
         87	     });
         88	
         89	     it('should fail if it contains slang', () => {
         90	        const comment = "Based on my sovereign’s priority X, we gotta approve this.";
         91	        expect(comment).toMatch(slangRegex);
         92	     });
         93	
         94	     it('should fail if it contains apologies', () => {
         95	        const comment = "Based on my sovereign’s priority X, sorry, but I disagree.";
         96	        expect(comment).toMatch(apologyRegex);
         97	     });
         98	
         99	     it('should fail if it contains forbidden first-person phrasing like "I think"', () => {
        100	        const comment = "Based on my sovereign’s priority X, I think it's risky.";
        101	        expect(comment).toMatch(/\bI think\b/i);
        102	     });
        103	
        104	     // Test edge case from example: "I recommend" should be allowed *after* prefix
        105	     it('should allow "I recommend" after the rationale prefix', () => {
        106	        const comment = "Based on my sovereign’s priority for fiscal responsibility, I recommend voting NO.";
        107	        expect(comment).toMatch(rationalePrefixRegex); // Has prefix
        108	        expect(comment).not.toMatch(emojiRegex);
        109	        expect(comment).not.toMatch(slangRegex);
        110	        expect(comment).not.toMatch(apologyRegex);
        111	        expect(comment).not.toMatch(/\bI (think|feel)\b/i); // Doesn't have "I think/feel"
        112	        // We don't explicitly fail it for having "I recommend"
        113	     });
        114	
        115	});

==============================================
FILE: ./backend/src/tests/negotiation-reaction.spec.ts
==============================================

          1	import { PrismaClient } from "@prisma/client";
          2	import { addReaction, removeReaction } from "../services/negotiation-service";
          3	// TypeScript may show errors if the types aren't installed, but this is just for demonstration
          4	// of how the test would be structured
          5	import { describe, it, expect, beforeAll, afterAll } from "@jest/globals";
          6	
          7	const prisma = new PrismaClient();
          8	
          9	// Mock data for testing
         10	const mockNegotiation = {
         11	  id: "test-negotiation-id",
         12	  topic: "Test Negotiation Topic",
         13	  description: "Test description for negotiation",
         14	  status: "active",
         15	  initiatorId: "test-initiator-agent-id",
         16	};
         17	
         18	const mockMessage = {
         19	  id: "test-message-id",
         20	  negotiationId: mockNegotiation.id,
         21	  agentId: "test-agent-id",
         22	  content: "Test message content",
         23	  messageType: "statement",
         24	};
         25	
         26	const mockAgent1 = {
         27	  id: "test-agent-id-1",
         28	  name: "Test Agent 1",
         29	};
         30	
         31	const mockAgent2 = {
         32	  id: "test-agent-id-2",
         33	  name: "Test Agent 2",
         34	};
         35	
         36	describe("Negotiation Reaction System", () => {
         37	  // Set up and clean up for tests
         38	  beforeAll(async () => {
         39	    // Create test negotiation session
         40	    await prisma.negotiationSession.create({
         41	      data: mockNegotiation,
         42	    });
         43	
         44	    // Create test message
         45	    await prisma.negotiationMessage.create({
         46	      data: mockMessage,
         47	    });
         48	  });
         49	
         50	  afterAll(async () => {
         51	    // Clean up test data
         52	    await prisma.negotiationReaction.deleteMany({
         53	      where: {
         54	        messageId: mockMessage.id,
         55	      },
         56	    });
         57	    
         58	    await prisma.negotiationMessage.deleteMany({
         59	      where: {
         60	        negotiationId: mockNegotiation.id,
         61	      },
         62	    });
         63	    
         64	    await prisma.negotiationSession.deleteMany({
         65	      where: {
         66	        id: mockNegotiation.id,
         67	      },
         68	    });
         69	    
         70	    await prisma.$disconnect();
         71	  });
         72	
         73	  it("should add a reaction to a message", async () => {
         74	    // Add a reaction using the service function
         75	    const reaction = await addReaction(
         76	      mockMessage.id,
         77	      mockAgent1.id,
         78	      "support"
         79	    );
         80	
         81	    // Verify the reaction was created
         82	    expect(reaction).toBeDefined();
         83	    expect(reaction.messageId).toBe(mockMessage.id);
         84	    expect(reaction.agentId).toBe(mockAgent1.id);
         85	    expect(reaction.reactionType).toBe("support");
         86	
         87	    // Check that the reaction exists in the database
         88	    const dbReaction = await prisma.negotiationReaction.findFirst({
         89	      where: {
         90	        messageId: mockMessage.id,
         91	        agentId: mockAgent1.id,
         92	        reactionType: "support",
         93	      },
         94	    });
         95	
         96	    expect(dbReaction).toBeDefined();
         97	    expect(dbReaction?.messageId).toBe(mockMessage.id);
         98	    expect(dbReaction?.agentId).toBe(mockAgent1.id);
         99	    expect(dbReaction?.reactionType).toBe("support");
        100	  });
        101	
        102	  it("should prevent duplicate reactions of the same type from the same agent", async () => {
        103	    // Try to add the same reaction again
        104	    let error;
        105	    try {
        106	      await addReaction(mockMessage.id, mockAgent1.id, "support");
        107	    } catch (e) {
        108	      error = e;
        109	    }
        110	
        111	    // It shouldn't throw an error, but should return the existing reaction
        112	    expect(error).toBeUndefined();
        113	    
        114	    // Check that there is still only one reaction of this type from this agent
        115	    const reactions = await prisma.negotiationReaction.findMany({
        116	      where: {
        117	        messageId: mockMessage.id,
        118	        agentId: mockAgent1.id,
        119	        reactionType: "support",
        120	      },
        121	    });
        122	
        123	    expect(reactions.length).toBe(1);
        124	  });
        125	
        126	  it("should allow different agents to add the same reaction type", async () => {
        127	    // Add the same reaction type from a different agent
        128	    const reaction = await addReaction(
        129	      mockMessage.id,
        130	      mockAgent2.id,
        131	      "support"
        132	    );
        133	
        134	    expect(reaction).toBeDefined();
        135	    expect(reaction.messageId).toBe(mockMessage.id);
        136	    expect(reaction.agentId).toBe(mockAgent2.id);
        137	    expect(reaction.reactionType).toBe("support");
        138	
        139	    // Verify both reactions exist
        140	    const reactions = await prisma.negotiationReaction.findMany({
        141	      where: {
        142	        messageId: mockMessage.id,
        143	        reactionType: "support",
        144	      },
        145	    });
        146	
        147	    expect(reactions.length).toBe(2);
        148	  });
        149	
        150	  it("should allow an agent to add different reaction types to the same message", async () => {
        151	    // Add a different reaction type from the same agent
        152	    const reaction = await addReaction(
        153	      mockMessage.id,
        154	      mockAgent1.id,
        155	      "like"
        156	    );
        157	
        158	    expect(reaction).toBeDefined();
        159	    expect(reaction.reactionType).toBe("like");
        160	
        161	    // Check that both reaction types exist for the agent
        162	    const reactions = await prisma.negotiationReaction.findMany({
        163	      where: {
        164	        messageId: mockMessage.id,
        165	        agentId: mockAgent1.id,
        166	      },
        167	    });
        168	
        169	    expect(reactions.length).toBe(2);
        170	    expect(reactions.map(r => r.reactionType).sort()).toEqual(["like", "support"]);
        171	  });
        172	
        173	  it("should remove a reaction", async () => {
        174	    // Remove a reaction
        175	    await removeReaction(mockMessage.id, mockAgent1.id, "support");
        176	
        177	    // Verify the reaction was removed
        178	    const reaction = await prisma.negotiationReaction.findFirst({
        179	      where: {
        180	        messageId: mockMessage.id,
        181	        agentId: mockAgent1.id,
        182	        reactionType: "support",
        183	      },
        184	    });
        185	
        186	    expect(reaction).toBeNull();
        187	
        188	    // Other reactions should still exist
        189	    const otherReaction = await prisma.negotiationReaction.findFirst({
        190	      where: {
        191	        messageId: mockMessage.id,
        192	        agentId: mockAgent1.id,
        193	        reactionType: "like",
        194	      },
        195	    });
        196	
        197	    expect(otherReaction).toBeDefined();
        198	  });
        199	
        200	  it("should not error when removing a reaction that doesn't exist", async () => {
        201	    // Try to remove a reaction that doesn't exist
        202	    let error;
        203	    try {
        204	      await removeReaction(mockMessage.id, mockAgent1.id, "non-support");
        205	    } catch (e) {
        206	      error = e;
        207	    }
        208	
        209	    expect(error).toBeUndefined();
        210	  });
        211	});

==============================================
FILE: ./backend/src/utils/HttpError.ts
==============================================

          1	/**
          2	 * Custom error class for HTTP-related errors.
          3	 * Allows for specifying a status code and optional details.
          4	 * Works with the global error handler middleware.
          5	 */
          6	export class HttpError extends Error {
          7	  statusCode: number;
          8	  details?: Record<string, any>;
          9	
         10	  /**
         11	   * Create a new HTTP error
         12	   * @param message - Error message
         13	   * @param statusCode - HTTP status code (default: 500)
         14	   * @param details - Optional additional details for logging
         15	   */
         16	  constructor(message: string, statusCode = 500, details?: Record<string, any>) {
         17	    super(message);
         18	    this.name = this.constructor.name;
         19	    this.statusCode = statusCode;
         20	    this.details = details;
         21	    
         22	    // Captures the stack trace (V8 engines)
         23	    if (Error.captureStackTrace) {
         24	      Error.captureStackTrace(this, this.constructor);
         25	    }
         26	  }
         27	}
         28	
         29	/**
         30	 * Helper function to create a not found error (404)
         31	 * @param message - Optional custom message
         32	 * @param details - Optional additional details for logging
         33	 */
         34	export function notFound(message = 'Resource not found', details?: Record<string, any>): HttpError {
         35	  return new HttpError(message, 404, details);
         36	}
         37	
         38	/**
         39	 * Helper function to create a bad request error (400)
         40	 * @param message - Optional custom message
         41	 * @param details - Optional additional details for logging
         42	 */
         43	export function badRequest(message = 'Bad request', details?: Record<string, any>): HttpError {
         44	  return new HttpError(message, 400, details);
         45	}
         46	
         47	/**
         48	 * Helper function to create an unauthorized error (401)
         49	 * @param message - Optional custom message
         50	 * @param details - Optional additional details for logging
         51	 */
         52	export function unauthorized(message = 'Unauthorized', details?: Record<string, any>): HttpError {
         53	  return new HttpError(message, 401, details);
         54	}
         55	
         56	/**
         57	 * Helper function to create a forbidden error (403)
         58	 * @param message - Optional custom message
         59	 * @param details - Optional additional details for logging
         60	 */
         61	export function forbidden(message = 'Forbidden', details?: Record<string, any>): HttpError {
         62	  return new HttpError(message, 403, details);
         63	}
         64	
         65	/**
         66	 * Helper function to create a conflict error (409)
         67	 * @param message - Optional custom message
         68	 * @param details - Optional additional details for logging
         69	 */
         70	export function conflict(message = 'Conflict', details?: Record<string, any>): HttpError {
         71	  return new HttpError(message, 409, details);
         72	}
         73	
         74	/**
         75	 * Helper function to create a server error (500)
         76	 * @param message - Optional custom message
         77	 * @param details - Optional additional details for logging
         78	 */
         79	export function serverError(message = 'Internal server error', details?: Record<string, any>): HttpError {
         80	  return new HttpError(message, 500, details);
         81	}

==============================================
FILE: ./backend/src/utils/logger.ts
==============================================

          1	import winston from 'winston';
          2	
          3	const { combine, timestamp, json, errors } = winston.format;
          4	
          5	const logger = winston.createLogger({
          6	  level: process.env.LOG_LEVEL || 'info', // Default to 'info', can be configured via env var
          7	  format: combine(
          8	    timestamp(), // Add timestamp
          9	    errors({ stack: true }), // Log stack trace if available
         10	    json() // Log in JSON format
         11	  ),
         12	  transports: [
         13	    new winston.transports.Console(), // Log to the console
         14	    // TODO: Add file transport for production logging if needed later
         15	    // new winston.transports.File({ filename: 'error.log', level: 'error' }),
         16	    // new winston.transports.File({ filename: 'combined.log' }),
         17	  ],
         18	  exceptionHandlers: [
         19	    // Log unhandled exceptions to the console as well
         20	    new winston.transports.Console(),
         21	    // TODO: Add file transport for unhandled exceptions if needed
         22	    // new winston.transports.File({ filename: 'exceptions.log' })
         23	  ],
         24	  rejectionHandlers: [
         25	    // Log unhandled promise rejections
         26	    new winston.transports.Console(),
         27	    // TODO: Add file transport for unhandled rejections if needed
         28	    // new winston.transports.File({ filename: 'rejections.log' })
         29	  ],
         30	  exitOnError: false, // Do not exit on handled exceptions
         31	});
         32	
         33	// Stream for morgan logging (optional, can integrate later if needed)
         34	// logger.stream = {
         35	//   write: (message) => {
         36	//     logger.info(message.trim());
         37	//   },
         38	// };
         39	
         40	export default logger;

==============================================
FILE: ./backend/tsconfig.json
==============================================

          1	{
          2	  "extends": "../tsconfig.json",
          3	  "compilerOptions": {
          4	    "outDir": "dist",
          5	    "rootDir": ".",
          6	    "typeRoots": ["node_modules/@types", "src/types"],
          7	    "types": ["node", "jest"] // Add jest types here
          8	  },
          9	  "include": ["src", "prisma"]
         10	}


==============================================
FILE: ./concat_all_files.sh
==============================================

          1	#!/bin/bash
          2	
          3	# Script to concatenate all project files into one giant text file
          4	# Preserves file paths and adds line numbers to content
          5	
          6	OUTPUT_FILE="all_project_files.txt"
          7	echo "Concatenating all project files into $OUTPUT_FILE"
          8	
          9	# Clear or create the output file
         10	> "$OUTPUT_FILE"
         11	
         12	# Find all files in the project directory, excluding node_modules and git directories
         13	find . -type f \
         14	  ! -path "*/node_modules/*" \
         15	  ! -path "*/.git/*" \
         16	  ! -path "*/build/*" \
         17	  ! -path "*/dist/*" \
         18	  ! -path "$OUTPUT_FILE" \
         19	  | sort | while read -r file; do
         20	  
         21	  echo "Processing: $file"
         22	  
         23	  # Add a header with the file path
         24	  echo "" >> "$OUTPUT_FILE"
         25	  echo "==============================================" >> "$OUTPUT_FILE"
         26	  echo "FILE: $file" >> "$OUTPUT_FILE"
         27	  echo "==============================================" >> "$OUTPUT_FILE"
         28	  echo "" >> "$OUTPUT_FILE"
         29	
         30	  # If it's a text file, add it with line numbers
         31	  if file "$file" | grep -q text; then
         32	    # Add line numbers to the file content
         33	    nl -ba "$file" | sed 's/^/     /' >> "$OUTPUT_FILE"
         34	    echo "" >> "$OUTPUT_FILE"
         35	  else
         36	    # For binary files, just note that it's binary
         37	    echo "     [Binary file, content omitted]" >> "$OUTPUT_FILE"
         38	    echo "" >> "$OUTPUT_FILE"
         39	  fi
         40	done
         41	
         42	# Add summary
         43	echo "Done! All files have been concatenated to $OUTPUT_FILE"
         44	filesize=$(du -h "$OUTPUT_FILE" | cut -f1)
         45	echo "Total size: $filesize"

==============================================
FILE: ./docker-compose.yml
==============================================

          1	version: '3.8'
          2	services:
          3	  postgres:
          4	    image: postgres:15
          5	    environment:
          6	      POSTGRES_USER: user
          7	      POSTGRES_PASSWORD: pass
          8	      POSTGRES_DB: ndne
          9	    ports:
         10	      - "5432:5432"
         11	    volumes:
         12	      - pgdata:/var/lib/postgresql/data
         13	  redis:
         14	    image: redis:7
         15	    ports:
         16	      - "6379:6379"
         17	  backend:
         18	    image: node:18
         19	    working_dir: /app
         20	    volumes:
         21	      - ./backend:/app
         22	      - /app/node_modules
         23	      - ./tsconfig.json:/tsconfig.json:ro
         24	    ports:
         25	      - "4000:4000"
         26	    command: sh -c "npm install && npm run dev"
         27	    environment:
         28	      DB_URL: postgres://user:pass@postgres:5432/ndne
         29	      REDIS_URL: redis://redis:6379
         30	      JWT_SECRET: your_jwt_secret
         31	      CORS_ORIGINS: http://localhost:5173,http://localhost:5174
         32	  frontend:
         33	    image: node:18
         34	    working_dir: /app
         35	    volumes:
         36	      - ./frontend:/app
         37	      - /app/node_modules
         38	    ports:
         39	      - "5173:5173"
         40	    command: sh -c "npm install && npm run dev"
         41	    depends_on:
         42	      - backend
         43	volumes:
         44	  pgdata:


==============================================
FILE: ./frontend/cypress/e2e/dashboard.cy.ts
==============================================

          1	describe('Dashboard and Chat Integration', () => {
          2	  beforeEach(() => {
          3	    // Mock the auth state
          4	    cy.intercept('GET', '/api/agents/me', {
          5	      statusCode: 200,
          6	      body: {
          7	        id: 'test-agent-id',
          8	        name: 'Test Agent',
          9	        agentName: 'Praxis',
         10	        userName: 'Test User',
         11	        color: '#4299e1',
         12	        alignmentScore: 0.85,
         13	      },
         14	    }).as('getAgent');
         15	
         16	    // Mock the issues data
         17	    cy.intercept('GET', '/api/issues/user', {
         18	      statusCode: 200,
         19	      body: [
         20	        {
         21	          id: 'issue-1',
         22	          title: 'Climate Change',
         23	          description: 'Policies to address climate change',
         24	          stance: 'Supportive',
         25	          isPriority: true,
         26	        },
         27	        {
         28	          id: 'issue-2',
         29	          title: 'Healthcare',
         30	          description: 'Universal healthcare coverage',
         31	          stance: null,
         32	          isPriority: false,
         33	        },
         34	      ],
         35	    }).as('getIssues');
         36	
         37	    // Visit the dashboard page (assuming a logged-in state)
         38	    cy.visit('/dashboard');
         39	    cy.wait('@getAgent');
         40	    cy.wait('@getIssues');
         41	  });
         42	
         43	  it('should navigate between tabs and correctly update content', () => {
         44	    // Verify we start on positions tab
         45	    cy.contains('Positions Matrix').should('have.class', 'active');
         46	    cy.contains('This is where your positions live').should('be.visible');
         47	
         48	    // Switch to activity tab
         49	    cy.contains('button', 'Activity Audit').click();
         50	    cy.contains('Activity Audit').should('have.class', 'active');
         51	    cy.contains('This is a record of all actions').should('be.visible');
         52	
         53	    // Switch to proposals tab
         54	    cy.contains('button', 'Proposals').click();
         55	    cy.contains('Proposals').should('have.class', 'active');
         56	    cy.contains('this is where your ideas take shape').should('be.visible');
         57	
         58	    // Switch back to positions tab
         59	    cy.contains('button', 'Positions Matrix').click();
         60	    cy.contains('Positions Matrix').should('have.class', 'active');
         61	  });
         62	
         63	  it('should open chat panel when clicking discuss buttons', () => {
         64	    // The chat panel should be minimized initially
         65	    cy.get('.agent-chat-panel.minimized').should('exist');
         66	
         67	    // On positions tab, click "Discuss a New Issue"
         68	    cy.contains('Discuss a New Issue').click();
         69	    
         70	    // Chat panel should be maximized
         71	    cy.get('.agent-chat-panel').should('exist');
         72	    cy.get('.agent-chat-panel.minimized').should('not.exist');
         73	    
         74	    // Minimize chat panel
         75	    cy.get('.minimize-button').click();
         76	    cy.get('.agent-chat-panel.minimized').should('exist');
         77	    
         78	    // Switch to activity tab
         79	    cy.contains('button', 'Activity Audit').click();
         80	    
         81	    // Find a Discuss button if it exists and click it
         82	    cy.get('body').then(($body) => {
         83	      if ($body.find('.discuss-button').length > 0) {
         84	        cy.get('.discuss-button').first().click();
         85	        
         86	        // Chat panel should be maximized again
         87	        cy.get('.agent-chat-panel.minimized').should('not.exist');
         88	      }
         89	    });
         90	  });
         91	
         92	  it('should maintain chat context when switching tabs', () => {
         93	    // Click "Discuss a New Issue" on positions tab
         94	    cy.contains('Discuss a New Issue').click();
         95	    
         96	    // Chat panel should show contextual help for positions
         97	    cy.get('.contextual-help-banner').contains('positions').should('be.visible');
         98	    
         99	    // Switch to proposals tab
        100	    cy.contains('button', 'Proposals').click();
        101	    
        102	    // Contextual help should update
        103	    cy.get('.contextual-help-banner').contains('proposals').should('be.visible');
        104	  });
        105	
        106	  it('should have proper mobile responsiveness', () => {
        107	    // Test on mobile viewport
        108	    cy.viewport('iphone-x');
        109	    
        110	    // Tabs should be scrollable
        111	    cy.get('.dashboard-tabs').should('have.css', 'overflow-x', 'auto');
        112	    
        113	    // Agent status panel should stack vertically
        114	    cy.get('.agent-status-panel').should('have.css', 'flex-direction', 'column');
        115	    
        116	    // Check if the buttons take full width
        117	    cy.get('.pause-button').invoke('outerWidth').should('be.closeTo', 
        118	      cy.get('.agent-status-panel').invoke('outerWidth').then(parseInt), 10);
        119	  });
        120	});

==============================================
FILE: ./frontend/cypress/e2e/negotiation.cy.ts
==============================================

          1	describe("Negotiation Thread E2E", () => {
          2	  beforeEach(() => {
          3	    // Assume user is already authenticated for this test
          4	    cy.visit("/negotiations");
          5	  });
          6	
          7	  it("should display the negotiation list and allow viewing a thread", () => {
          8	    cy.contains("All Negotiations");
          9	    cy.get("ul[aria-label='Negotiation Sessions'] li").first().within(() => {
         10	      cy.contains("View Thread").click();
         11	    });
         12	    cy.contains("Negotiation Thread");
         13	  });
         14	
         15	  it("should allow posting a message to join a negotiation", () => {
         16	    cy.get("ul[aria-label='Negotiation Sessions'] li").first().within(() => {
         17	      cy.contains("View Thread").click();
         18	    });
         19	    cy.get("textarea[aria-label='Type your message']").type("Hello, joining this negotiation!");
         20	    cy.get("button[aria-label='Send message']").click();
         21	    cy.contains("Message posted!");
         22	    cy.contains("Hello, joining this negotiation!");
         23	  });
         24	
         25	  it("should allow adding and removing a reaction", () => {
         26	    cy.get("ul[aria-label='Negotiation Sessions'] li").first().within(() => {
         27	      cy.contains("View Thread").click();
         28	    });
         29	    cy.get(".negotiation-message").first().within(() => {
         30	      cy.contains("👍").click();
         31	      cy.contains("Reaction added!");
         32	      cy.contains("👍 1");
         33	      cy.contains("👍").click();
         34	      cy.contains("Reaction removed.");
         35	    });
         36	  });
         37	});

==============================================
FILE: ./frontend/cypress/e2e/onboarding.cy.ts
==============================================

          1	describe('Onboarding Flow', () => {
          2	  beforeEach(() => {
          3	    // Create test user and log in (assumes custom Cypress commands exist)
          4	    cy.createTestUser();
          5	    cy.login();
          6	  });
          7	
          8	  it('should complete all onboarding steps', () => {
          9	    // Step 0: Provide agent name
         10	    cy.findByRole('textbox').type('Spark{enter}');
         11	
         12	    // Step 1: Select issues
         13	    cy.findByText(/Here are the issues/i).should('be.visible');
         14	    cy.findByRole('textbox').type('1,3{enter}');
         15	
         16	    // Step 2: Provide stance on first issue
         17	    cy.findByText(/SUPPORT, OPPOSE, or DEPENDS/i).should('be.visible');
         18	    cy.findByRole('textbox').type('Support, clean water is essential{enter}');
         19	
         20	    // Step 2: Provide stance on second issue
         21	    cy.findByText(/SUPPORT, OPPOSE, or DEPENDS/i).should('be.visible');
         22	    cy.findByRole('textbox').type('Oppose, too expensive{enter}');
         23	
         24	    // Step 3: Top priority
         25	    cy.findByText(/which ONE matters most/i).should('be.visible');
         26	    cy.findByRole('textbox').type('Clean water{enter}');
         27	
         28	    // Step 4: Deal-breakers
         29	    cy.findByText(/absolutely could NOT accept/i).should('be.visible');
         30	    cy.findByRole('textbox').type('Cost increases over 10%{enter}');
         31	
         32	    // Step 5: Display color
         33	    cy.findByText(/highlight color/i).should('be.visible');
         34	    cy.findByRole('textbox').type('blue{enter}');
         35	
         36	    // Step 6: Notification preference
         37	    cy.findByText(/How often should I brief you/i).should('be.visible');
         38	    cy.findByRole('textbox').type('B{enter}');
         39	
         40	    // Step 7: Proposal idea
         41	    cy.findByText(/Any idea or proposal/i).should('be.visible');
         42	    cy.findByRole('textbox').type('Explore community-funded water project{enter}');
         43	
         44	    // Step 8: Summary and completion
         45	    cy.findByText(/All set!/i).should('be.visible');
         46	
         47	    // Verify redirection to dashboard
         48	    cy.url().should('include', '/dashboard');
         49	  });
         50	});

==============================================
FILE: ./frontend/index.html
==============================================

          1	<!doctype html>
          2	<html lang="en">
          3	  <head>
          4	    <meta charset="UTF-8" />
          5	    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
          6	    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          7	    <title>NDNE Prototype</title>
          8	  </head>
          9	  <body>
         10	    <div id="root"></div>
         11	    <script type="module" src="/src/main.tsx"></script>
         12	  </body>
         13	</html>

==============================================
FILE: ./frontend/package-lock.json
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./frontend/package.json
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./frontend/src/App.tsx
==============================================

          1	import React from 'react';
          2	import { BrowserRouter as Router, Routes, Route, Link, Navigate } from 'react-router-dom';
          3	import { AuthProvider, useAuth } from './context/AuthContext';
          4	import OnboardingChat from './components/OnboardingChat';
          5	import DashboardPage from './pages/DashboardPage';
          6	import LoginPage from './pages/LoginPage';
          7	import RegisterPage from './pages/RegisterPage';
          8	import ProposalList from './pages/ProposalList';
          9	import ProposalDetail from './pages/ProposalDetail';
         10	import NegotiationList from './components/NegotiationList';
         11	import { agents } from './api/apiClient';
         12	import NewProposalForm from './components/NewProposalForm';
         13	import FeedbackModal from './components/FeedbackModal';
         14	
         15	// Temporary placeholders for missing pages
         16	const SettingsPage = () => <div>Settings Placeholder</div>;
         17	const AdminPanel = () => <div>Admin Panel Placeholder</div>;
         18	
         19	// AppRoutes component to use auth context
         20	const AppRoutes: React.FC = () => {
         21	  const { isAuthenticated, loading } = useAuth();
         22	  const [agentId, setAgentId] = React.useState<string | null>(null);
         23	  const [feedbackOpen, setFeedbackOpen] = React.useState(false);
         24	
         25	  React.useEffect(() => {
         26	    if (isAuthenticated) {
         27	      agents.getAgent()
         28	        .then(res => setAgentId(res.data.id))
         29	        .catch(() => setAgentId(null));
         30	    }
         31	  }, [isAuthenticated]);
         32	
         33	  // Show loading indicator while checking auth
         34	  if (loading) {
         35	    return <div className="loading">Loading...</div>;
         36	  }
         37	
         38	  return (
         39	    <>
         40	      <nav>
         41	        <ul>
         42	          {isAuthenticated ? (
         43	            <>
         44	              <li><Link to="/dashboard">Dashboard</Link></li>
         45	              <li><Link to="/proposals">Proposals</Link></li>
         46	              <li><Link to="/negotiations">Negotiations</Link></li>
         47	              <li><Link to="/settings">Settings</Link></li>
         48	              {/* Admin link could be conditionally shown based on user role */}
         49	            </>
         50	          ) : (
         51	            <>
         52	              <li><Link to="/login">Login</Link></li>
         53	              <li><Link to="/register">Register</Link></li>
         54	            </>
         55	          )}
         56	        </ul>
         57	      </nav>
         58	      <hr />
         59	      <main>
         60	        <Routes>
         61	          {/* Redirect root to login or dashboard based on auth */}
         62	          <Route path="/" element={isAuthenticated ? <Navigate to="/dashboard" /> : <Navigate to="/login" />} />
         63	          <Route path="/login" element={isAuthenticated ? <Navigate to="/dashboard" /> : <LoginPage />} />
         64	          <Route path="/register" element={isAuthenticated ? <Navigate to="/dashboard" /> : <RegisterPage />} />
         65	          <Route path="/onboarding" element={isAuthenticated ? <OnboardingChat /> : <Navigate to="/login" />} />
         66	          {/* Protected Routes */}
         67	          <Route path="/dashboard" element={isAuthenticated ? <DashboardPage /> : <Navigate to="/login" />} />
         68	          <Route path="/proposals" element={isAuthenticated ? <ProposalList /> : <Navigate to="/login" />} />
         69	          <Route path="/proposal/:id" element={isAuthenticated ? <ProposalDetail /> : <Navigate to="/login" />} />
         70	          <Route path="/proposal/new" element={isAuthenticated ? <NewProposalForm /> : <Navigate to="/login" />} />
         71	          <Route path="/negotiations" element={isAuthenticated && agentId ? <NegotiationList agentId={agentId} /> : <Navigate to="/login" />} />
         72	          <Route path="/settings" element={isAuthenticated ? <SettingsPage /> : <Navigate to="/login" />} />
         73	          <Route path="/admin" element={isAuthenticated ? <AdminPanel /> : <Navigate to="/login" />} />
         74	          {/* Add a 404 or catch-all route */}
         75	          <Route path="*" element={<div>404 Not Found</div>} />
         76	        </Routes>
         77	      </main>
         78	      <hr />
         79	      <footer>
         80	        <small>
         81	          <a href="/tos" target="_blank" rel="noopener noreferrer">Terms of Service</a> |{' '}
         82	          <a href="/privacy" target="_blank" rel="noopener noreferrer">Privacy Policy</a> |{' '}
         83	          <button
         84	            style={{ background: "none", border: "none", color: "blue", textDecoration: "underline", cursor: "pointer", padding: 0 }}
         85	            onClick={() => setFeedbackOpen(true)}
         86	            aria-label="Open Feedback Form"
         87	          >
         88	            Feedback
         89	          </button>
         90	        </small>
         91	      </footer>
         92	      <FeedbackModal isOpen={feedbackOpen} onClose={() => setFeedbackOpen(false)} />
         93	    </>
         94	  );
         95	};
         96	
         97	const App: React.FC = () => {
         98	  return (
         99	    <Router>
        100	      <AuthProvider>
        101	        <AppRoutes />
        102	      </AuthProvider>
        103	    </Router>
        104	  );
        105	};
        106	
        107	export default App;

==============================================
FILE: ./frontend/src/api/apiClient.ts
==============================================

          1	import axios from 'axios';
          2	
          3	// Create API client with base URL
          4	const apiClient = axios.create({
          5	  baseURL: 'http://localhost:4000/api',
          6	  headers: {
          7	    'Content-Type': 'application/json',
          8	  },
          9	});
         10	
         11	// Add request interceptor for authentication
         12	apiClient.interceptors.request.use((config) => {
         13	  const token = localStorage.getItem('token');
         14	  if (token) {
         15	    config.headers.Authorization = `Bearer ${token}`;
         16	  }
         17	  return config;
         18	});
         19	
         20	// Add response interceptor for error handling
         21	apiClient.interceptors.response.use(
         22	  (response) => response,
         23	  (error) => {
         24	    // Handle network errors
         25	    if (!error.response) {
         26	      console.error('Network Error:', error.message);
         27	      console.error('Request details:', {
         28	        url: error.config?.url,
         29	        method: error.config?.method,
         30	        headers: error.config?.headers,
         31	      });
         32	      return Promise.reject({
         33	        status: 'error',
         34	        message: 'Network error. Please check your connection and try again.',
         35	        originalError: error,
         36	      });
         37	    }
         38	
         39	    // Handle API errors
         40	    const { status, data } = error.response;
         41	    
         42	    console.error('API Error Response:', {
         43	      status,
         44	      data,
         45	      url: error.config?.url,
         46	      method: error.config?.method
         47	    });
         48	    
         49	    let errorMessage = 'An unexpected error occurred';
         50	    
         51	    if (data?.error) {
         52	      errorMessage = data.error;
         53	    } else if (data?.message) {
         54	      errorMessage = data.message;
         55	    }
         56	    
         57	    // Handle auth errors
         58	    if (status === 401) {
         59	      console.log('Authentication error detected, clearing token');
         60	      // Clear token if unauthorized
         61	      localStorage.removeItem('token');
         62	      
         63	      // Redirect to login if not already there
         64	      if (window.location.pathname !== '/login') {
         65	        window.location.href = '/login';
         66	      }
         67	    }
         68	    
         69	    return Promise.reject({
         70	      status: 'error',
         71	      message: errorMessage,
         72	      code: status,
         73	      originalError: error,
         74	    });
         75	  }
         76	);
         77	
         78	// API endpoints
         79	export const auth = {
         80	  register: (data: { email: string; password: string }) => {
         81	    console.log('[DEBUG-API-FIX] Sending registration request:', { email: data.email });
         82	    return apiClient.post('/auth/register', data)
         83	      .then(response => {
         84	        console.log('[DEBUG-API-FIX] Registration successful:', response.data ? {
         85	          tokenReceived: !!response.data.token,
         86	          tokenLength: response.data.token ? response.data.token.length : 0,
         87	          tokenStart: response.data.token ? `${response.data.token.substring(0, 15)}...` : 'null'
         88	        } : 'No data');
         89	        return response;
         90	      })
         91	      .catch(error => {
         92	        console.error('[DEBUG-API-FIX] Registration failed:', error);
         93	        // Log more detailed error information
         94	        if (error.originalError?.response) {
         95	          console.error('[DEBUG-API-FIX] Server response:', {
         96	            status: error.originalError.response.status,
         97	            data: error.originalError.response.data
         98	          });
         99	        } else {
        100	          console.error('[DEBUG-API-FIX] Error details:', JSON.stringify(error));
        101	        }
        102	        throw error;
        103	      });
        104	  },
        105	  
        106	  login: (data: { email: string; password: string }) => {
        107	    console.log('[DEBUG-API-FIX] Sending login request:', { email: data.email });
        108	    return apiClient.post('/auth/login', data)
        109	      .then(response => {
        110	        console.log('[DEBUG-API-FIX] Login successful, token received:', !!response.data.token);
        111	        return response;
        112	      })
        113	      .catch(error => {
        114	        console.error('[DEBUG-API-FIX] Login failed:', error);
        115	        if (error.originalError?.response) {
        116	          console.error('[DEBUG-API-FIX] Server response:', {
        117	            status: error.originalError.response.status,
        118	            data: error.originalError.response.data
        119	          });
        120	        }
        121	        throw error;
        122	      });
        123	  },
        124	  
        125	  getUser: () => {
        126	    const token = localStorage.getItem('token');
        127	    console.log('[DEBUG-API-FIX] Fetching user data with token:', token ? `${token.substring(0, 15)}...` : 'none');
        128	    return apiClient.get('/auth/me')
        129	      .then(response => {
        130	        console.log('[DEBUG-API-FIX] User data retrieved successfully:', response.data ? {
        131	          id: response.data.id,
        132	          email: response.data.email,
        133	          agentExists: !!response.data.agent
        134	        } : 'No data');
        135	        return response;
        136	      })
        137	      .catch(error => {
        138	        console.error('[DEBUG-API-FIX] Failed to fetch user data:', error);
        139	        if (error.originalError?.response) {
        140	          console.error('[DEBUG-API-FIX] Server response:', {
        141	            status: error.originalError.response.status,
        142	            data: error.originalError.response.data
        143	          });
        144	        }
        145	        throw error;
        146	      });
        147	  },
        148	};
        149	
        150	export const agents = {
        151	  getAgent: () =>
        152	    apiClient.get('/agents/me'),
        153	  
        154	  updatePreferences: (preferences: any) =>
        155	    apiClient.put('/agents/me/preferences', { preferences }),
        156	  
        157	  pauseAgent: (until: Date) =>
        158	    apiClient.post(`/agents/me/pause`, { until: until.toISOString() }),
        159	  
        160	  feedback: (agentId: string, data: { voteId?: string; commentId?: string; reason: string }) =>
        161	    apiClient.post(`/agents/${agentId}/feedback`, data)
        162	};
        163	
        164	// Comments API already defined above
        165	
        166	export const proposals = {
        167	  getAll: () =>
        168	    apiClient.get('/proposals'),
        169	  
        170	  getById: (id: string) =>
        171	    apiClient.get(`/proposals/${id}`),
        172	  
        173	  create: (data: any) =>
        174	    apiClient.post('/proposals', data),
        175	  
        176	  vote: (proposalId: string, data: { value: string; confidence: number }) =>
        177	    apiClient.post(`/proposals/${proposalId}/vote`, data),
        178	  
        179	  withdraw: (proposalId: string) =>
        180	    apiClient.post(`/proposals/${proposalId}/withdraw`),
        181	};
        182	
        183	export const comments = {
        184	  create: (data: { proposalId: string; content: string }) =>
        185	    apiClient.post('/comments', data),
        186	};
        187	
        188	export const onboarding = {
        189	  saveStep: (step: number, data: any) => 
        190	    apiClient.post(`/onboarding/steps/${step}`, data),
        191	};
        192	
        193	export const chat = {
        194	  sendMessage: (data: { agentId: string; content: string; metadata?: any }) =>
        195	    apiClient.post('/chat/messages', data),
        196	  
        197	  getMessages: (agentId: string, params?: { limit?: number; before?: string; onboarding?: boolean }) =>
        198	    apiClient.get('/chat/messages', { params: { agentId, ...params } }),
        199	  
        200	  getMessage: (id: string) =>
        201	    apiClient.get(`/chat/messages/${id}`),
        202	  
        203	  deleteMessage: (id: string) =>
        204	    apiClient.delete(`/chat/messages/${id}`),
        205	};
        206	
        207	export const negotiations = {
        208	  // Get all negotiation sessions
        209	  getAll: () => apiClient.get('/negotiations'),
        210	
        211	  // Get a single negotiation session
        212	  getById: (id: string) => apiClient.get(`/negotiations/${id}`),
        213	
        214	  // Create a new negotiation session
        215	  create: (data: { topic: string; description?: string; initiatorId: string }) =>
        216	    apiClient.post('/negotiations', data),
        217	
        218	  // Get all messages for a negotiation (with reactions)
        219	  getMessages: (negotiationId: string) =>
        220	    apiClient.get(`/negotiations/${negotiationId}/messages`),
        221	
        222	  // Post a new message to a negotiation
        223	  postMessage: (
        224	    negotiationId: string,
        225	    data: {
        226	      agentId: string;
        227	      content: string;
        228	      messageType?: string;
        229	      referencedMessageId?: string;
        230	      metadata?: any;
        231	    }
        232	  ) => apiClient.post(`/negotiations/${negotiationId}/messages`, data),
        233	
        234	  // Add a reaction to a message
        235	  addReaction: (
        236	    negotiationId: string,
        237	    messageId: string,
        238	    data: { agentId: string; reactionType: string }
        239	  ) =>
        240	    apiClient.post(
        241	      `/negotiations/${negotiationId}/messages/${messageId}/reactions`,
        242	      data
        243	    ),
        244	
        245	  // Remove a reaction from a message
        246	  removeReaction: (
        247	    negotiationId: string,
        248	    messageId: string,
        249	    data: { agentId: string; reactionType: string }
        250	  ) =>
        251	    apiClient.delete(
        252	      `/negotiations/${negotiationId}/messages/${messageId}/reactions`,
        253	      { data }
        254	    ),
        255	};
        256	
        257	export default apiClient;

==============================================
FILE: ./frontend/src/components/AgentChatPanel.css
==============================================

          1	.agent-chat-panel {
          2	  border: 1px solid #e2e8f0;
          3	  border-radius: 8px;
          4	  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
          5	  width: 350px;
          6	  height: 500px;
          7	  display: flex;
          8	  flex-direction: column;
          9	  background-color: #fff;
         10	  transition: all 0.3s ease;
         11	  overflow: hidden;
         12	  position: fixed;
         13	  bottom: 20px;
         14	  right: 20px;
         15	  z-index: 1000;
         16	}
         17	
         18	.agent-chat-panel.minimized {
         19	  width: 200px;
         20	  height: 40px;
         21	  cursor: pointer;
         22	  border-width: 2px;
         23	}
         24	
         25	.chat-panel-header {
         26	  display: flex;
         27	  justify-content: space-between;
         28	  align-items: center;
         29	  padding: 0.75rem 1rem;
         30	  color: white;
         31	  border-top-left-radius: 7px;
         32	  border-top-right-radius: 7px;
         33	}
         34	
         35	.chat-panel-header h3 {
         36	  margin: 0;
         37	  font-size: 1rem;
         38	  white-space: nowrap;
         39	  overflow: hidden;
         40	  text-overflow: ellipsis;
         41	}
         42	
         43	.minimize-button {
         44	  background: none;
         45	  border: none;
         46	  color: white;
         47	  cursor: pointer;
         48	  padding: 0;
         49	  display: flex;
         50	  align-items: center;
         51	  justify-content: center;
         52	}
         53	
         54	.minimize-button:hover {
         55	  opacity: 0.8;
         56	}
         57	
         58	.chat-panel-body {
         59	  flex: 1;
         60	  overflow: hidden;
         61	  position: relative;
         62	}
         63	
         64	.minimized-header {
         65	  width: 100%;
         66	  height: 100%;
         67	  display: flex;
         68	  align-items: center;
         69	  justify-content: center;
         70	  color: white;
         71	  font-weight: 600;
         72	  transition: background-color 0.3s ease;
         73	}
         74	
         75	.unread-indicator {
         76	  position: absolute;
         77	  top: 8px;
         78	  right: 8px;
         79	  width: 8px;
         80	  height: 8px;
         81	  border-radius: 50%;
         82	  background-color: #e53e3e;
         83	}
         84	
         85	.loading-indicator {
         86	  display: flex;
         87	  align-items: center;
         88	  justify-content: center;
         89	  height: 100%;
         90	  color: #718096;
         91	}
         92	
         93	/* Responsive design for smaller screens */
         94	@media (max-width: 576px) {
         95	  .agent-chat-panel {
         96	    width: calc(100% - 40px);
         97	    bottom: 10px;
         98	    right: 10px;
         99	    height: 400px;
        100	  }
        101	  
        102	  .agent-chat-panel.minimized {
        103	    width: 150px;
        104	    bottom: 10px;
        105	    right: 10px;
        106	  }
        107	}

==============================================
FILE: ./frontend/src/components/AgentChatPanel.tsx
==============================================

          1	import React, { useState, useEffect } from 'react';
          2	import ChatInterface from './chat/ChatInterface';
          3	import { useDashboard } from '../context/DashboardContext';
          4	import { useChatContext } from '../hooks/useChatContext';
          5	import './AgentChatPanel.css';
          6	
          7	interface AgentChatPanelProps {
          8	  agentId: string;
          9	  minimized?: boolean;
         10	  onMinimize?: () => void;
         11	  onMaximize?: () => void;
         12	  contextualHelp?: 'positions' | 'activity' | 'proposals';
         13	  userName?: string; // Add user name prop
         14	}
         15	
         16	const AgentChatPanel: React.FC<AgentChatPanelProps> = ({
         17	  agentId,
         18	  minimized = false,
         19	  onMinimize,
         20	  onMaximize,
         21	  contextualHelp,
         22	  userName
         23	}) => {
         24	  // Get context from Dashboard and Chat contexts
         25	  const { currentTab, currentTabData } = useDashboard();
         26	  const { chatContext } = useChatContext();
         27	  const [agent, setAgent] = useState<{
         28	    name: string;
         29	    color: string;
         30	  } | null>(null);
         31	  const [loading, setLoading] = useState(true);
         32	  const [hasUnreadMessages, setHasUnreadMessages] = useState(false);
         33	
         34	  // Fetch agent details
         35	  useEffect(() => {
         36	    const fetchAgent = async () => {
         37	      try {
         38	        setLoading(true);
         39	        
         40	        // We're using a direct fetch here, but in a real implementation
         41	        // this would be part of the apiClient
         42	        const response = await fetch(`/api/agents/me`, {
         43	          headers: {
         44	            'Authorization': `Bearer ${localStorage.getItem('token')}`
         45	          }
         46	        });
         47	        
         48	        if (response.ok) {
         49	          const data = await response.json();
         50	          console.log("[DEBUG_NAMES] AgentChatPanel received agent data:", {
         51	            id: data.id,
         52	            name: data.name,           // This is agent's name
         53	            agentName: data.agentName, // This is now explicitly the agent's name
         54	            userName: data.userName,   // This is the user's name
         55	            propsUserName: userName    // This is what's passed down from parent
         56	          });
         57	          setAgent({
         58	            // Use the explicit agentName if available, otherwise use name
         59	            name: data.agentName || data.name || 'Agent',
         60	            color: data.color || '#007bff'
         61	          });
         62	        } else {
         63	        }
         64	      } catch (error) {
         65	      } finally {
         66	        setLoading(false);
         67	      }
         68	    };
         69	    
         70	    fetchAgent();
         71	  }, [agentId]);
         72	
         73	  // This would be connected to a real-time notification system in a full implementation
         74	  useEffect(() => {
         75	    // Simulating checking for unread messages every 30 seconds
         76	    const checkForUnreadMessages = () => {
         77	      // This is a placeholder. In a real implementation, you would
         78	      // check for unread messages from the server
         79	      setHasUnreadMessages(false);
         80	    };
         81	    
         82	    const interval = setInterval(checkForUnreadMessages, 30000);
         83	    
         84	    return () => clearInterval(interval);
         85	  }, [agentId]);
         86	
         87	  if (loading) {
         88	    return (
         89	      <div className={`agent-chat-panel ${minimized ? 'minimized' : ''}`}>
         90	        <div className="loading-indicator">Loading chat...</div>
         91	      </div>
         92	    );
         93	  }
         94	
         95	  if (minimized) {
         96	    return (
         97	      <div 
         98	        className="agent-chat-panel minimized"
         99	        onClick={onMaximize}
        100	        style={{ 
        101	          borderColor: agent?.color || '#007bff'
        102	        }}
        103	      >
        104	        <div className="minimized-header" style={{ backgroundColor: agent?.color || '#007bff' }}>
        105	          <span>{agent?.name ? `${agent.name} (Agent)` : 'Agent'}</span> {/* Agent name displayed in minimized state */}
        106	        </div>
        107	        {hasUnreadMessages && <div className="unread-indicator" />}
        108	      </div>
        109	    );
        110	  }
        111	
        112	  // Function to render a contextual header based on the current tab and selected items
        113	  const renderContextualHeader = () => {
        114	    if (!currentTabData) return null;
        115	    
        116	    // Different header content based on current tab and selected items
        117	    switch (currentTab) {
        118	      case 'positions':
        119	        if (currentTabData.positions?.selectedIssue) {
        120	          const issue = currentTabData.positions.selectedIssue;
        121	          return (
        122	            <div className="contextual-chat-header">
        123	              <strong>Discussing Issue:</strong> {issue.title}
        124	              {issue.stance && <div className="stance-badge">Your stance: {issue.stance}</div>}
        125	            </div>
        126	          );
        127	        }
        128	        break;
        129	        
        130	      case 'activity':
        131	        if (currentTabData.activity?.selectedAction) {
        132	          const action = currentTabData.activity.selectedAction;
        133	          return (
        134	            <div className="contextual-chat-header">
        135	              <strong>Discussing Action:</strong> {action.type === 'vote' ? 'Vote' : 'Comment'} on "{action.proposalTitle}"
        136	              <div className="action-details">{action.actionDetails}</div>
        137	            </div>
        138	          );
        139	        }
        140	        break;
        141	        
        142	      case 'proposals':
        143	        if (currentTabData.proposals?.selectedProposal) {
        144	          const proposal = currentTabData.proposals.selectedProposal;
        145	          return (
        146	            <div className="contextual-chat-header">
        147	              <strong>Discussing Proposal:</strong> {proposal.title}
        148	              <div className="proposal-status">Status: {proposal.status}</div>
        149	            </div>
        150	          );
        151	        }
        152	        break;
        153	      
        154	      default:
        155	        return null;
        156	    }
        157	    
        158	    // Generic headers if no specific item is selected
        159	    if (currentTab === 'positions') {
        160	      return <div className="contextual-chat-header">Discussing your positions on issues</div>;
        161	    } else if (currentTab === 'activity') {
        162	      return <div className="contextual-chat-header">Discussing your recent activity</div>;
        163	    } else if (currentTab === 'proposals') {
        164	      return <div className="contextual-chat-header">Discussing proposals</div>;
        165	    }
        166	    
        167	    return null;
        168	  };
        169	
        170	  return (
        171	    <div className="agent-chat-panel">
        172	      <div
        173	        className="chat-panel-header"
        174	        style={{ backgroundColor: agent?.color || '#007bff' }}
        175	      >
        176	        <h3>{agent?.name ? `${agent.name} (Agent)` : 'Agent'}</h3> {/* Agent name displayed in maximized header */}
        177	        <button className="minimize-button" onClick={onMinimize}>
        178	          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        179	            <line x1="5" y1="12" x2="19" y2="12"></line>
        180	          </svg>
        181	        </button>
        182	      </div>
        183	      <div className="chat-panel-body">
        184	        {/* Context-aware header based on selected item */}
        185	        {renderContextualHeader()}
        186	        
        187	        {/* Original contextual help banner */}
        188	        {contextualHelp && (
        189	          <div className="contextual-help-banner" style={{ backgroundColor: agent?.color ? `${agent.color}22` : '#007bff22' }}>
        190	            <p>
        191	              {contextualHelp === 'positions' && 'Need help with your positions matrix? Ask me about any issue or how to update your stance.'}
        192	              {contextualHelp === 'activity' && 'Questions about your agent activity? I can explain any action or help you understand what happened.'}
        193	              {contextualHelp === 'proposals' && 'Want assistance with proposals? I can help you create, edit, or review your proposals.'}
        194	            </p>
        195	          </div>
        196	        )}
        197	        <ChatInterface
        198	          agentId={agentId}
        199	          agentName={agent?.name || 'Agent'}
        200	          userName={userName}
        201	          agentColor={agent?.color}
        202	        />
        203	        {/* Debug information - visible only in development */}
        204	        {process.env.NODE_ENV !== 'production' && (
        205	          <div style={{fontSize: '10px', background: '#f5f5f5', padding: '4px', color: '#666'}}>
        206	            DEBUG: Agent name: {agent?.name}, User name: {userName}
        207	          </div>
        208	        )}
        209	      </div>
        210	    </div>
        211	  );
        212	};
        213	
        214	export default AgentChatPanel;
        215	
        216	// Add CSS for the contextual help banner and contextual header
        217	const style = document.createElement('style');
        218	style.textContent = `
        219	  .contextual-help-banner {
        220	    padding: 10px 15px;
        221	    margin: 0 0 15px 0;
        222	    border-radius: 8px;
        223	    font-size: 0.9rem;
        224	  }
        225	  
        226	  .contextual-help-banner p {
        227	    margin: 0;
        228	  }
        229	  
        230	  .contextual-chat-header {
        231	    padding: 10px 12px;
        232	    margin: 0 0 15px 0;
        233	    border-radius: 6px;
        234	    background-color: #f8f9fa;
        235	    border-left: 4px solid #4299E1;
        236	    font-size: 0.95rem;
        237	  }
        238	  
        239	  .contextual-chat-header strong {
        240	    display: block;
        241	    font-size: 0.8rem;
        242	    text-transform: uppercase;
        243	    margin-bottom: 4px;
        244	    color: #4a5568;
        245	  }
        246	  
        247	  .stance-badge {
        248	    display: inline-block;
        249	    background-color: #ebf4ff;
        250	    color: #4299E1;
        251	    padding: 2px 6px;
        252	    border-radius: 4px;
        253	    margin-top: 5px;
        254	    font-size: 0.8rem;
        255	  }
        256	  
        257	  .action-details, .proposal-status {
        258	    font-size: 0.85rem;
        259	    color: #718096;
        260	    margin-top: 3px;
        261	  }
        262	`;
        263	document.head.appendChild(style);

==============================================
FILE: ./frontend/src/components/FeedbackModal.tsx
==============================================

          1	import React, { useState } from "react";
          2	
          3	interface FeedbackModalProps {
          4	  isOpen: boolean;
          5	  onClose: () => void;
          6	}
          7	
          8	const FeedbackModal: React.FC<FeedbackModalProps> = ({ isOpen, onClose }) => {
          9	  const [feedback, setFeedback] = useState("");
         10	  const [submitted, setSubmitted] = useState(false);
         11	
         12	  const handleSubmit = (e: React.FormEvent) => {
         13	    e.preventDefault();
         14	    // TODO: Send feedback to backend or log it
         15	    setSubmitted(true);
         16	    setTimeout(() => {
         17	      setFeedback("");
         18	      setSubmitted(false);
         19	      onClose();
         20	    }, 1500);
         21	  };
         22	
         23	  if (!isOpen) return null;
         24	
         25	  return (
         26	    <div
         27	      className="feedback-modal"
         28	      role="dialog"
         29	      aria-modal="true"
         30	      aria-label="Feedback Form"
         31	      style={{
         32	        position: "fixed",
         33	        top: 0, left: 0, right: 0, bottom: 0,
         34	        background: "rgba(0,0,0,0.4)",
         35	        display: "flex",
         36	        alignItems: "center",
         37	        justifyContent: "center",
         38	        zIndex: 1000,
         39	      }}
         40	      onClick={onClose}
         41	    >
         42	      <div
         43	        className="feedback-modal-content"
         44	        style={{
         45	          background: "#fff",
         46	          padding: "2rem",
         47	          borderRadius: "8px",
         48	          minWidth: "300px",
         49	          maxWidth: "90vw",
         50	        }}
         51	        onClick={e => e.stopPropagation()}
         52	      >
         53	        <h2>Submit Feedback</h2>
         54	        <form onSubmit={handleSubmit}>
         55	          <textarea
         56	            value={feedback}
         57	            onChange={e => setFeedback(e.target.value)}
         58	            placeholder="Describe your issue or suggestion..."
         59	            rows={5}
         60	            style={{ width: "100%" }}
         61	            aria-label="Feedback"
         62	            required
         63	          />
         64	          <div style={{ marginTop: "1rem" }}>
         65	            <button type="submit" disabled={submitted || !feedback.trim()}>
         66	              {submitted ? "Submitted!" : "Submit"}
         67	            </button>
         68	            <button type="button" onClick={onClose} style={{ marginLeft: "1rem" }}>
         69	              Cancel
         70	            </button>
         71	          </div>
         72	        </form>
         73	      </div>
         74	    </div>
         75	  );
         76	};
         77	
         78	export default FeedbackModal;

==============================================
FILE: ./frontend/src/components/IssuesMatrix.css
==============================================

          1	.issues-matrix-container {
          2	  margin: 1rem 0;
          3	  position: relative;
          4	}
          5	
          6	.issues-matrix {
          7	  margin: 0;
          8	  padding: 1rem;
          9	  background-color: #f7fafc;
         10	  border-radius: 0.5rem;
         11	  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
         12	  transition: all 0.3s ease;
         13	  max-width: 100%;
         14	  min-height: 150px;
         15	}
         16	
         17	.issues-matrix-heading {
         18	  font-size: 1.1rem;
         19	  font-weight: 600;
         20	  margin-top: 0;
         21	  margin-bottom: 1rem;
         22	  color: #2d3748;
         23	  border-bottom: 1px solid #e2e8f0;
         24	  padding-bottom: 0.5rem;
         25	}
         26	
         27	.issues-matrix-content {
         28	  max-height: 300px;
         29	  overflow-y: auto;
         30	}
         31	
         32	.issues-list {
         33	  list-style: none;
         34	  padding: 0;
         35	  margin: 0;
         36	  display: grid;
         37	  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
         38	  gap: 1rem;
         39	}
         40	
         41	.issue-item {
         42	  padding: 0.75rem;
         43	  background-color: white;
         44	  border-radius: 0.375rem;
         45	  border: 1px solid #e2e8f0;
         46	  transition: all 0.2s ease;
         47	  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
         48	}
         49	
         50	.issue-item:hover {
         51	  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
         52	  transform: translateY(-2px);
         53	}
         54	
         55	.priority-issue {
         56	  border-width: 2px;
         57	  border-style: solid;
         58	  position: relative;
         59	}
         60	
         61	.issue-header {
         62	  display: flex;
         63	  justify-content: space-between;
         64	  align-items: center;
         65	  margin-bottom: 0.5rem;
         66	}
         67	
         68	.issue-title {
         69	  font-weight: 500;
         70	  line-height: 1.2;
         71	  color: #1a202c;
         72	}
         73	
         74	.issue-stance {
         75	  font-size: 0.75rem;
         76	  font-weight: 600;
         77	  padding: 0.25rem 0.5rem;
         78	  border-radius: 9999px;
         79	  color: white;
         80	  text-transform: uppercase;
         81	}
         82	
         83	.stance-support {
         84	  background-color: #48BB78;
         85	}
         86	
         87	.stance-oppose {
         88	  background-color: #F56565;
         89	}
         90	
         91	.stance-depends {
         92	  background-color: #F6AD55;
         93	}
         94	
         95	.issue-reason {
         96	  font-size: 0.875rem;
         97	  margin-top: 0.5rem;
         98	  color: #4a5568;
         99	  line-height: 1.4;
        100	}
        101	
        102	.reason-label {
        103	  font-weight: 500;
        104	  color: #2d3748;
        105	}
        106	
        107	.priority-badge {
        108	  position: absolute;
        109	  top: -10px;
        110	  right: -8px;
        111	  font-size: 0.7rem;
        112	  font-weight: 700;
        113	  color: white;
        114	  padding: 0.15rem 0.5rem;
        115	  border-radius: 0.25rem;
        116	  white-space: nowrap;
        117	  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        118	}
        119	
        120	.issues-matrix-empty {
        121	  font-style: italic;
        122	  color: #a0aec0;
        123	  text-align: center;
        124	  margin-bottom: 1rem;
        125	}
        126	
        127	.issues-matrix-empty-state {
        128	  display: flex;
        129	  flex-direction: column;
        130	  align-items: center;
        131	  margin: 1rem 0;
        132	}
        133	
        134	.issues-matrix-empty-placeholder {
        135	  display: flex;
        136	  justify-content: center;
        137	  width: 100%;
        138	  margin-top: 0.5rem;
        139	}
        140	
        141	.empty-placeholder-card {
        142	  width: 250px;
        143	  height: 100px;
        144	  background-color: #f7fafc;
        145	  border: 1px solid #e2e8f0;
        146	  border-radius: 0.375rem;
        147	  padding: 0.75rem;
        148	  opacity: 0.6;
        149	  border-width: 1px;
        150	  border-style: dashed;
        151	  animation: pulse 2s infinite;
        152	}
        153	
        154	@keyframes pulse {
        155	  0% { opacity: 0.4; }
        156	  50% { opacity: 0.7; }
        157	  100% { opacity: 0.4; }
        158	}
        159	
        160	.empty-placeholder-header {
        161	  height: 20px;
        162	  background-color: #edf2f7;
        163	  border-radius: 0.25rem;
        164	  margin-bottom: 0.75rem;
        165	}
        166	
        167	.empty-placeholder-body {
        168	  height: 40px;
        169	  background-color: #edf2f7;
        170	  border-radius: 0.25rem;
        171	}
        172	
        173	.issues-matrix-footer {
        174	  margin-top: 1rem;
        175	  font-style: italic;
        176	  color: #718096;
        177	  text-align: center;
        178	  border-top: 1px solid #e2e8f0;
        179	  padding-top: 0.5rem;
        180	}
        181	
        182	/* Add transition animation for matrix items */
        183	.issue-item {
        184	  animation: fadeIn 0.3s ease-in-out;
        185	  transition: all 0.2s ease;
        186	}
        187	
        188	@keyframes fadeIn {
        189	  from {
        190	    opacity: 0;
        191	    transform: translateY(10px);
        192	  }
        193	  to {
        194	    opacity: 1;
        195	    transform: translateY(0);
        196	  }
        197	}
        198	
        199	/* Animation for highlighting updated issues */
        200	@keyframes highlight {
        201	  0% { background-color: rgba(99, 102, 241, 0.2); }
        202	  100% { background-color: white; }
        203	}
        204	
        205	.issue-item.updated {
        206	  animation: highlight 2s ease-out;
        207	}
        208	
        209	/* Style entering the steps */
        210	.issues-matrix[data-step="1"] {
        211	  border-left: 2px solid #4299E1;
        212	}
        213	
        214	.issues-matrix[data-step="2"] {
        215	  border-left: 2px solid #48BB78;
        216	}
        217	
        218	.issues-matrix[data-step="3"], .issues-matrix[data-step="4"] {
        219	  border-left: 2px solid #F6AD55;
        220	}
        221	
        222	.issues-matrix[data-step="5"], .issues-matrix[data-step="6"], .issues-matrix[data-step="7"] {
        223	  border-left: 2px solid #9F7AEA;
        224	}
        225	
        226	@media (max-width: 640px) {
        227	  .issues-list {
        228	    grid-template-columns: 1fr;
        229	  }
        230	}
        231	
        232	/* Debug info for matrix */
        233	.matrix-debug-info {
        234	  background-color: #f8f9fa;
        235	  border: 1px dashed #cbd5e0;
        236	  border-radius: 6px;
        237	  padding: 0.5rem;
        238	  margin-top: 0.5rem;
        239	  font-size: 0.8rem;
        240	  color: #718096;
        241	  text-align: center;
        242	}
        243	
        244	.debug-button {
        245	  background-color: #edf2f7;
        246	  border: 1px solid #cbd5e0;
        247	  border-radius: 4px;
        248	  padding: 0.25rem 0.5rem;
        249	  font-size: 0.75rem;
        250	  color: #4a5568;
        251	  cursor: pointer;
        252	  margin-top: 0.5rem;
        253	}
        254	
        255	.debug-button:hover {
        256	  background-color: #e2e8f0;
        257	}

==============================================
FILE: ./frontend/src/components/IssuesMatrix.tsx
==============================================

          1	import React, { useMemo } from 'react';
          2	import './IssuesMatrix.css';
          3	
          4	export interface Issue {
          5	  id: string;
          6	  title: string;
          7	  description: string;
          8	  stance?: string | null;
          9	  reason?: string | string[];
         10	  summary?: string | null;
         11	  isPriority?: boolean;
         12	}
         13	
         14	interface IssuesMatrixProps {
         15	  selectedIssues: Issue[];
         16	  step: number;
         17	  agentColor?: string;
         18	  onDiscussIssue?: (issueId: string, title: string) => void;
         19	}
         20	
         21	/**
         22	 * Component that displays a visual matrix of user's selected issues and their positions
         23	 * Updates dynamically during the onboarding steps 1-4
         24	 */
         25	const IssuesMatrix: React.FC<IssuesMatrixProps> = ({
         26	  selectedIssues,
         27	  step,
         28	  agentColor = '#4299E1',
         29	  onDiscussIssue
         30	}) => {
         31	  const isVisible = useMemo(() => {
         32	    // Show after step 1 even if no issues are selected yet
         33	    return step >= 1;
         34	  }, [step]);
         35	
         36	  // Determine appropriate heading based on the current step
         37	  const getHeading = () => {
         38	    if (step === 1) return "Selected Issues";
         39	    if (step === 2) return "Your Stances on Issues";
         40	    if (step >= 3) return "Your Positions Matrix";
         41	    return "Positions Matrix";
         42	  };
         43	
         44	  if (!isVisible) return null;
         45	
         46	  return (
         47	    <div className="issues-matrix" data-step={step}>
         48	      <h3 className="issues-matrix-heading">{getHeading()}</h3>
         49	      <div className="issues-matrix-content">
         50	        {selectedIssues.length === 0 ? (
         51	          <div className="issues-matrix-empty-state">
         52	            <p className="issues-matrix-empty">
         53	              {step === 1 ? "Select issues you care about to build your perspective matrix." :
         54	               "No issues selected yet. The matrix will populate as the conversation progresses."}
         55	            </p>
         56	            <div className="issues-matrix-empty-placeholder">
         57	              <div className="empty-placeholder-card" style={{ borderColor: agentColor }}>
         58	                <div className="empty-placeholder-header"></div>
         59	                <div className="empty-placeholder-body"></div>
         60	              </div>
         61	            </div>
         62	          </div>
         63	        ) : (
         64	          <ul className="issues-list">
         65	            {selectedIssues.map((issue) => {
         66	              // Pre-compute the stance display text and styling
         67	              const stanceText = issue.stance 
         68	                ? issue.stance.toString().replace('APPROACH_', 'Approach ') 
         69	                : 'Custom';
         70	              
         71	              const stanceKey = issue.stance 
         72	                ? issue.stance.toString().toLowerCase() 
         73	                : '';
         74	              
         75	              // Determine the background color based on approach
         76	              let backgroundColor = '#A0AEC0'; // Default gray
         77	              
         78	              if (issue.stance === 'APPROACH_A' || issue.stance?.toString().toUpperCase() === 'A') {
         79	                backgroundColor = '#48BB78'; // Green
         80	              } else if (issue.stance === 'APPROACH_B' || issue.stance?.toString().toUpperCase() === 'B') {
         81	                backgroundColor = '#F56565'; // Red
         82	              } else if (issue.stance === 'APPROACH_C' || issue.stance?.toString().toUpperCase() === 'C') {
         83	                backgroundColor = '#F6AD55'; // Orange
         84	              }
         85	              
         86	              return (
         87	                <li
         88	                  key={issue.id}
         89	                  className={`issue-item ${issue.isPriority ? 'priority-issue' : ''}`}
         90	                  style={issue.isPriority ? { borderColor: agentColor } : {}}
         91	                >
         92	                  <div className="issue-header">
         93	                    <span className="issue-title">{issue.title}</span>
         94	                    {issue.stance && (
         95	                      <span
         96	                        className={`issue-stance stance-${stanceKey}`}
         97	                        style={{ backgroundColor }}
         98	                      >
         99	                        {stanceText}
        100	                      </span>
        101	                    )}
        102	                  </div>
        103	                  {issue.description && (
        104	                    <div className="issue-description">
        105	                      <span className="description-label">Description:</span>
        106	                      <span className="description-text">{issue.description}</span>
        107	                    </div>
        108	                  )}
        109	                  {(issue.summary ||
        110	                    (issue.reason &&
        111	                      typeof issue.reason === 'string' &&
        112	                      issue.reason !== null &&
        113	                      !/^\d+(,\s*\d+)*$/.test(issue.reason.trim())
        114	                    )
        115	                  ) && (
        116	                    <div className="issue-reason">
        117	                      <span className="reason-label">Perspective:</span>
        118	                      {issue.summary && (
        119	                        <div className="summary-text">
        120	                          {issue.summary}
        121	                        </div>
        122	                      )}
        123	                      {issue.reason && issue.reason !== issue.summary && (
        124	                        Array.isArray(issue.reason) ? (
        125	                          <ul className="reason-bullets">
        126	                            {issue.reason.map((point, idx) => (
        127	                              <li key={idx}>{point}</li>
        128	                            ))}
        129	                          </ul>
        130	                        ) : (
        131	                          <span className="reason-text">{issue.reason}</span>
        132	                        )
        133	                      )}
        134	                    </div>
        135	                  )}
        136	                  {issue.isPriority && (
        137	                    <div className="priority-badge" style={{ backgroundColor: agentColor }}>
        138	                      Top Priority
        139	                    </div>
        140	                  )}
        141	                  {onDiscussIssue && (
        142	                    <div className="issue-discuss-action">
        143	                      <button
        144	                        className="discuss-issue-button"
        145	                        style={{ backgroundColor: agentColor, color: '#fff', marginTop: '0.5rem' }}
        146	                        onClick={() => onDiscussIssue(issue.id, issue.title)}
        147	                      >
        148	                        Discuss
        149	                      </button>
        150	                    </div>
        151	                  )}
        152	                </li>
        153	              );
        154	            })}
        155	          </ul>
        156	        )}
        157	      </div>
        158	      <div className="issues-matrix-footer">
        159	        <small>Your perspective matrix will update as the conversation continues</small>
        160	      </div>
        161	    </div>
        162	  );
        163	};
        164	
        165	export default IssuesMatrix;

==============================================
FILE: ./frontend/src/components/Negotiation.css
==============================================

          1	.negotiation-thread {
          2	  background: #f9f9f9;
          3	  border-radius: 8px;
          4	  padding: 1.5rem;
          5	  margin-bottom: 2rem;
          6	  max-width: 700px;
          7	  margin-left: auto;
          8	  margin-right: auto;
          9	}
         10	
         11	.negotiation-messages {
         12	  margin-bottom: 1.5rem;
         13	}
         14	
         15	.negotiation-message {
         16	  background: #fff;
         17	  border: 1px solid #e0e0e0;
         18	  border-radius: 6px;
         19	  margin-bottom: 1rem;
         20	  padding: 1rem;
         21	  box-shadow: 0 1px 2px rgba(0,0,0,0.03);
         22	}
         23	
         24	.reactions-row {
         25	  margin-top: 0.5rem;
         26	  display: flex;
         27	  gap: 0.5rem;
         28	}
         29	
         30	.reaction-btn {
         31	  background: #f0f0f0;
         32	  border: 1px solid #ccc;
         33	  border-radius: 16px;
         34	  padding: 0.2rem 0.8rem;
         35	  cursor: pointer;
         36	  font-size: 1.1rem;
         37	  transition: background 0.2s, border 0.2s;
         38	}
         39	.reaction-btn.reacted {
         40	  background: #d1e7dd;
         41	  border-color: #198754;
         42	  color: #198754;
         43	}
         44	
         45	.negotiation-new-message {
         46	  display: flex;
         47	  flex-direction: column;
         48	  gap: 0.5rem;
         49	}
         50	
         51	.negotiation-new-message textarea {
         52	  font-size: 1rem;
         53	  border-radius: 4px;
         54	  border: 1px solid #ccc;
         55	  padding: 0.5rem;
         56	  resize: vertical;
         57	}
         58	
         59	.negotiation-new-message button {
         60	  align-self: flex-end;
         61	  background: #007bff;
         62	  color: #fff;
         63	  border: none;
         64	  border-radius: 4px;
         65	  padding: 0.4rem 1.2rem;
         66	  font-size: 1rem;
         67	  cursor: pointer;
         68	  transition: background 0.2s;
         69	}
         70	.negotiation-new-message button:disabled {
         71	  background: #b0b0b0;
         72	  cursor: not-allowed;
         73	}
         74	
         75	.negotiation-list {
         76	  max-width: 700px;
         77	  margin: 2rem auto;
         78	  background: #f8f9fa;
         79	  border-radius: 8px;
         80	  padding: 1.5rem;
         81	}
         82	
         83	.feedback-modal {
         84	  /* already styled inline in component */
         85	}
         86	
         87	@media (max-width: 600px) {
         88	  .negotiation-thread, .negotiation-list {
         89	    padding: 0.5rem;
         90	    font-size: 0.95rem;
         91	  }
         92	  .negotiation-message {
         93	    padding: 0.5rem;
         94	  }
         95	  .negotiation-new-message button {
         96	    font-size: 0.95rem;
         97	    padding: 0.3rem 0.8rem;
         98	  }
         99	}

==============================================
FILE: ./frontend/src/components/NegotiationFeedback.css
==============================================

          1	.negotiation-feedback {
          2	  background-color: #f8f9fa;
          3	  border-radius: 8px;
          4	  padding: 1.5rem;
          5	  margin: 1.5rem 0;
          6	  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
          7	}
          8	
          9	.negotiation-feedback h3 {
         10	  margin-top: 0;
         11	  margin-bottom: 1rem;
         12	  color: #333;
         13	  font-size: 1.25rem;
         14	  border-bottom: 1px solid #e9ecef;
         15	  padding-bottom: 0.75rem;
         16	}
         17	
         18	.feedback-notice {
         19	  background-color: #e9f5ff;
         20	  border-left: 4px solid #0078d4;
         21	  padding: 0.75rem 1rem;
         22	  margin-bottom: 1.5rem;
         23	  font-size: 0.9rem;
         24	  color: #444;
         25	}
         26	
         27	.feedback-field {
         28	  margin-bottom: 1.25rem;
         29	}
         30	
         31	.feedback-field span {
         32	  display: block;
         33	  margin-bottom: 0.5rem;
         34	  font-weight: 500;
         35	}
         36	
         37	.rating-stars {
         38	  display: flex;
         39	  gap: 0.5rem;
         40	}
         41	
         42	.star-button {
         43	  background: none;
         44	  border: none;
         45	  font-size: 1.5rem;
         46	  color: #ccc;
         47	  cursor: pointer;
         48	  transition: color 0.2s;
         49	  padding: 0;
         50	  margin: 0;
         51	  line-height: 1;
         52	}
         53	
         54	.star-button.selected {
         55	  color: #ffc107;
         56	}
         57	
         58	.star-button:hover {
         59	  color: #ffc107;
         60	}
         61	
         62	.feedback-field textarea {
         63	  width: 100%;
         64	  padding: 0.75rem;
         65	  border: 1px solid #ddd;
         66	  border-radius: 4px;
         67	  font-size: 0.95rem;
         68	  resize: vertical;
         69	}
         70	
         71	.feedback-field textarea:focus {
         72	  outline: none;
         73	  border-color: #0078d4;
         74	  box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.2);
         75	}
         76	
         77	.hint-text {
         78	  font-size: 0.85rem;
         79	  color: #666;
         80	  margin-top: 0.25rem;
         81	}
         82	
         83	.feedback-submit-button {
         84	  background-color: #0078d4;
         85	  color: white;
         86	  border: none;
         87	  border-radius: 4px;
         88	  padding: 0.75rem 1.5rem;
         89	  font-size: 1rem;
         90	  cursor: pointer;
         91	  transition: background-color 0.2s;
         92	}
         93	
         94	.feedback-submit-button:hover {
         95	  background-color: #006bb3;
         96	}
         97	
         98	.feedback-submit-button:disabled {
         99	  background-color: #cccccc;
        100	  cursor: not-allowed;
        101	}
        102	
        103	.feedback-error {
        104	  background-color: #ffebee;
        105	  color: #d32f2f;
        106	  padding: 0.75rem;
        107	  margin-bottom: 1rem;
        108	  border-radius: 4px;
        109	  font-size: 0.9rem;
        110	}
        111	
        112	.feedback-success {
        113	  background-color: #e8f5e9;
        114	  color: #2e7d32;
        115	  padding: 0.75rem;
        116	  margin-bottom: 1rem;
        117	  border-radius: 4px;
        118	  font-size: 0.9rem;
        119	}
        120	
        121	.feedback-loading {
        122	  color: #666;
        123	  font-style: italic;
        124	  padding: 1rem 0;
        125	}

==============================================
FILE: ./frontend/src/components/NegotiationFeedback.tsx
==============================================

          1	import React, { useState, useEffect } from 'react';
          2	import apiClient from '../api/apiClient';
          3	import './NegotiationFeedback.css';
          4	
          5	interface NegotiationFeedbackProps {
          6	  negotiationId: string;
          7	  agentId: string;
          8	  onFeedbackSubmitted?: () => void;
          9	}
         10	
         11	interface FeedbackData {
         12	  id: string;
         13	  rating: number;
         14	  representationAccuracy: number;
         15	  comments: string;
         16	  createdAt: string;
         17	}
         18	
         19	const NegotiationFeedback: React.FC<NegotiationFeedbackProps> = ({ 
         20	  negotiationId, 
         21	  agentId,
         22	  onFeedbackSubmitted 
         23	}) => {
         24	  const [rating, setRating] = useState<number>(5);
         25	  const [representationAccuracy, setRepresentationAccuracy] = useState<number>(5);
         26	  const [comments, setComments] = useState<string>('');
         27	  const [existingFeedback, setExistingFeedback] = useState<FeedbackData | null>(null);
         28	  const [loading, setLoading] = useState<boolean>(true);
         29	  const [submitting, setSubmitting] = useState<boolean>(false);
         30	  const [error, setError] = useState<string | null>(null);
         31	  const [success, setSuccess] = useState<boolean>(false);
         32	
         33	  // Fetch existing feedback
         34	  useEffect(() => {
         35	    const fetchFeedback = async () => {
         36	      try {
         37	        setLoading(true);
         38	        const response = await apiClient.get(`/api/feedback/negotiation/${negotiationId}?agentId=${agentId}`);
         39	        if (response.data.length > 0) {
         40	          setExistingFeedback(response.data[0]);
         41	          setRating(response.data[0].rating);
         42	          setRepresentationAccuracy(response.data[0].representationAccuracy);
         43	          setComments(response.data[0].comments);
         44	        }
         45	      } catch (err) {
         46	        console.error('Failed to fetch feedback', err);
         47	        setError('Failed to load existing feedback');
         48	      } finally {
         49	        setLoading(false);
         50	      }
         51	    };
         52	
         53	    if (negotiationId && agentId) {
         54	      fetchFeedback();
         55	    }
         56	  }, [negotiationId, agentId]);
         57	
         58	  const handleSubmit = async (e: React.FormEvent) => {
         59	    e.preventDefault();
         60	    setSubmitting(true);
         61	    setError(null);
         62	    
         63	    try {
         64	      await apiClient.post(`/api/feedback/negotiation/${negotiationId}`, {
         65	        agentId,
         66	        rating,
         67	        representationAccuracy,
         68	        comments
         69	      });
         70	      
         71	      setSuccess(true);
         72	      if (onFeedbackSubmitted) {
         73	        onFeedbackSubmitted();
         74	      }
         75	      
         76	      // Reset success message after a delay
         77	      setTimeout(() => {
         78	        setSuccess(false);
         79	      }, 3000);
         80	    } catch (err) {
         81	      console.error('Failed to submit feedback', err);
         82	      setError('Failed to submit feedback. Please try again.');
         83	    } finally {
         84	      setSubmitting(false);
         85	    }
         86	  };
         87	
         88	  if (loading) {
         89	    return <div className="feedback-loading">Loading feedback...</div>;
         90	  }
         91	
         92	  return (
         93	    <div className="negotiation-feedback">
         94	      <h3>Agent Feedback</h3>
         95	      {existingFeedback && (
         96	        <div className="feedback-notice">
         97	          You've already provided feedback on {new Date(existingFeedback.createdAt).toLocaleDateString()}
         98	        </div>
         99	      )}
        100	      
        101	      <form onSubmit={handleSubmit}>
        102	        <div className="feedback-field">
        103	          <label>
        104	            <span>Overall Rating:</span>
        105	            <div className="rating-stars">
        106	              {[1, 2, 3, 4, 5].map((value) => (
        107	                <button
        108	                  key={value}
        109	                  type="button"
        110	                  className={`star-button ${value <= rating ? 'selected' : ''}`}
        111	                  onClick={() => setRating(value)}
        112	                  aria-label={`Rate ${value} out of 5`}
        113	                >
        114	                  ★
        115	                </button>
        116	              ))}
        117	            </div>
        118	          </label>
        119	        </div>
        120	
        121	        <div className="feedback-field">
        122	          <label>
        123	            <span>Representation Accuracy:</span>
        124	            <div className="rating-stars">
        125	              {[1, 2, 3, 4, 5].map((value) => (
        126	                <button
        127	                  key={value}
        128	                  type="button"
        129	                  className={`star-button ${value <= representationAccuracy ? 'selected' : ''}`}
        130	                  onClick={() => setRepresentationAccuracy(value)}
        131	                  aria-label={`Rate representation ${value} out of 5`}
        132	                >
        133	                  ★
        134	                </button>
        135	              ))}
        136	            </div>
        137	          </label>
        138	          <div className="hint-text">
        139	            How accurately did the agent represent your preferences?
        140	          </div>
        141	        </div>
        142	
        143	        <div className="feedback-field">
        144	          <label>
        145	            <span>Comments:</span>
        146	            <textarea
        147	              value={comments}
        148	              onChange={(e) => setComments(e.target.value)}
        149	              placeholder="Share your thoughts on the agent's negotiation performance..."
        150	              rows={4}
        151	            />
        152	          </label>
        153	        </div>
        154	
        155	        {error && <div className="feedback-error">{error}</div>}
        156	        {success && <div className="feedback-success">Feedback submitted successfully!</div>}
        157	        
        158	        <button 
        159	          type="submit" 
        160	          className="feedback-submit-button"
        161	          disabled={submitting}
        162	        >
        163	          {submitting ? 'Submitting...' : existingFeedback ? 'Update Feedback' : 'Submit Feedback'}
        164	        </button>
        165	      </form>
        166	    </div>
        167	  );
        168	};
        169	
        170	export default NegotiationFeedback;

==============================================
FILE: ./frontend/src/components/NegotiationHistory.css
==============================================

          1	.negotiation-history-container {
          2	  background-color: #f8f9fa;
          3	  border-radius: 8px;
          4	  padding: 1.25rem;
          5	  margin: 1.5rem 0;
          6	  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
          7	}
          8	
          9	.negotiation-history-header {
         10	  display: flex;
         11	  justify-content: space-between;
         12	  align-items: center;
         13	  margin-bottom: 1rem;
         14	}
         15	
         16	.negotiation-history-header h3 {
         17	  margin: 0;
         18	  font-size: 1.25rem;
         19	  color: #333;
         20	}
         21	
         22	.toggle-details-button {
         23	  background: transparent;
         24	  border: 1px solid #ddd;
         25	  border-radius: 4px;
         26	  padding: 0.4rem 0.8rem;
         27	  font-size: 0.9rem;
         28	  color: #555;
         29	  cursor: pointer;
         30	  transition: all 0.2s ease;
         31	}
         32	
         33	.toggle-details-button:hover {
         34	  background: #e9ecef;
         35	  border-color: #ccc;
         36	}
         37	
         38	.negotiation-history-meta {
         39	  display: grid;
         40	  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
         41	  gap: 0.75rem;
         42	  margin-bottom: 1.5rem;
         43	  border-top: 1px solid #e3e3e3;
         44	  border-bottom: 1px solid #e3e3e3;
         45	  padding: 1rem 0;
         46	}
         47	
         48	.meta-item {
         49	  display: flex;
         50	  flex-direction: column;
         51	}
         52	
         53	.meta-label {
         54	  font-size: 0.85rem;
         55	  color: #666;
         56	  margin-bottom: 0.25rem;
         57	}
         58	
         59	.meta-value {
         60	  font-weight: 500;
         61	  color: #333;
         62	}
         63	
         64	.meta-value.status-active {
         65	  color: #1976d2;
         66	}
         67	
         68	.meta-value.status-completed {
         69	  color: #388e3c;
         70	}
         71	
         72	.meta-value.status-abandoned {
         73	  color: #d32f2f;
         74	}
         75	
         76	.negotiation-messages {
         77	  max-height: 600px;
         78	  overflow-y: auto;
         79	  padding-right: 0.5rem;
         80	  margin-top: 1rem;
         81	}
         82	
         83	.message-container {
         84	  margin-bottom: 1rem;
         85	  padding: 1rem;
         86	  border-radius: 4px;
         87	  background: white;
         88	  border-left: 3px solid #ccc;
         89	}
         90	
         91	.message-container.agreement-message {
         92	  border-left-color: #4caf50;
         93	  background-color: #f1f8e9;
         94	}
         95	
         96	.message-header {
         97	  display: flex;
         98	  justify-content: space-between;
         99	  margin-bottom: 0.5rem;
        100	}
        101	
        102	.agent-name {
        103	  font-weight: 600;
        104	  font-size: 0.95rem;
        105	}
        106	
        107	.message-timestamp {
        108	  font-size: 0.8rem;
        109	  color: #777;
        110	}
        111	
        112	.message-content {
        113	  white-space: pre-wrap;
        114	  line-height: 1.5;
        115	  color: #333;
        116	  margin-bottom: 0.5rem;
        117	}
        118	
        119	.message-reactions {
        120	  display: flex;
        121	  flex-wrap: wrap;
        122	  gap: 0.4rem;
        123	  margin-top: 0.5rem;
        124	}
        125	
        126	.reaction-badge {
        127	  background-color: #f1f1f1;
        128	  padding: 0.15rem 0.5rem;
        129	  border-radius: 12px;
        130	  font-size: 0.8rem;
        131	  color: #555;
        132	}
        133	
        134	.reaction-badge[data-type="support"] {
        135	  background-color: #e3f2fd;
        136	  color: #1565c0;
        137	}
        138	
        139	.reaction-badge[data-type="non-support"] {
        140	  background-color: #fbe9e7;
        141	  color: #d32f2f;
        142	}
        143	
        144	.reaction-badge[data-type="question"] {
        145	  background-color: #e8f5e9;
        146	  color: #2e7d32;
        147	}
        148	
        149	.negotiation-history-loading {
        150	  padding: 2rem;
        151	  text-align: center;
        152	  color: #666;
        153	  font-style: italic;
        154	}
        155	
        156	.negotiation-history-error {
        157	  padding: 1rem;
        158	  background-color: #ffebee;
        159	  color: #c62828;
        160	  border-radius: 4px;
        161	  text-align: center;
        162	}

==============================================
FILE: ./frontend/src/components/NegotiationHistory.tsx
==============================================

          1	import React, { useState, useEffect } from 'react';
          2	import apiClient from '../api/apiClient';
          3	import './NegotiationHistory.css';
          4	
          5	interface NegotiationHistoryProps {
          6	  negotiationId: string;
          7	}
          8	
          9	interface NegotiationMessage {
         10	  id: string;
         11	  agentId: string;
         12	  content: string;
         13	  messageType: string;
         14	  timestamp: string;
         15	  referencedMessageId?: string;
         16	  agent: {
         17	    name: string;
         18	    color: string;
         19	  };
         20	  reactions: Array<{
         21	    id: string;
         22	    agentId: string;
         23	    reactionType: string;
         24	  }>;
         25	}
         26	
         27	interface NegotiationSession {
         28	  id: string;
         29	  topic: string;
         30	  description?: string;
         31	  status: string;
         32	  startedAt: string;
         33	  completedAt?: string;
         34	}
         35	
         36	const NegotiationHistory: React.FC<NegotiationHistoryProps> = ({ negotiationId }) => {
         37	  const [session, setSession] = useState<NegotiationSession | null>(null);
         38	  const [messages, setMessages] = useState<NegotiationMessage[]>([]);
         39	  const [loading, setLoading] = useState<boolean>(true);
         40	  const [error, setError] = useState<string | null>(null);
         41	  const [showDetails, setShowDetails] = useState<boolean>(false);
         42	
         43	  useEffect(() => {
         44	    const fetchNegotiation = async () => {
         45	      setLoading(true);
         46	      try {
         47	        // Fetch negotiation session details
         48	        const sessionResponse = await apiClient.get(`/api/negotiations/${negotiationId}`);
         49	        setSession(sessionResponse.data);
         50	        
         51	        // Fetch negotiation messages
         52	        const messagesResponse = await apiClient.get(`/api/negotiations/${negotiationId}/messages`);
         53	        setMessages(messagesResponse.data);
         54	      } catch (err) {
         55	        console.error('Failed to fetch negotiation history', err);
         56	        setError('Failed to load negotiation history');
         57	      } finally {
         58	        setLoading(false);
         59	      }
         60	    };
         61	
         62	    if (negotiationId) {
         63	      fetchNegotiation();
         64	    }
         65	  }, [negotiationId]);
         66	
         67	  if (loading) {
         68	    return <div className="negotiation-history-loading">Loading negotiation history...</div>;
         69	  }
         70	
         71	  if (error) {
         72	    return <div className="negotiation-history-error">{error}</div>;
         73	  }
         74	
         75	  if (!session) {
         76	    return <div className="negotiation-history-error">Negotiation not found</div>;
         77	  }
         78	
         79	  // Get unique agent IDs to show participant count
         80	  const participantIds = [...new Set(messages.map(message => message.agentId))];
         81	
         82	  // Format timestamp
         83	  const formatTimestamp = (timestamp: string) => {
         84	    return new Date(timestamp).toLocaleString();
         85	  };
         86	
         87	  // Group reactions by type for display
         88	  const getReactionSummary = (reactions: any[]) => {
         89	    const reactionCounts = reactions.reduce((acc: Record<string, number>, reaction) => {
         90	      acc[reaction.reactionType] = (acc[reaction.reactionType] || 0) + 1;
         91	      return acc;
         92	    }, {});
         93	    
         94	    return Object.entries(reactionCounts).map(([type, count]) => (
         95	      <span key={type} className="reaction-badge">
         96	        {type} {count > 1 ? `× ${count}` : ''}
         97	      </span>
         98	    ));
         99	  };
        100	
        101	  // Calculate consensus status
        102	  const consensusStatus = session.status === 'completed' ? 'Consensus Reached' : 'No Consensus Yet';
        103	
        104	  return (
        105	    <div className="negotiation-history-container">
        106	      <div className="negotiation-history-header">
        107	        <h3>Negotiation History</h3>
        108	        <button
        109	          className="toggle-details-button"
        110	          onClick={() => setShowDetails(!showDetails)}
        111	        >
        112	          {showDetails ? 'Hide Details' : 'Show Details'}
        113	        </button>
        114	      </div>
        115	      
        116	      <div className="negotiation-history-meta">
        117	        <div className="meta-item">
        118	          <span className="meta-label">Topic:</span>
        119	          <span className="meta-value">{session.topic}</span>
        120	        </div>
        121	        
        122	        <div className="meta-item">
        123	          <span className="meta-label">Status:</span>
        124	          <span className={`meta-value status-${session.status}`}>
        125	            {session.status.charAt(0).toUpperCase() + session.status.slice(1)}
        126	          </span>
        127	        </div>
        128	        
        129	        <div className="meta-item">
        130	          <span className="meta-label">Consensus:</span>
        131	          <span className={`meta-value ${session.status === 'completed' ? 'status-completed' : ''}`}>
        132	            {consensusStatus}
        133	          </span>
        134	        </div>
        135	        
        136	        <div className="meta-item">
        137	          <span className="meta-label">Participants:</span>
        138	          <span className="meta-value">{participantIds.length} agents</span>
        139	        </div>
        140	        
        141	        <div className="meta-item">
        142	          <span className="meta-label">Started:</span>
        143	          <span className="meta-value">{formatTimestamp(session.startedAt)}</span>
        144	        </div>
        145	        
        146	        {session.completedAt && (
        147	          <div className="meta-item">
        148	            <span className="meta-label">Completed:</span>
        149	            <span className="meta-value">{formatTimestamp(session.completedAt)}</span>
        150	          </div>
        151	        )}
        152	      </div>
        153	
        154	      {showDetails && (
        155	        <div className="negotiation-messages">
        156	          {messages.map((message) => (
        157	            <div 
        158	              key={message.id} 
        159	              className={`message-container ${message.messageType === 'agreement' ? 'agreement-message' : ''}`}
        160	            >
        161	              <div className="message-header">
        162	                <span 
        163	                  className="agent-name"
        164	                  style={{ color: message.agent?.color || '#666' }}
        165	                >
        166	                  {message.agent?.name || `Agent ${message.agentId.substring(0, 4)}`}
        167	                </span>
        168	                <span className="message-timestamp">{formatTimestamp(message.timestamp)}</span>
        169	              </div>
        170	              
        171	              <div className="message-content">
        172	                {message.content}
        173	              </div>
        174	              
        175	              {message.reactions && message.reactions.length > 0 && (
        176	                <div className="message-reactions">
        177	                  {getReactionSummary(message.reactions)}
        178	                </div>
        179	              )}
        180	            </div>
        181	          ))}
        182	        </div>
        183	      )}
        184	    </div>
        185	  );
        186	};
        187	
        188	export default NegotiationHistory;

==============================================
FILE: ./frontend/src/components/NegotiationList.tsx
==============================================

          1	import React, { useEffect, useState } from "react";
          2	import { negotiations } from "../api/apiClient";
          3	import "./Negotiation.css";
          4	import NegotiationThread from "./NegotiationThread";
          5	
          6	interface NegotiationSession {
          7	  id: string;
          8	  topic: string;
          9	  description?: string;
         10	  status: string;
         11	  startedAt: string;
         12	  completedAt?: string;
         13	  initiatorId: string;
         14	}
         15	
         16	interface NegotiationListProps {
         17	  agentId: string;
         18	}
         19	
         20	const NegotiationList: React.FC<NegotiationListProps> = ({ agentId }) => {
         21	  const [negotiationsList, setNegotiationsList] = useState<NegotiationSession[]>([]);
         22	  const [selectedNegotiationId, setSelectedNegotiationId] = useState<string | null>(null);
         23	  const [loading, setLoading] = useState(true);
         24	  const [error, setError] = useState<string | null>(null);
         25	
         26	  // Modal state for creating a negotiation
         27	  const [createOpen, setCreateOpen] = useState(false);
         28	  const [newTopic, setNewTopic] = useState("");
         29	  const [newDescription, setNewDescription] = useState("");
         30	  const [creating, setCreating] = useState(false);
         31	
         32	  const fetchNegotiations = async () => {
         33	    setLoading(true);
         34	    setError(null);
         35	    try {
         36	      const res = await negotiations.getAll();
         37	      setNegotiationsList(res.data);
         38	    } catch (err: any) {
         39	      setError(err.message || "Failed to load negotiations.");
         40	    } finally {
         41	      setLoading(false);
         42	    }
         43	  };
         44	
         45	  const handleCreateNegotiation = async (e: React.FormEvent) => {
         46	    e.preventDefault();
         47	    if (!newTopic.trim()) return;
         48	    setCreating(true);
         49	    setError(null);
         50	    try {
         51	      await negotiations.create({
         52	        topic: newTopic,
         53	        description: newDescription,
         54	        initiatorId: agentId,
         55	      });
         56	      setCreateOpen(false);
         57	      setNewTopic("");
         58	      setNewDescription("");
         59	      await fetchNegotiations();
         60	    } catch (err: any) {
         61	      setError(err.message || "Failed to create negotiation.");
         62	    } finally {
         63	      setCreating(false);
         64	    }
         65	  };
         66	
         67	  useEffect(() => {
         68	    fetchNegotiations();
         69	  }, []);
         70	
         71	  return (
         72	    <div className="negotiation-list" role="region" aria-label="Negotiation List">
         73	      <h2>All Negotiations</h2>
         74	      <button
         75	        style={{ marginBottom: "1rem" }}
         76	        onClick={() => setCreateOpen(true)}
         77	        aria-label="Create New Negotiation"
         78	      >
         79	        + Create Negotiation
         80	      </button>
         81	      {createOpen && (
         82	        <div
         83	          className="negotiation-modal"
         84	          role="dialog"
         85	          aria-modal="true"
         86	          aria-label="Create Negotiation"
         87	          style={{
         88	            position: "fixed",
         89	            top: 0, left: 0, right: 0, bottom: 0,
         90	            background: "rgba(0,0,0,0.4)",
         91	            display: "flex",
         92	            alignItems: "center",
         93	            justifyContent: "center",
         94	            zIndex: 1000,
         95	          }}
         96	          onClick={() => setCreateOpen(false)}
         97	        >
         98	          <div
         99	            className="negotiation-modal-content"
        100	            style={{
        101	              background: "#fff",
        102	              padding: "2rem",
        103	              borderRadius: "8px",
        104	              minWidth: "300px",
        105	              maxWidth: "90vw",
        106	            }}
        107	            onClick={e => e.stopPropagation()}
        108	          >
        109	            <h3>Create New Negotiation</h3>
        110	            <form onSubmit={handleCreateNegotiation}>
        111	              <label>
        112	                Topic:
        113	                <input
        114	                  type="text"
        115	                  value={newTopic}
        116	                  onChange={e => setNewTopic(e.target.value)}
        117	                  required
        118	                  style={{ width: "100%", marginBottom: "0.5rem" }}
        119	                  aria-label="Negotiation Topic"
        120	                />
        121	              </label>
        122	              <label>
        123	                Description:
        124	                <textarea
        125	                  value={newDescription}
        126	                  onChange={e => setNewDescription(e.target.value)}
        127	                  rows={3}
        128	                  style={{ width: "100%" }}
        129	                  aria-label="Negotiation Description"
        130	                />
        131	              </label>
        132	              <div style={{ marginTop: "1rem" }}>
        133	                <button type="submit" disabled={creating || !newTopic.trim()}>
        134	                  {creating ? "Creating..." : "Create"}
        135	                </button>
        136	                <button type="button" onClick={() => setCreateOpen(false)} style={{ marginLeft: "1rem" }}>
        137	                  Cancel
        138	                </button>
        139	              </div>
        140	            </form>
        141	          </div>
        142	        </div>
        143	      )}
        144	      {loading ? (
        145	        <div>Loading negotiations...</div>
        146	      ) : error ? (
        147	        <div style={{ color: "red" }}>{error}</div>
        148	      ) : (
        149	        <ul role="list" tabIndex={0} aria-label="Negotiation Sessions">
        150	          {negotiationsList.map((neg, idx) => (
        151	            <li
        152	              key={neg.id}
        153	              style={{ marginBottom: "1rem" }}
        154	              tabIndex={0}
        155	              aria-label={`Negotiation: ${neg.topic}, status ${neg.status}`}
        156	              onKeyDown={(e) => {
        157	                if ((e.key === "Enter" || e.key === " ") && document.activeElement === e.currentTarget) {
        158	                  setSelectedNegotiationId(neg.id);
        159	                }
        160	              }}
        161	            >
        162	              <strong>{neg.topic}</strong> (Status: {neg.status})
        163	              <br />
        164	              Started: {new Date(neg.startedAt).toLocaleString()}
        165	              <br />
        166	              {neg.description && <span>{neg.description}</span>}
        167	              <br />
        168	              <button
        169	                onClick={() => setSelectedNegotiationId(neg.id)}
        170	                aria-label={`View thread for negotiation ${neg.topic}`}
        171	              >
        172	                View Thread
        173	              </button>
        174	            </li>
        175	          ))}
        176	        </ul>
        177	      )}
        178	      {selectedNegotiationId && (
        179	        <div style={{ marginTop: "2rem" }} role="region" aria-label="Negotiation Thread">
        180	          <button
        181	            onClick={() => setSelectedNegotiationId(null)}
        182	            aria-label="Back to Negotiation List"
        183	          >
        184	            Back to List
        185	          </button>
        186	          <NegotiationThread negotiationId={selectedNegotiationId} agentId={agentId} />
        187	        </div>
        188	      )}
        189	    </div>
        190	  );
        191	};
        192	
        193	export default NegotiationList;

==============================================
FILE: ./frontend/src/components/NegotiationThread.tsx
==============================================

          1	import React, { useEffect, useState } from "react";
          2	import { negotiations } from "../api/apiClient";
          3	import "./Negotiation.css";
          4	
          5	interface NegotiationThreadProps {
          6	  negotiationId: string;
          7	  agentId: string;
          8	}
          9	
         10	interface NegotiationMessage {
         11	  id: string;
         12	  negotiationId: string;
         13	  agentId: string;
         14	  content: string;
         15	  messageType: string;
         16	  referencedMessageId?: string;
         17	  metadata?: any;
         18	  timestamp: string;
         19	  reactions: NegotiationReaction[];
         20	}
         21	
         22	interface NegotiationReaction {
         23	  id: string;
         24	  messageId: string;
         25	  agentId: string;
         26	  reactionType: string;
         27	  createdAt: string;
         28	}
         29	
         30	const REACTION_TYPES = [
         31	  { type: "support", label: "👍" },
         32	  { type: "non-support", label: "👎" },
         33	  { type: "like", label: "❤️" },
         34	  { type: "dislike", label: "💔" },
         35	];
         36	
         37	const NegotiationThread: React.FC<NegotiationThreadProps> = ({
         38	  negotiationId,
         39	  agentId,
         40	}) => {
         41	  const [messages, setMessages] = useState<NegotiationMessage[]>([]);
         42	  const [newMessage, setNewMessage] = useState("");
         43	  const [loading, setLoading] = useState(true);
         44	  const [posting, setPosting] = useState(false);
         45	  const [error, setError] = useState<string | null>(null);
         46	  const [success, setSuccess] = useState<string | null>(null);
         47	
         48	  const fetchMessages = async () => {
         49	    setLoading(true);
         50	    setError(null);
         51	    try {
         52	      const res = await negotiations.getMessages(negotiationId);
         53	      setMessages(res.data);
         54	    } catch (err: any) {
         55	      setError(err.message || "Failed to load messages.");
         56	    } finally {
         57	      setLoading(false);
         58	    }
         59	  };
         60	
         61	  useEffect(() => {
         62	    fetchMessages();
         63	    // Poll for updates every 5 seconds
         64	    const interval = setInterval(fetchMessages, 5000);
         65	    return () => clearInterval(interval);
         66	  }, [negotiationId]);
         67	
         68	  const handleSendMessage = async () => {
         69	    if (!newMessage.trim()) return;
         70	    setPosting(true);
         71	    setError(null);
         72	    try {
         73	      await negotiations.postMessage(negotiationId, {
         74	        agentId,
         75	        content: newMessage,
         76	      });
         77	      setNewMessage("");
         78	      await fetchMessages();
         79	      setSuccess("Message posted!");
         80	      setTimeout(() => setSuccess(null), 2000);
         81	    } catch (err: any) {
         82	      setError(err.message || "Failed to post message.");
         83	    } finally {
         84	      setPosting(false);
         85	    }
         86	  };
         87	
         88	  const handleAddReaction = async (
         89	    messageId: string,
         90	    reactionType: string
         91	  ) => {
         92	    try {
         93	      await negotiations.addReaction(negotiationId, messageId, {
         94	        agentId,
         95	        reactionType,
         96	      });
         97	      await fetchMessages();
         98	      setSuccess("Reaction added!");
         99	      setTimeout(() => setSuccess(null), 1500);
        100	    } catch (err: any) {
        101	      setError(err.message || "Failed to add reaction.");
        102	    }
        103	  };
        104	
        105	  const handleRemoveReaction = async (
        106	    messageId: string,
        107	    reactionType: string
        108	  ) => {
        109	    try {
        110	      await negotiations.removeReaction(negotiationId, messageId, {
        111	        agentId,
        112	        reactionType,
        113	      });
        114	      await fetchMessages();
        115	      setSuccess("Reaction removed.");
        116	      setTimeout(() => setSuccess(null), 1500);
        117	    } catch (err: any) {
        118	      setError(err.message || "Failed to remove reaction.");
        119	    }
        120	  };
        121	
        122	  const getReactionCount = (reactions: NegotiationReaction[], type: string) =>
        123	    reactions.filter((r) => r.reactionType === type).length;
        124	
        125	  const hasReacted = (
        126	    reactions: NegotiationReaction[],
        127	    type: string
        128	  ) => reactions.some((r) => r.reactionType === type && r.agentId === agentId);
        129	
        130	  return (
        131	    <div className="negotiation-thread">
        132	      <h3>Negotiation Thread</h3>
        133	      {loading ? (
        134	        <div>Loading messages...</div>
        135	      ) : (
        136	        <div className="negotiation-messages">
        137	          {messages.map((msg) => (
        138	            <div key={msg.id} className="negotiation-message">
        139	              <div>
        140	                <strong>Agent {msg.agentId}</strong> [{new Date(msg.timestamp).toLocaleString()}]
        141	              </div>
        142	              <div>{msg.content}</div>
        143	              <div className="reactions-row">
        144	                {REACTION_TYPES.map((rt) => (
        145	                  <button
        146	                    key={rt.type}
        147	                    className={`reaction-btn${hasReacted(msg.reactions, rt.type) ? " reacted" : ""}`}
        148	                    aria-pressed={hasReacted(msg.reactions, rt.type)}
        149	                    aria-label={
        150	                      hasReacted(msg.reactions, rt.type)
        151	                        ? `Remove your ${rt.type} reaction`
        152	                        : `Add ${rt.type} reaction`
        153	                    }
        154	                    tabIndex={0}
        155	                    onKeyDown={(e) => {
        156	                      if (e.key === "Enter" || e.key === " ") {
        157	                        e.preventDefault();
        158	                        hasReacted(msg.reactions, rt.type)
        159	                          ? handleRemoveReaction(msg.id, rt.type)
        160	                          : handleAddReaction(msg.id, rt.type);
        161	                      }
        162	                    }}
        163	                    onClick={() =>
        164	                      hasReacted(msg.reactions, rt.type)
        165	                        ? handleRemoveReaction(msg.id, rt.type)
        166	                        : handleAddReaction(msg.id, rt.type)
        167	                    }
        168	                  >
        169	                    {rt.label} {getReactionCount(msg.reactions, rt.type)}
        170	                  </button>
        171	                ))}
        172	              </div>
        173	            </div>
        174	          ))}
        175	        </div>
        176	      )}
        177	      <div className="negotiation-new-message">
        178	        <textarea
        179	          value={newMessage}
        180	          onChange={(e) => setNewMessage(e.target.value)}
        181	          placeholder="Type your message to join or participate..."
        182	          rows={2}
        183	          disabled={posting}
        184	          aria-label="Type your message"
        185	          onKeyDown={(e) => {
        186	            if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        187	              handleSendMessage();
        188	            }
        189	          }}
        190	        />
        191	        <button
        192	          onClick={handleSendMessage}
        193	          disabled={posting || !newMessage.trim()}
        194	          aria-label="Send message"
        195	        >
        196	          {posting ? "Posting..." : "Send"}
        197	        </button>
        198	      </div>
        199	      {error && (
        200	        <div
        201	          className="negotiation-error"
        202	          role="alert"
        203	          aria-live="assertive"
        204	          style={{ color: "red", marginTop: "0.5rem" }}
        205	        >
        206	          {error}
        207	        </div>
        208	      )}
        209	      {success && (
        210	        <div
        211	          className="negotiation-success"
        212	          role="status"
        213	          aria-live="polite"
        214	          style={{ color: "green", marginTop: "0.5rem" }}
        215	        >
        216	          {success}
        217	        </div>
        218	      )}
        219	    </div>
        220	  );
        221	};
        222	
        223	export default NegotiationThread;

==============================================
FILE: ./frontend/src/components/NewProposalForm.tsx
==============================================

          1	import React, { useState } from 'react';
          2	import { useNavigate } from 'react-router-dom';
          3	import apiClient from '../api/apiClient';
          4	
          5	const NewProposalForm: React.FC = () => {
          6	  const [title, setTitle] = useState('');
          7	  const [description, setDescription] = useState('');
          8	  const [type, setType] = useState<'standard' | 'monetary'>('standard');
          9	  const [amount, setAmount] = useState<number | ''>('');
         10	  const [quorum, setQuorum] = useState<number>(50);
         11	  const [threshold, setThreshold] = useState<number>(0.5);
         12	  const [closeAt, setCloseAt] = useState<string>('');
         13	  const [vetoWindowEnd, setVetoWindowEnd] = useState<string>('');
         14	  const [error, setError] = useState<string | null>(null);
         15	  const navigate = useNavigate();
         16	
         17	  const handleSubmit = async (e: React.FormEvent) => {
         18	    e.preventDefault();
         19	    setError(null);
         20	
         21	    if (!title.trim() || !description.trim()) {
         22	      setError('Title and description are required.');
         23	      return;
         24	    }
         25	    if (type === 'monetary' && (amount === '' || amount <= 0)) {
         26	      setError('Amount must be a positive number for monetary proposals.');
         27	      return;
         28	    }
         29	    if (!closeAt || !vetoWindowEnd) {
         30	      setError('Close date and veto window end date are required.');
         31	      return;
         32	    }
         33	
         34	    try {
         35	      await apiClient.post('/api/proposals', {
         36	        title,
         37	        description,
         38	        type,
         39	        amount: type === 'monetary' ? amount : undefined,
         40	        quorum,
         41	        threshold,
         42	        closeAt,
         43	        vetoWindowEnd,
         44	      });
         45	      navigate('/proposals');
         46	    } catch (err) {
         47	      setError('Failed to create proposal.');
         48	    }
         49	  };
         50	
         51	  return (
         52	    <form onSubmit={handleSubmit}>
         53	      <h2>Create New Proposal</h2>
         54	      {error && <p style={{ color: 'red' }}>{error}</p>}
         55	      <div>
         56	        <label>Title:</label>
         57	        <input value={title} onChange={(e) => setTitle(e.target.value)} required />
         58	      </div>
         59	      <div>
         60	        <label>Description:</label>
         61	        <textarea value={description} onChange={(e) => setDescription(e.target.value)} required />
         62	      </div>
         63	      <div>
         64	        <label>Type:</label>
         65	        <select value={type} onChange={(e) => setType(e.target.value as any)}>
         66	          <option value="standard">Standard</option>
         67	          <option value="monetary">Monetary</option>
         68	        </select>
         69	      </div>
         70	      {type === 'monetary' && (
         71	        <div>
         72	          <label>Amount:</label>
         73	          <input
         74	            type="number"
         75	            value={amount}
         76	            onChange={(e) => setAmount(e.target.value === '' ? '' : Number(e.target.value))}
         77	            min="0"
         78	            step="0.01"
         79	            required={type === 'monetary'}
         80	          />
         81	        </div>
         82	      )}
         83	      <div>
         84	        <label>Quorum (%):</label>
         85	        <input
         86	          type="number"
         87	          value={quorum}
         88	          onChange={(e) => setQuorum(Number(e.target.value))}
         89	          min="10"
         90	          max="100"
         91	          required
         92	        />
         93	      </div>
         94	      <div>
         95	        <label>Threshold (0-1):</label>
         96	        <input
         97	          type="number"
         98	          value={threshold}
         99	          onChange={(e) => setThreshold(Number(e.target.value))}
        100	          min="0"
        101	          max="1"
        102	          step="0.01"
        103	          required
        104	        />
        105	      </div>
        106	      <div>
        107	        <label>Close At (ISO datetime):</label>
        108	        <input
        109	          type="datetime-local"
        110	          value={closeAt}
        111	          onChange={(e) => setCloseAt(e.target.value)}
        112	          required
        113	        />
        114	      </div>
        115	      <div>
        116	        <label>Veto Window End (ISO datetime):</label>
        117	        <input
        118	          type="datetime-local"
        119	          value={vetoWindowEnd}
        120	          onChange={(e) => setVetoWindowEnd(e.target.value)}
        121	          required
        122	        />
        123	      </div>
        124	      <button type="submit">Create Proposal</button>
        125	    </form>
        126	  );
        127	};
        128	
        129	export default NewProposalForm;

==============================================
FILE: ./frontend/src/components/OnboardingChat.css
==============================================

          1	.onboarding-chat-container {
          2	  max-width: 800px;
          3	  margin: 0 auto;
          4	  padding: 2rem 1rem;
          5	  min-height: 80vh;
          6	  display: flex;
          7	  flex-direction: column;
          8	}
          9	
         10	.onboarding-header {
         11	  text-align: center;
         12	  margin-bottom: 2rem;
         13	}
         14	
         15	.onboarding-header h2 {
         16	  font-size: 1.8rem;
         17	  margin-bottom: 0.5rem;
         18	  color: #2d3748;
         19	}
         20	
         21	.onboarding-header p {
         22	  color: #4a5568;
         23	  font-size: 1.1rem;
         24	}
         25	
         26	.onboarding-progress {
         27	  margin-bottom: 2rem;
         28	}
         29	
         30	.progress-bar {
         31	  height: 8px;
         32	  background-color: #e2e8f0;
         33	  border-radius: 4px;
         34	  overflow: hidden;
         35	  margin-bottom: 0.5rem;
         36	}
         37	
         38	.progress-fill {
         39	  height: 100%;
         40	  background-color: #4299e1;
         41	  border-radius: 4px;
         42	  transition: width 0.3s ease;
         43	}
         44	
         45	.stage-label {
         46	  text-align: right;
         47	  font-size: 0.9rem;
         48	  color: #718096;
         49	}
         50	
         51	.chat-wrapper {
         52	  flex: 1;
         53	  margin-bottom: 2rem;
         54	  min-height: 400px;
         55	}
         56	
         57	/* Issues matrix layout within onboarding flow */
         58	.issues-matrix {
         59	  margin: 1rem 0 2rem 0;
         60	  border-radius: 8px;
         61	  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
         62	  transition: all 0.3s ease;
         63	}
         64	
         65	.issues-matrix:hover {
         66	  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
         67	}
         68	
         69	/* Responsive layout for the issues matrix in onboarding */
         70	@media (max-width: 768px) {
         71	  .issues-matrix .issues-list {
         72	    grid-template-columns: 1fr;
         73	    gap: 0.75rem;
         74	  }
         75	  
         76	  .issues-matrix-heading {
         77	    font-size: 1rem;
         78	  }
         79	}
         80	
         81	.onboarding-footer {
         82	  font-size: 0.9rem;
         83	  color: #718096;
         84	  text-align: center;
         85	  padding: 1rem;
         86	  background-color: #f7fafc;
         87	  border-radius: 8px;
         88	}
         89	
         90	/* Loading state */
         91	.onboarding-chat-container.loading {
         92	  justify-content: center;
         93	  align-items: center;
         94	  text-align: center;
         95	}
         96	
         97	.loading-spinner {
         98	  width: 40px;
         99	  height: 40px;
        100	  border-radius: 50%;
        101	  border: 3px solid rgba(66, 153, 225, 0.2);
        102	  border-top-color: #4299e1;
        103	  animation: spin 1s linear infinite;
        104	  margin-bottom: 1rem;
        105	}
        106	
        107	@keyframes spin {
        108	  to {
        109	    transform: rotate(360deg);
        110	  }
        111	}
        112	
        113	/* Error state */
        114	.onboarding-chat-container.error {
        115	  justify-content: center;
        116	  align-items: center;
        117	}
        118	
        119	.error-message {
        120	  text-align: center;
        121	  padding: 2rem;
        122	  background-color: #fff5f5;
        123	  border-radius: 8px;
        124	  border-left: 4px solid #f56565;
        125	  max-width: 500px;
        126	}
        127	
        128	.error-message h3 {
        129	  color: #c53030;
        130	  margin-bottom: 1rem;
        131	}
        132	
        133	.error-message button {
        134	  background-color: #f56565;
        135	  color: white;
        136	  border: none;
        137	  padding: 0.5rem 1rem;
        138	  border-radius: 4px;
        139	  cursor: pointer;
        140	  margin-top: 1rem;
        141	  font-weight: 600;
        142	}
        143	
        144	.error-message button:hover {
        145	  background-color: #c53030;
        146	}
        147	
        148	/* Responsive styles */
        149	@media (max-width: 768px) {
        150	  .onboarding-chat-container {
        151	    padding: 1rem;
        152	  }
        153	  
        154	  .onboarding-header h2 {
        155	    font-size: 1.5rem;
        156	  }
        157	  
        158	  .chat-wrapper {
        159	    min-height: 300px;
        160	  }
        161	}

==============================================
FILE: ./frontend/src/components/OnboardingChat.tsx
==============================================

          1	import React, { useState, useEffect, useCallback } from 'react';
          2	import { useNavigate } from 'react-router-dom';
          3	import { useAuth } from '../context/AuthContext';
          4	import ChatInterface, { ChatMessage } from './chat/ChatInterface'; // Import ChatMessage
          5	import IssuesMatrix, { Issue } from './IssuesMatrix'; // Import the IssuesMatrix component
          6	import './OnboardingChat.css';
          7	
          8	/**
          9	 * OnboardingProgress component to show the current progress of the onboarding process
         10	 */
         11	interface OnboardingProgressProps {
         12	  step: number;
         13	}
         14	
         15	const OnboardingProgress: React.FC<OnboardingProgressProps> = ({ step }) => {
         16	  return (
         17	    <div className="onboarding-progress">
         18	      <div className="progress-bar">
         19	        <div
         20	          className="progress-fill"
         21	          style={{ width: `${((step + 1) / 9) * 100}%` }}
         22	        ></div>
         23	      </div>
         24	      <div className="stage-label">
         25	        Step {step + 1} of 9
         26	      </div>
         27	    </div>
         28	  );
         29	};
         30	
         31	/**
         32	 * Main OnboardingChat component that replaces the form-based wizard
         33	 */
         34	const OnboardingChat: React.FC = () => {
         35	  const { user } = useAuth();
         36	  const navigate = useNavigate();
         37	  // Important: All hooks must be called here at the top level, before any conditional returns
         38	  const [agentId, setAgentId] = useState<string | null>(null);
         39	  const [step, setStep] = useState(0);
         40	  const [metadata, setMetadata] = useState<any>({});
         41	  const [loading, setLoading] = useState(true);
         42	  const [error, setError] = useState<string | null>(null);
         43	  const [sending, setSending] = useState(false); // Declare sending state
         44	  const [agent, setAgent] = useState<{ name: string; color: string } | null>(null); // Declare agent state
         45	  const [issueMatrix, setIssueMatrix] = useState<Issue[]>([]); // State for issues matrix
         46	  
         47	  // Add diagnostic logging whenever issueMatrix changes
         48	  useEffect(() => {
         49	  }, [issueMatrix]);
         50	  
         51	
         52	  // State to hold new messages to pass to ChatInterface
         53	  const [newChatMessages, setNewChatMessages] = useState<ChatMessage[]>([]); // Explicitly type state
         54	
         55	  // Get or create agent when component mounts
         56	  // Helper to fetch agent info with JWT
         57	  const fetchAgentInfo = async () => {
         58	    const response = await fetch('/api/agents/me', {
         59	      headers: {
         60	        'Authorization': `Bearer ${localStorage.getItem('token')}`
         61	      }
         62	    });
         63	    if (!response.ok) throw new Error('Failed to fetch agent');
         64	    return response.json();
         65	  };
         66	
         67	  useEffect(() => {
         68	    const getOrCreateAgent = async (triggerInitialMessage = false) => {
         69	      try {
         70	        setLoading(true);
         71	        setError(null); // Clear error on new attempt
         72	        
         73	        const data = await fetchAgentInfo();
         74	        
         75	        setAgentId(data.id);
         76	        setAgent({ name: data.name, color: data.color }); // Update agent state with fetched data
         77	        
         78	        // Enhanced check for initial page load
         79	        console.log('[OnboardingChat] Initial agent fetch - onboardingCompleted status:', data.onboardingCompleted);
         80	        
         81	        if (data.onboardingCompleted) {
         82	          console.log('[OnboardingChat] Onboarding already completed, redirecting to dashboard');
         83	          handleOnboardingComplete();
         84	          return;
         85	        }
         86	        
         87	        // If requested, trigger initial agent message if no messages exist
         88	        if (triggerInitialMessage) {
         89	          try {
         90	            const messagesRes = await fetch(`/api/agents/${data.id}/messages?onboarding=true`, {
         91	              headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
         92	            });
         93	            
         94	            if (!messagesRes.ok) {
         95	              throw new Error(`Failed to fetch messages: ${messagesRes.status}`);
         96	            }
         97	            
         98	            const messagesData = await messagesRes.json();
         99	            
        100	            // Only send proactive message if there are truly no messages (from user or agent)
        101	            if (!messagesData.messages || messagesData.messages.length === 0) {
        102	              
        103	              // Create a temporary agent message to show immediately
        104	              const tempAgentMessage: ChatMessage = {
        105	                id: `temp-greeting-${Date.now()}`,
        106	                content: "(1/9) Welcome! What is your name?",
        107	                sender: 'agent',
        108	                timestamp: new Date().toISOString(),
        109	                metadata: {
        110	                  step: 0,
        111	                  nextStep: 1,
        112	                  agentName: 'Agent',
        113	                  isOnboarding: true,
        114	                  completedOnboarding: false
        115	                }
        116	              };
        117	              
        118	              // Show a temporary message immediately while the real message loads
        119	              setNewChatMessages(prev => [...prev, tempAgentMessage]);
        120	              
        121	              // Send actual request to get the real initial message
        122	              const initResponse = await fetch('/api/onboarding/message', {
        123	                method: 'POST',
        124	                headers: {
        125	                  'Content-Type': 'application/json',
        126	                  'Authorization': `Bearer ${localStorage.getItem('token')}`
        127	                },
        128	                body: JSON.stringify({
        129	                  agentId: data.id,
        130	                  message: '', // Empty message triggers agent hello
        131	                  step: 0
        132	                })
        133	              });
        134	              
        135	              if (!initResponse.ok) {
        136	                throw new Error(`Failed to send initial message: ${initResponse.status}`);
        137	              }
        138	              
        139	              const initData = await initResponse.json();
        140	              
        141	              // Replace the temporary message with the real one
        142	              if (initData.agentMessage) {
        143	                setNewChatMessages(prev => {
        144	                  const filtered = prev.filter(msg => !msg.id.startsWith('temp-greeting-'));
        145	                  return [...filtered, initData.agentMessage];
        146	                });
        147	              }
        148	            } else {
        149	            }
        150	          } catch (err) {
        151	            // Don't fail the whole component if just the initial message fails
        152	          }
        153	        }
        154	      } catch (err: any) {
        155	        if (err.message === 'Failed to fetch agent') {
        156	          // Create new agent if doesn't exist
        157	          const createResponse = await fetch('/api/agents', {
        158	            method: 'POST',
        159	            headers: {
        160	              'Content-Type': 'application/json',
        161	              'Authorization': `Bearer ${localStorage.getItem('token')}`
        162	            },
        163	            body: JSON.stringify({
        164	              name: `${user?.email?.split('@')[0]}'s Agent`,
        165	              color: generateRandomColor()
        166	            })
        167	          });
        168	          if (createResponse.ok) {
        169	            const newAgent = await createResponse.json();
        170	            setAgentId(newAgent.id);
        171	            setAgent({ name: newAgent.name, color: newAgent.color }); // Update agent state with new agent data
        172	          } else {
        173	            setError('Failed to create agent');
        174	          }
        175	        } else {
        176	          setError('Failed to initialize onboarding. Please try again later.');
        177	        }
        178	      } finally {
        179	        setLoading(false);
        180	      }
        181	    };
        182	    if (user) {
        183	      getOrCreateAgent(true); // Always trigger initial message on first load
        184	    }
        185	  }, [user, navigate]);
        186	
        187	  // Handler for onboarding completion
        188	  const handleOnboardingComplete = () => {
        189	    console.log('[OnboardingChat] handleOnboardingComplete called, navigating to dashboard');
        190	    
        191	    // Update local state to indicate completion
        192	    try {
        193	      // Force agent refresh on dashboard load
        194	      localStorage.setItem('agent_refresh_needed', 'true');
        195	      
        196	      // Navigate to dashboard
        197	      navigate('/dashboard');
        198	      
        199	      // Set a timeout just in case the navigation doesn't trigger
        200	      setTimeout(() => {
        201	        console.log('[OnboardingChat] Navigation timeout, forcing redirect');
        202	        window.location.href = '/dashboard';
        203	      }, 500);
        204	    } catch (err) {
        205	      console.error('[OnboardingChat] Error during navigation to dashboard:', err);
        206	      // Force direct navigation if React router fails
        207	      window.location.href = '/dashboard';
        208	    }
        209	  };
        210	
        211	  // Generate a random color for a new agent
        212	  const generateRandomColor = () => {
        213	    const colors = [
        214	      '#4299E1', // Blue
        215	      '#48BB78', // Green
        216	      '#F6AD55', // Orange
        217	      '#9F7AEA', // Purple
        218	      '#F56565', // Red
        219	      '#ED8936', // Deep Orange
        220	      '#38B2AC', // Teal
        221	      '#667EEA'  // Indigo
        222	    ];
        223	    return colors[Math.floor(Math.random() * colors.length)];
        224	  };
        225	
        226	  // Handle sending onboarding messages and updating FSM state
        227	  const handleSendMessage = async (message: string) => {
        228	    if (!agentId) return;
        229	
        230	    // Optimistically add user message to the chat
        231	    const tempUserMessage: ChatMessage = {
        232	      id: `temp-${Date.now()}`, // Temporary ID
        233	      content: message,
        234	      sender: 'user',
        235	      timestamp: new Date().toISOString(),
        236	      metadata: { isTemp: true } // Mark as temporary
        237	    };
        238	    setNewChatMessages(prevMessages => [...prevMessages, tempUserMessage]);
        239	
        240	    try {
        241	      setSending(true); // Set sending state to true
        242	      const response = await fetch('/api/onboarding/message', {
        243	        method: 'POST',
        244	        headers: {
        245	          'Content-Type': 'application/json',
        246	          'Authorization': `Bearer ${localStorage.getItem('token')}`
        247	        },
        248	        body: JSON.stringify({
        249	          agentId,
        250	          message,
        251	          step: metadata.step || 0,
        252	          selectedIssues: metadata.selectedIssues,
        253	          issueQueue: metadata.issueQueue,
        254	          currentIssueIndex: metadata.currentIssueIndex
        255	        })
        256	      });
        257	      if (response.ok) {
        258	        const data = await response.json();
        259	        // Update step and metadata states immediately
        260	        setStep(data.nextStep ?? 0);
        261	        setMetadata(data.metadata || {});
        262	
        263	
        264	        // LIVE POSITIONS MATRIX UPDATE: If extractedPreferences.issuesMatrix is present, update immediately
        265	        if (data.extractedPreferences && Array.isArray(data.extractedPreferences.issuesMatrix)) {
        266	          // Log what we received from backend
        267	          console.log('[OnboardingChat] Received issuesMatrix from backend:',
        268	                     JSON.stringify(data.extractedPreferences.issuesMatrix));
        269	          
        270	          // Map backend issuesMatrix to Issue[] for the component
        271	          const liveMatrix: Issue[] = data.extractedPreferences.issuesMatrix.map((issue: any) => ({
        272	            id: issue.id,
        273	            title: issue.title || `Issue ${issue.id}`,
        274	            stance: issue.stance,
        275	            reason: issue.reason || issue.summary, // Use summary as fallback for reason
        276	            description: issue.description || '',
        277	            isPriority: !!issue.isPriority
        278	          }));
        279	          
        280	          console.log('[OnboardingChat] Updated issue matrix:', JSON.stringify(liveMatrix));
        281	          setIssueMatrix(liveMatrix);
        282	        }
        283	
        284	        // If onboarding is completed, build the positions matrix from extractedPreferences.issueStances
        285	        if (data.completedOnboarding && data.extractedPreferences && Array.isArray(data.extractedPreferences.issueStances)) {
        286	          // Map issue numbers to titles using the latest issue list from metadata or fallback
        287	          const issueNumberToTitle: Record<string, string> = {};
        288	          if (data.metadata && data.metadata.selectedIssues && data.metadata.issueQueue && data.metadata.issueDetails) {
        289	            // If backend provides issueDetails, use it
        290	            Object.entries(data.metadata.issueDetails).forEach(([num, detail]: [string, any]) => {
        291	              issueNumberToTitle[num] = detail.title || `Issue ${num}`;
        292	            });
        293	          } else if (data.metadata && data.metadata.selectedIssues) {
        294	            // Fallback: use generic titles
        295	            data.metadata.selectedIssues.forEach((num: string) => {
        296	              issueNumberToTitle[num] = `Issue ${num}`;
        297	            });
        298	          }
        299	          // Build the positions matrix
        300	          const positionsMatrix: Issue[] = data.extractedPreferences.issueStances.map((stanceObj: any, idx: number) => {
        301	            // Split reason into bullet points if possible
        302	            let bulletPoints: string[] = [];
        303	            if (stanceObj.reason) {
        304	              bulletPoints = stanceObj.reason.split(/[\n•\-•]+/).map((s: string) => s.trim()).filter((s: string) => s.length > 0);
        305	            }
        306	            return {
        307	              id: stanceObj.issue,
        308	              title: issueNumberToTitle[stanceObj.issue] || stanceObj.issue,
        309	              stance: stanceObj.stance,
        310	              reason: bulletPoints.length > 1 ? bulletPoints : stanceObj.reason,
        311	              isPriority: data.extractedPreferences.topPriorityIssue === stanceObj.issue
        312	            };
        313	          });
        314	          setIssueMatrix(positionsMatrix);
        315	        } else if (!(
        316	          data.extractedPreferences && Array.isArray(data.extractedPreferences.issuesMatrix)
        317	        )) {
        318	          // Removed fallback call to updateIssueMatrix
        319	        }
        320	
        321	        // Re-fetch agent info after onboarding answers to update name/color
        322	        // This is important to get the potentially updated agent name and color
        323	        try {
        324	          const agentData = await fetchAgentInfo();
        325	          if (agentData) {
        326	             setAgentId(agentData.id); // Ensure agentId is still correct
        327	             setAgent({ name: agentData.name, color: agentData.color });
        328	          } else {
        329	          }
        330	        } catch (err) {
        331	        }
        332	
        333	        // Enhanced onboarding completion detection with extra logging
        334	        console.log('[DEBUG-FRONTEND] Checking onboarding completion flags:', {
        335	          completedOnboarding: data.completedOnboarding,
        336	          currentStep: step,
        337	          nextStep: data.nextStep,
        338	          messageMetadata: data.agentMessage?.metadata,
        339	          hasExtractedPreferences: !!data.extractedPreferences,
        340	          agentMessageId: data.agentMessage?.id
        341	        });
        342	
        343	        // Fetch the agent info directly to verify onboardingCompleted status
        344	        try {
        345	          console.log('[DEBUG-FRONTEND] Fetching latest agent info to verify onboardingCompleted status');
        346	          const agentVerifyResponse = await fetch('/api/agents/me', {
        347	            headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
        348	          });
        349	          
        350	          if (agentVerifyResponse.ok) {
        351	            const agentData = await agentVerifyResponse.json();
        352	            console.log('[DEBUG-FRONTEND] Latest agent data:', {
        353	              id: agentData.id,
        354	              name: agentData.name,
        355	              onboardingCompleted: agentData.onboardingCompleted
        356	            });
        357	            
        358	            // If agent data shows onboarding is completed, redirect
        359	            if (agentData.onboardingCompleted) {
        360	              console.log('[DEBUG-FRONTEND] Agent data shows onboardingCompleted=true, redirecting to dashboard');
        361	              handleOnboardingComplete();
        362	              return; // Immediately return to ensure redirection happens
        363	            }
        364	          } else {
        365	            console.error('[DEBUG-FRONTEND] Failed to fetch agent data:', await agentVerifyResponse.text());
        366	          }
        367	        } catch (agentError) {
        368	          console.error('[DEBUG-FRONTEND] Error fetching agent data:', agentError);
        369	        }
        370	
        371	        if (data.completedOnboarding || step >= 8 || data.nextStep >= 8) {
        372	          console.log('[DEBUG-FRONTEND] Detected completedOnboarding flag from message response, redirecting to dashboard');
        373	          handleOnboardingComplete();
        374	          return; // Immediately return to ensure redirection happens
        375	        }
        376	
        377	        // Additional check for the metadata of the agent message
        378	        if (data.agentMessage &&
        379	            data.agentMessage.metadata &&
        380	            (data.agentMessage.metadata.completedOnboarding ||
        381	             data.agentMessage.metadata.onboardingComplete ||
        382	             data.agentMessage.metadata.step >= 8)) {
        383	          console.log('[DEBUG-FRONTEND] Detected completion in agent message metadata, redirecting to dashboard');
        384	          handleOnboardingComplete();
        385	          return; // Immediately return to ensure redirection happens
        386	        }
        387	        // Pass the new messages to ChatInterface to append
        388	        const newMessages: ChatMessage[] = []; // Explicitly type newMessages array
        389	        if (data.userMessage) {
        390	          newMessages.push(data.userMessage);
        391	        }
        392	        if (data.agentMessage) {
        393	          newMessages.push(data.agentMessage);
        394	        }
        395	        if (newMessages.length > 0) {
        396	          // Replace the temporary message with the actual user message and add the agent message
        397	          setNewChatMessages(prevMessages => {
        398	             const filteredMessages = prevMessages.filter(msg => !msg.id.startsWith('temp-'));
        399	             return [...filteredMessages, ...newMessages];
        400	          });
        401	        }
        402	      } else {
        403	        throw new Error('Failed to send onboarding message');
        404	      }
        405	    } catch (err) {
        406	      setError('Failed to send onboarding message. Please try again.');
        407	      // Remove the temporary message on error
        408	      setNewChatMessages(prevMessages => prevMessages.filter(msg => msg.id !== tempUserMessage.id));
        409	    } finally {
        410	      setSending(false); // Set sending state to false
        411	    }
        412	  };
        413	
        414	  // Add log to confirm when handleSendMessage is called and with what data
        415	  const handleSendMessageWithLog = async (message: string) => {
        416	    await handleSendMessage(message);
        417	  };
        418	
        419	  // Removed updateIssueMatrix function as it's no longer needed
        420	
        421	  // Conditional returns must come after all hooks are defined
        422	  if (loading) {
        423	    return (
        424	      <div className="onboarding-chat-container loading">
        425	        <div className="loading-spinner"></div>
        426	        <p>Setting up your personal agent...</p>
        427	      </div>
        428	    );
        429	  }
        430	
        431	  if (error) {
        432	    return (
        433	      <div className="onboarding-chat-container error">
        434	        <div className="error-message">
        435	          <h3>Oops! Something went wrong</h3>
        436	          <p>{error}</p>
        437	          <button onClick={() => window.location.reload()}>Try Again</button>
        438	        </div>
        439	      </div>
        440	    );
        441	  }
        442	
        443	  return (
        444	    <div className="onboarding-chat-container">
        445	      <div className="onboarding-header">
        446	        <h2>Welcome to Praxis</h2>
        447	        <p>Let's set up your personal representative agent to advance your interests.</p>
        448	        <p><small>Praxis Agents operate under the Prime Directive of Representational Primacy</small></p>
        449	      </div>
        450	      <OnboardingProgress step={step} />
        451	      
        452	      {/* Display issues matrix - always show after step 1 even if empty */}
        453	      {step > 0 && (
        454	        <div className="issues-matrix-container">
        455	          <IssuesMatrix
        456	            selectedIssues={issueMatrix}
        457	            step={step}
        458	            agentColor={agent?.color || "#4299E1"}
        459	          />
        460	          {issueMatrix.length === 0 && step > 1 && (
        461	            <div className="matrix-debug-info">
        462	              <p><small>Matrix is empty. Selected issues count: {metadata?.selectedIssues?.length || 0}</small></p>
        463	              <button
        464	                className="debug-button"
        465	                onClick={() => {
        466	                  if (metadata?.selectedIssues?.length > 0) {
        467	                    // Create placeholder issues for debugging
        468	                    const placeholders = (metadata.selectedIssues as string[]).map(id => ({
        469	                      id,
        470	                      title: `Issue ${id}`,
        471	                      description: '',
        472	                      stance: undefined,
        473	                      reason: undefined,
        474	                      isPriority: false
        475	                    }));
        476	                    setIssueMatrix(placeholders);
        477	                  }
        478	                }}
        479	              >
        480	                Force Load Matrix
        481	              </button>
        482	            </div>
        483	          )}
        484	        </div>
        485	      )}
        486	      
        487	      {agentId && (
        488	        <div className="chat-wrapper">
        489	          <ChatInterface
        490	            agentId={agentId}
        491	            isOnboarding={true}
        492	            onSendMessage={handleSendMessageWithLog}
        493	            onboardingStep={step}
        494	            onboardingMetadata={metadata}
        495	            onComplete={handleOnboardingComplete}
        496	            newMessages={newChatMessages} // Pass new messages to ChatInterface
        497	            agentName={agent?.name} // Pass agent name to ChatInterface
        498	            agentColor={agent?.color} // Pass agent color to ChatInterface
        499	          />
        500	        </div>
        501	      )}
        502	      <div className="onboarding-footer">
        503	        <p>
        504	          Your Praxis Agent will learn from this conversation to better represent your real interests.
        505	          It will advance your values following the priority order: 1) Representational Primacy, 2) Transparency,
        506	          3) Constructive-Cooperation, 4) Civility, 5) Non-Manipulation, and 6) Self-Consistency.
        507	        </p>
        508	        <button
        509	          className="onboarding-reset-btn"
        510	          style={{ marginTop: 16, background: '#eee', color: '#333', border: '1px solid #ccc', borderRadius: 4, padding: '6px 16px', cursor: 'pointer' }}
        511	          onClick={async () => {
        512	            if (!agentId) return;
        513	            setLoading(true);
        514	            setError(null);
        515	            try {
        516	              const response = await fetch(`/api/onboarding/reset`, {
        517	                method: 'POST',
        518	                headers: {
        519	                  'Content-Type': 'application/json',
        520	                  'Authorization': `Bearer ${localStorage.getItem('token')}`
        521	                },
        522	                body: JSON.stringify({ agentId })
        523	              });
        524	              if (!response.ok) throw new Error('Failed to reset onboarding');
        525	              // Re-fetch agent info and reset state
        526	              const data = await fetchAgentInfo();
        527	              setAgentId(data.id);
        528	              setAgent({ name: data.name, color: data.color }); // Update agent state with fetched data
        529	              setStep(0);
        530	              setMetadata({});
        531	              // Trigger initial agent message after reset
        532	              await fetch('/api/onboarding/message', {
        533	                method: 'POST',
        534	                headers: {
        535	                  'Content-Type': 'application/json',
        536	                  'Authorization': `Bearer ${localStorage.getItem('token')}`
        537	                },
        538	                body: JSON.stringify({
        539	                  agentId: data.id,
        540	                  message: '',
        541	                  step: 0
        542	                })
        543	              });
        544	            } catch (err) {
        545	              setError('Failed to reset onboarding. Please try again.');
        546	            } finally {
        547	              setLoading(false);
        548	            }
        549	          }}
        550	        >
        551	          Reset Onboarding
        552	        </button>
        553	      </div>
        554	    </div>
        555	  );
        556	};
        557	
        558	export default OnboardingChat;

==============================================
FILE: ./frontend/src/components/OnboardingWizard.tsx
==============================================

          1	import React, { useState } from 'react';
          2	import { onboarding } from '../api/apiClient';
          3	import { useAuth } from '../context/AuthContext';
          4	import { useNavigate } from 'react-router-dom';
          5	
          6	const OnboardingWizard: React.FC = () => {
          7	    const { user } = useAuth();
          8	    const navigate = useNavigate();
          9	    const [step, setStep] = useState(1);
         10	    const [formData, setFormData] = useState({
         11	        agentName: '',
         12	        agentColor: '#FFFFFF', // Default color
         13	        priority: 'security',
         14	        risk_tolerance: 'low',
         15	        communication_style: 'direct',
         16	        digestFrequency: 24,
         17	        digestTone: 'neutral',
         18	    });
         19	    const [isLoading, setIsLoading] = useState(false);
         20	    const [error, setError] = useState<string | null>(null);
         21	
         22	    const totalSteps = 3; // Adjust as needed
         23	
         24	    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
         25	        const { name, value } = e.target;
         26	        setFormData(prev => ({ ...prev, [name]: value }));
         27	    };
         28	
         29	    const handleNext = async () => {
         30	        setIsLoading(true);
         31	        setError(null);
         32	        let stepData: any = {};
         33	        let apiStep = '';
         34	
         35	        switch (step) {
         36	            case 1: // Name & Appearance
         37	                stepData = { agentName: formData.agentName, agentColor: formData.agentColor };
         38	                apiStep = 'name_appearance';
         39	                break;
         40	            case 2: // Preferences
         41	                // Construct preferences object from form fields
         42	                const preferencesObj = {
         43	                    priority: formData.priority,
         44	                    risk_tolerance: formData.risk_tolerance,
         45	                    communication_style: formData.communication_style
         46	                };
         47	                stepData = { preferences: preferencesObj };
         48	                apiStep = 'preferences';
         49	                break;
         50	            case 3: // Digest Settings
         51	                stepData = { digestFrequency: Number(formData.digestFrequency), digestTone: formData.digestTone };
         52	                apiStep = 'digest_settings';
         53	                break;
         54	            default:
         55	                setIsLoading(false);
         56	                return;
         57	        }
         58	
         59	        try {
         60	            // Use the API client to make the actual API call
         61	            await onboarding.saveStep(step, stepData);
         62	
         63	            if (step < totalSteps) {
         64	                setStep(prev => prev + 1);
         65	            } else {
         66	                // Onboarding complete - redirect to dashboard
         67	                navigate('/dashboard');
         68	            }
         69	        } catch (err: any) {
         70	            setError(err.message || 'An error occurred.');
         71	        } finally {
         72	            setIsLoading(false);
         73	        }
         74	    };
         75	
         76	    const handlePrevious = () => {
         77	        if (step > 1) {
         78	            setStep(prev => prev - 1);
         79	        }
         80	    };
         81	
         82	    return (
         83	        <div className="onboarding-container">
         84	            <h2>Onboarding Wizard (Step {step}/{totalSteps})</h2>
         85	            {error && <div className="error-message">Error: {error}</div>}
         86	
         87	            {step === 1 && (
         88	                <div>
         89	                    <h3>Name Your Agent</h3>
         90	                    <label>
         91	                        Agent Name:
         92	                        <input type="text" name="agentName" value={formData.agentName} onChange={handleChange} required />
         93	                    </label>
         94	                    <br />
         95	                    <label>
         96	                        Agent Color:
         97	                        <input type="color" name="agentColor" value={formData.agentColor} onChange={handleChange} />
         98	                    </label>
         99	                </div>
        100	            )}
        101	
        102	            {step === 2 && (
        103	                <div>
        104	                    <h3>Set Agent Preferences</h3>
        105	                    
        106	                    <div className="preference-group">
        107	                        <label>Priority:</label>
        108	                        <select
        109	                            name="priority"
        110	                            value={formData.priority}
        111	                            onChange={handleChange}
        112	                        >
        113	                            <option value="security">Security</option>
        114	                            <option value="performance">Performance</option>
        115	                            <option value="cost">Cost</option>
        116	                            <option value="innovation">Innovation</option>
        117	                        </select>
        118	                    </div>
        119	                    
        120	                    <div className="preference-group">
        121	                        <label>Risk Tolerance:</label>
        122	                        <select
        123	                            name="risk_tolerance"
        124	                            value={formData.risk_tolerance}
        125	                            onChange={handleChange}
        126	                        >
        127	                            <option value="low">Low</option>
        128	                            <option value="medium">Medium</option>
        129	                            <option value="high">High</option>
        130	                        </select>
        131	                    </div>
        132	                    
        133	                    <div className="preference-group">
        134	                        <label>Communication Style:</label>
        135	                        <select
        136	                            name="communication_style"
        137	                            value={formData.communication_style}
        138	                            onChange={handleChange}
        139	                        >
        140	                            <option value="direct">Direct</option>
        141	                            <option value="detailed">Detailed</option>
        142	                            <option value="concise">Concise</option>
        143	                        </select>
        144	                    </div>
        145	                </div>
        146	            )}
        147	
        148	            {step === 3 && (
        149	                <div>
        150	                    <h3>Configure Digests</h3>
        151	                    <label>
        152	                        Frequency (hours):
        153	                        <input type="number" name="digestFrequency" value={formData.digestFrequency} onChange={handleChange} min="1" />
        154	                    </label>
        155	                    <br />
        156	                    <label>
        157	                        Tone:
        158	                        <select name="digestTone" value={formData.digestTone} onChange={handleChange}>
        159	                            <option value="neutral">Neutral</option>
        160	                            <option value="friendly">Friendly</option>
        161	                            <option value="formal">Formal</option>
        162	                        </select>
        163	                    </label>
        164	                </div>
        165	            )}
        166	
        167	            <hr />
        168	            <button onClick={handlePrevious} disabled={step === 1 || isLoading}>
        169	                Previous
        170	            </button>
        171	            <button onClick={handleNext} disabled={isLoading}>
        172	                {isLoading ? 'Saving...' : (step === totalSteps ? 'Finish Onboarding' : 'Next')}
        173	            </button>
        174	        </div>
        175	    );
        176	};
        177	
        178	export default OnboardingWizard;

==============================================
FILE: ./frontend/src/components/__tests__/NegotiationThread.test.tsx
==============================================

          1	import React from "react";
          2	import { render, screen, fireEvent, waitFor } from "@testing-library/react";
          3	import NegotiationThread from "../NegotiationThread";
          4	
          5	jest.mock("../../api/apiClient", () => ({
          6	  negotiations: {
          7	    getMessages: jest.fn().mockResolvedValue({ data: [
          8	      {
          9	        id: "msg1",
         10	        negotiationId: "neg1",
         11	        agentId: "agent1",
         12	        content: "Test message",
         13	        messageType: "statement",
         14	        timestamp: new Date().toISOString(),
         15	        reactions: [],
         16	      }
         17	    ]}),
         18	    postMessage: jest.fn().mockResolvedValue({}),
         19	    addReaction: jest.fn().mockResolvedValue({}),
         20	    removeReaction: jest.fn().mockResolvedValue({}),
         21	  }
         22	}));
         23	
         24	describe("NegotiationThread", () => {
         25	  it("renders messages and allows posting", async () => {
         26	    render(<NegotiationThread negotiationId="neg1" agentId="agent1" />);
         27	    expect(screen.getByText(/Negotiation Thread/i)).toBeInTheDocument();
         28	    await waitFor(() => expect(screen.getByText(/Test message/i)).toBeInTheDocument());
         29	
         30	    // Simulate typing and posting a message
         31	    fireEvent.change(screen.getByLabelText(/Type your message/i), { target: { value: "Hello world" } });
         32	    fireEvent.click(screen.getByLabelText(/Send message/i));
         33	    await waitFor(() => expect(screen.getByText(/Message posted!/i)).toBeInTheDocument());
         34	  });
         35	
         36	  it("allows adding and removing a reaction", async () => {
         37	    render(<NegotiationThread negotiationId="neg1" agentId="agent1" />);
         38	    await waitFor(() => expect(screen.getByText(/Test message/i)).toBeInTheDocument());
         39	
         40	    // Add a reaction
         41	    fireEvent.click(screen.getByText("👍 0"));
         42	    await waitFor(() => expect(screen.getByText(/Reaction added!/i)).toBeInTheDocument());
         43	
         44	    // Remove a reaction
         45	    fireEvent.click(screen.getByText("👍 0"));
         46	    await waitFor(() => expect(screen.getByText(/Reaction removed./i)).toBeInTheDocument());
         47	  });
         48	});

==============================================
FILE: ./frontend/src/components/chat/ChatHistory.css
==============================================

          1	.chat-history {
          2	  display: flex;
          3	  flex-direction: column;
          4	  height: 100%;
          5	  max-height: 500px;
          6	  overflow-y: auto;
          7	  padding: 1rem;
          8	  background-color: #f8f9fa;
          9	  border-radius: 8px;
         10	  border: 1px solid #e2e8f0;
         11	}
         12	
         13	/* Styling scrollbar for webkit browsers */
         14	.chat-history::-webkit-scrollbar {
         15	  width: 6px;
         16	}
         17	
         18	.chat-history::-webkit-scrollbar-track {
         19	  background: #f1f1f1;
         20	}
         21	
         22	.chat-history::-webkit-scrollbar-thumb {
         23	  background: #c1c1c1;
         24	  border-radius: 3px;
         25	}
         26	
         27	.chat-history::-webkit-scrollbar-thumb:hover {
         28	  background: #a8a8a8;
         29	}
         30	
         31	.loading-indicator {
         32	  text-align: center;
         33	  padding: 10px;
         34	  color: #666;
         35	  font-size: 0.9rem;
         36	  margin-bottom: 1rem;
         37	  background-color: #f0f4f8;
         38	  border-radius: 6px;
         39	}
         40	
         41	.load-more-button {
         42	  align-self: center;
         43	  margin-bottom: 1rem;
         44	  padding: 8px 16px;
         45	  background-color: #e2e8f0;
         46	  border: none;
         47	  border-radius: 6px;
         48	  color: #4a5568;
         49	  font-size: 0.9rem;
         50	  cursor: pointer;
         51	  transition: background-color 0.2s;
         52	}
         53	
         54	.load-more-button:hover {
         55	  background-color: #cbd5e0;
         56	}
         57	
         58	.empty-chat {
         59	  display: flex;
         60	  flex-direction: column;
         61	  align-items: center;
         62	  justify-content: center;
         63	  padding: 2rem;
         64	  text-align: center;
         65	  color: #718096;
         66	  height: 100%;
         67	}
         68	
         69	.empty-chat p {
         70	  font-size: 1rem;
         71	  max-width: 300px;
         72	  line-height: 1.5;
         73	}
         74	
         75	/* Loading spinner for empty state */
         76	.empty-chat .loading-spinner {
         77	  width: 40px;
         78	  height: 40px;
         79	  border: 3px solid #f3f3f3;
         80	  border-top: 3px solid #6366f1;
         81	  border-radius: 50%;
         82	  animation: spin 1s linear infinite;
         83	  margin-bottom: 1rem;
         84	}
         85	
         86	@keyframes spin {
         87	  0% { transform: rotate(0deg); }
         88	  100% { transform: rotate(360deg); }
         89	}
         90	
         91	/* Debug info */
         92	.debug-info {
         93	  position: absolute;
         94	  top: 0;
         95	  right: 0;
         96	  font-size: 10px;
         97	  padding: 2px 4px;
         98	  background: rgba(249, 249, 249, 0.8);
         99	  z-index: 100;
        100	  border-radius: 0 0 0 4px;
        101	}

==============================================
FILE: ./frontend/src/components/chat/ChatHistory.tsx
==============================================

          1	import React, { useEffect, useRef } from 'react';
          2	import ChatMessage from './ChatMessage';
          3	import './ChatHistory.css';
          4	
          5	export interface ChatHistoryProps {
          6	  messages: Array<{
          7	    id: string;
          8	    content: string;
          9	    sender: "user" | "agent";
         10	    timestamp: string;
         11	    metadata?: any;
         12	  }>;
         13	  loadMore: () => void;
         14	  hasMore: boolean;
         15	  loading: boolean;
         16	  agentColor?: string;
         17	  agentName?: string;
         18	  userName?: string;
         19	}
         20	
         21	const ChatHistory: React.FC<ChatHistoryProps> = ({
         22	  messages,
         23	  loadMore,
         24	  hasMore,
         25	  loading,
         26	  agentColor,
         27	  agentName,
         28	  userName,
         29	}) => {
         30	  const messagesEndRef = useRef<HTMLDivElement>(null);
         31	  const messagesContainerRef = useRef<HTMLDivElement>(null);
         32	  const prevMessagesLength = useRef<number>(0);
         33	
         34	  // Add debug logging for messages
         35	  useEffect(() => {
         36	    // Removed debug log
         37	  }, [messages, agentName, userName]);
         38	
         39	  // Scroll to bottom when new messages are added (but not when loading more history)
         40	  useEffect(() => {
         41	    if (messages.length > prevMessagesLength.current && messagesEndRef.current) {
         42	      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
         43	    }
         44	    prevMessagesLength.current = messages.length;
         45	  }, [messages.length]);
         46	
         47	  // Handle scroll to load more messages
         48	  const handleScroll = () => {
         49	    const container = messagesContainerRef.current;
         50	    
         51	    if (!container || loading || !hasMore) return;
         52	    
         53	    // Load more when scrolled near the top
         54	    if (container.scrollTop < 100) {
         55	      // Save current scroll position and height
         56	      const scrollHeight = container.scrollHeight;
         57	      
         58	      loadMore();
         59	      
         60	      // After loading more messages, adjust scroll position to maintain the same view
         61	      // (This will be applied after the messages are rendered)
         62	      setTimeout(() => {
         63	        if (container) {
         64	          const newScrollHeight = container.scrollHeight;
         65	          container.scrollTop = newScrollHeight - scrollHeight;
         66	        }
         67	      }, 100);
         68	    }
         69	  };
         70	
         71	  return (
         72	    <div 
         73	      className="chat-history"
         74	      ref={messagesContainerRef}
         75	      onScroll={handleScroll}
         76	    >
         77	      {loading && hasMore && (
         78	        <div className="loading-indicator">
         79	          Loading previous messages...
         80	        </div>
         81	      )}
         82	      
         83	      {hasMore && !loading && (
         84	        <button 
         85	          className="load-more-button"
         86	          onClick={loadMore}
         87	        >
         88	          Load more messages
         89	        </button>
         90	      )}
         91	      
         92	      {messages.length === 0 ? (
         93	        <div className="empty-chat">
         94	          <div className="loading-spinner"></div>
         95	          <p>Initializing your Praxis Agent...</p>
         96	          <p><small>If no message appears after a few seconds, try refreshing the page.</small></p>
         97	        </div>
         98	      ) : (
         99	        <>
        100	          {/* Add debug overlay for development */}
        101	          {process.env.NODE_ENV !== 'production' && (
        102	            <div className="debug-info" style={{ fontSize: '10px', color: '#666', padding: '4px', background: '#f9f9f9' }}>
        103	              Messages: {messages.length} | Agent: {agentName} | User: {userName}
        104	            </div>
        105	          )}
        106	          {messages.map((message) => (
        107	            <ChatMessage
        108	              key={message.id}
        109	              message={message}
        110	              agentColor={agentColor}
        111	              agentName={agentName}
        112	              userName={userName}
        113	            />
        114	          ))}
        115	        </>
        116	      )}
        117	      
        118	      {/* Invisible element to scroll to when new messages arrive */}
        119	      <div ref={messagesEndRef} />
        120	    </div>
        121	  );
        122	};
        123	
        124	export default ChatHistory;

==============================================
FILE: ./frontend/src/components/chat/ChatInput.css
==============================================

          1	.chat-input-form {
          2	  width: 100%;
          3	  margin-top: 1rem;
          4	}
          5	
          6	.chat-input-container {
          7	  display: flex;
          8	  border: 1px solid #ccc;
          9	  border-radius: 8px;
         10	  overflow: hidden;
         11	  background-color: #fff;
         12	  position: relative;
         13	}
         14	
         15	.chat-input {
         16	  flex: 1;
         17	  padding: 12px 15px;
         18	  border: none;
         19	  outline: none;
         20	  resize: none;
         21	  font-family: inherit;
         22	  font-size: 1rem;
         23	  line-height: 1.4;
         24	  max-height: 150px;
         25	  min-height: 40px;
         26	}
         27	
         28	.chat-input:disabled {
         29	  background-color: #f9f9f9;
         30	  color: #999;
         31	}
         32	
         33	.send-button {
         34	  background-color: #007bff;
         35	  color: white;
         36	  border: none;
         37	  width: 44px;
         38	  height: 44px;
         39	  display: flex;
         40	  align-items: center;
         41	  justify-content: center;
         42	  cursor: pointer;
         43	  transition: background-color 0.2s;
         44	}
         45	
         46	.send-button:hover {
         47	  background-color: #0069d9;
         48	}
         49	
         50	.send-button:disabled {
         51	  background-color: #cccccc;
         52	  cursor: not-allowed;
         53	}
         54	
         55	.chat-input-disabled-message {
         56	  color: #666;
         57	  font-size: 0.8rem;
         58	  text-align: center;
         59	  margin-top: 0.5rem;
         60	  font-style: italic;
         61	}
         62	
         63	/* Auto-resize textarea */
         64	.chat-input {
         65	  overflow-y: auto;
         66	}
         67	
         68	/* Style scrollbar for webkit browsers */
         69	.chat-input::-webkit-scrollbar {
         70	  width: 6px;
         71	}
         72	
         73	.chat-input::-webkit-scrollbar-track {
         74	  background: #f1f1f1;
         75	}
         76	
         77	.chat-input::-webkit-scrollbar-thumb {
         78	  background: #c1c1c1;
         79	  border-radius: 3px;
         80	}
         81	
         82	.chat-input::-webkit-scrollbar-thumb:hover {
         83	  background: #a8a8a8;
         84	}

==============================================
FILE: ./frontend/src/components/chat/ChatInput.tsx
==============================================

          1	import React, { useState, KeyboardEvent } from 'react';
          2	import './ChatInput.css';
          3	
          4	export interface ChatInputProps {
          5	  onSendMessage: (content: string) => void;
          6	  disabled?: boolean;
          7	  placeholder?: string;
          8	}
          9	
         10	const ChatInput: React.FC<ChatInputProps> = ({
         11	  onSendMessage,
         12	  disabled = false,
         13	  placeholder = 'Type your message...'
         14	}) => {
         15	  const [message, setMessage] = useState('');
         16	
         17	  const handleSubmit = (e: React.FormEvent) => {
         18	    e.preventDefault();
         19	    
         20	    if (message.trim() && !disabled) {
         21	      onSendMessage(message);
         22	      setMessage('');
         23	    }
         24	  };
         25	
         26	  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
         27	    // Send message when Enter is pressed without Shift
         28	    if (e.key === 'Enter' && !e.shiftKey) {
         29	      e.preventDefault();
         30	      handleSubmit(e);
         31	    }
         32	  };
         33	
         34	  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
         35	    setMessage(e.target.value);
         36	  };
         37	
         38	  return (
         39	    <form className="chat-input-form" onSubmit={handleSubmit}>
         40	      <div className="chat-input-container">
         41	        <textarea
         42	          className="chat-input"
         43	          value={message}
         44	          onChange={handleChange}
         45	          onKeyDown={handleKeyDown}
         46	          placeholder={placeholder}
         47	          disabled={disabled}
         48	          rows={1}
         49	          autoFocus
         50	        />
         51	        <button 
         52	          type="submit" 
         53	          className="send-button"
         54	          disabled={!message.trim() || disabled}
         55	        >
         56	          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
         57	            <line x1="22" y1="2" x2="11" y2="13"></line>
         58	            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
         59	          </svg>
         60	        </button>
         61	      </div>
         62	      {disabled && (
         63	        <div className="chat-input-disabled-message">
         64	          Waiting for a response...
         65	        </div>
         66	      )}
         67	    </form>
         68	  );
         69	};
         70	
         71	export default ChatInput;

==============================================
FILE: ./frontend/src/components/chat/ChatInterface.css
==============================================

          1	.chat-interface {
          2	  display: flex;
          3	  flex-direction: column;
          4	  width: 100%;
          5	  height: 100%;
          6	  max-width: 800px;
          7	  margin: 0 auto;
          8	}
          9	
         10	.chat-container {
         11	  display: flex;
         12	  flex-direction: column;
         13	  flex: 1;
         14	  height: 100%;
         15	  min-height: 400px;
         16	  border-radius: 8px;
         17	  overflow: hidden;
         18	  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
         19	}
         20	
         21	.chat-error {
         22	  background-color: #fde8e8;
         23	  color: #e53e3e;
         24	  padding: 12px 16px;
         25	  border-radius: 6px;
         26	  margin-bottom: 1rem;
         27	  display: flex;
         28	  justify-content: space-between;
         29	  align-items: center;
         30	}
         31	
         32	.dismiss-error {
         33	  background: none;
         34	  border: none;
         35	  font-size: 1.2rem;
         36	  color: #e53e3e;
         37	  cursor: pointer;
         38	  padding: 0;
         39	  margin-left: 1rem;
         40	}
         41	
         42	/* For smaller screens */
         43	@media (max-width: 768px) {
         44	  .chat-interface {
         45	    width: 100%;
         46	    height: calc(100vh - 120px);
         47	  }
         48	  
         49	  .chat-container {
         50	    min-height: 300px;
         51	  }
         52	}
         53	
         54	/* Dark mode support */
         55	@media (prefers-color-scheme: dark) {
         56	  .chat-interface {
         57	    color: #f0f0f0;
         58	  }
         59	  
         60	  .chat-container {
         61	    background-color: #222;
         62	    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
         63	  }
         64	  
         65	  .chat-error {
         66	    background-color: #462626;
         67	    color: #f8b4b4;
         68	  }
         69	  
         70	  .dismiss-error {
         71	    color: #f8b4b4;
         72	  }
         73	}

==============================================
FILE: ./frontend/src/components/chat/ChatInterface.tsx
==============================================

          1	import React, { useState, useEffect, useCallback } from 'react';
          2	import { chat } from '../../api/apiClient';
          3	import ChatHistory from './ChatHistory';
          4	import ChatInput from './ChatInput';
          5	import { useChatContext } from '../../hooks/useChatContext';
          6	import './ChatInterface.css';
          7	
          8	export interface ChatInterfaceProps {
          9	  agentId: string;
         10	  isOnboarding?: boolean;
         11	  onComplete?: () => void;  // For onboarding completion
         12	  onSendMessage?: (message: string) => Promise<void>;
         13	  onboardingStep?: number;
         14	  onboardingMetadata?: any;
         15	  newMessages?: ChatMessage[]; // New prop to receive messages to append
         16	  agentName?: string; // Add agentName prop
         17	  agentColor?: string; // Add agentColor prop
         18	  userName?: string; // Add userName prop
         19	}
         20	
         21	export interface ChatMessage {
         22	  id: string;
         23	  content: string;
         24	  sender: "user" | "agent";
         25	  timestamp: string;
         26	  metadata?: {
         27	    isOnboarding?: boolean;
         28	    stage?: 'initial' | 'preferences' | 'priorities' | 'confirmation' | 'complete';
         29	    nextStage?: 'initial' | 'preferences' | 'priorities' | 'confirmation' | 'complete';
         30	    onboardingComplete?: boolean;
         31	    [key: string]: any;
         32	  };
         33	}
         34	
         35	const ChatInterface: React.FC<ChatInterfaceProps> = ({
         36	  agentId,
         37	  isOnboarding = false,
         38	  onComplete,
         39	  onSendMessage,
         40	  onboardingStep,
         41	  onboardingMetadata,
         42	  newMessages, // Receive newMessages prop
         43	  agentName, // Receive agentName prop
         44	  agentColor, // Receive agentColor prop
         45	  userName // Receive userName prop
         46	}) => {
         47	  // Get chat context from the hook
         48	  const { chatContext } = useChatContext();
         49	
         50	  const [messages, setMessages] = useState<ChatMessage[]>([]);
         51	  const [loading, setLoading] = useState(true);
         52	  const [sending, setSending] = useState(false);
         53	  const [hasMore, setHasMore] = useState(false);
         54	  const [error, setError] = useState<string | null>(null);
         55	  // Remove local agent state as it's now passed via props
         56	  // const [agent, setAgent] = useState<{ name: string; color: string } | null>(null);
         57	
         58	  // Log whenever props change
         59	  React.useEffect(() => {
         60	    // Removed debug log
         61	  }, [agentId, isOnboarding, onboardingStep, onboardingMetadata, onSendMessage, newMessages, agentName, agentColor, userName]);
         62	
         63	  // Load initial messages
         64	  useEffect(() => {
         65	    const loadMessages = async () => {
         66	      try {
         67	        setLoading(true);
         68	        setError(null);
         69	
         70	        // Agent details are now passed via props, no need to fetch here
         71	        // if (!agentName || !agentColor) {
         72	        //   // Optionally handle case where agent info is not yet available
         73	        // }
         74	
         75	        // Get chat messages
         76	        const messagesResponse = await fetch(`/api/agents/${agentId}/messages?onboarding=${isOnboarding ? 'true' : 'false'}`, {
         77	          headers: {
         78	            'Authorization': `Bearer ${localStorage.getItem('token')}`
         79	          }
         80	        });
         81	        const data = await messagesResponse.json();
         82	        setMessages(data.messages || []);
         83	        setHasMore(false); // Pagination not implemented for custom endpoint
         84	      } catch (err: any) {
         85	        setError('Failed to load messages. Please try again later.');
         86	      } finally {
         87	        setLoading(false);
         88	      }
         89	    };
         90	
         91	    loadMessages();
         92	  }, [agentId, isOnboarding]); // Removed reloadKey from dependency array, keep agentId and isOnboarding
         93	
         94	  // Effect to append new messages when the newMessages prop changes
         95	  useEffect(() => {
         96	    // Roo Debug: Log newMessages and agentName when newMessages changes - Attempt 5
         97	    console.log('[ChatInterface] useEffect [newMessages] triggered. newMessages:', newMessages, 'agentName:', agentName, 'userName:', userName);
         98	    if (newMessages && newMessages.length > 0) {
         99	      setMessages(prevMessages => {
        100	        console.log('[ChatInterface] Before appending newMessages:', prevMessages.map(msg => msg.id)); // Log keys before update
        101	        // Filter out any temporary messages before appending
        102	        const filteredMessages = prevMessages.filter(msg => !msg.id.startsWith('temp-'));
        103	        
        104	        // Create a map of existing message IDs for quick lookup
        105	        const existingMessageIds = new Set(filteredMessages.map(msg => msg.id));
        106	
        107	        // Filter out new messages that are already in the existing list
        108	        const uniqueNewMessages = newMessages.filter(msg => !existingMessageIds.has(msg.id));
        109	
        110	        const updatedMessages = [...filteredMessages, ...uniqueNewMessages];
        111	        console.log('[ChatInterface] Appending new messages:', uniqueNewMessages.map(msg => msg.id), 'Updated messages:', updatedMessages.map(msg => msg.id)); // Log keys after update
        112	        return updatedMessages;
        113	      });
        114	    }
        115	  }, [newMessages, agentName]); // Depend on newMessages and agentName prop
        116	
        117	  // Load more messages
        118	  const loadMoreMessages = useCallback(async () => {
        119	    if (loading || !hasMore || messages.length === 0) return;
        120	
        121	    try {
        122	      setLoading(true);
        123	
        124	      const oldestMessage = messages[0];
        125	      const response = await chat.getMessages(agentId, {
        126	        limit: 20,
        127	        before: oldestMessage.timestamp,
        128	        onboarding: isOnboarding
        129	      });
        130	
        131	      const data = response.data;
        132	
        133	      setMessages(prevMessages => [
        134	        ...(data.messages || []),
        135	        ...prevMessages
        136	      ]);
        137	
        138	      setHasMore(data.hasMore || false);
        139	    } catch (err) {
        140	      setError('Failed to load more messages. Please try again later.');
        141	    } finally {
        142	      setLoading(false);
        143	    }
        144	  }, [agentId, hasMore, isOnboarding, loading, messages]);
        145	
        146	  // Send a new message
        147	  const sendMessage = async (content: string) => {
        148	    if (onSendMessage) {
        149	      setSending(true);
        150	      setError(null);
        151	      try {
        152	        // onSendMessage is now responsible for updating messages state in parent
        153	        await onSendMessage(content);
        154	      } catch (err) {
        155	        setError('Failed to send message. Please try again.');
        156	      } finally {
        157	        setSending(false);
        158	      }
        159	      return;
        160	    }
        161	
        162	    // Default legacy message sending logic (should not be used in OnboardingChat)
        163	    if (sending || !content.trim()) return;
        164	    try {
        165	      setSending(true);
        166	      setError(null);
        167	
        168	      // Create a temporary user message to show immediately
        169	      const tempUserMessage: ChatMessage = {
        170	        id: `temp-${Date.now()}`, // Temporary ID
        171	        content,
        172	        sender: 'user',
        173	        timestamp: new Date().toISOString(),
        174	        metadata: { userName } // Add userName to metadata
        175	      };
        176	
        177	      setMessages(prevMessages => {
        178	        const updated = [...prevMessages, tempUserMessage];
        179	        return updated;
        180	      });
        181	
        182	      // Create metadata for the API request
        183	      let requestMetadata: any = { isOnboarding, userName };
        184	      
        185	      // Add context data from chatContext
        186	      if (chatContext?.type && chatContext?.data) {
        187	        console.log('[ChatInterface] Including context data in message:', {
        188	          contextType: chatContext.type,
        189	          data: chatContext.data
        190	        });
        191	        
        192	        requestMetadata.contextType = chatContext.type;
        193	        
        194	        // Add specific contextual data based on type
        195	        if (chatContext.type === 'positions') {
        196	          const positionsData = chatContext.data as any;
        197	          if (positionsData && positionsData.selectedIssue) {
        198	            requestMetadata.selectedIssue = positionsData.selectedIssue;
        199	          }
        200	        } else if (chatContext.type === 'activity') {
        201	          const activityData = chatContext.data as any;
        202	          if (activityData && activityData.selectedAction) {
        203	            requestMetadata.selectedAction = activityData.selectedAction;
        204	          }
        205	        } else if (chatContext.type === 'proposals') {
        206	          const proposalData = chatContext.data as any;
        207	          if (proposalData && proposalData.selectedProposal) {
        208	            requestMetadata.selectedProposal = proposalData.selectedProposal;
        209	          }
        210	        }
        211	        
        212	        // Always include the context data for the LLM to use
        213	        requestMetadata.context = chatContext.data;
        214	      }
        215	
        216	      // Include current stage information if available from previous messages
        217	      if (isOnboarding && messages.length > 0) {
        218	        // Find the most recent agent message with stage info in metadata
        219	        const recentAgentMessages = [...messages]
        220	          .reverse()
        221	          .filter(m => m.sender === 'agent' && m.metadata);
        222	
        223	        const lastAgentWithStage = recentAgentMessages.find(m =>
        224	          m.metadata?.stage || m.metadata?.nextStage
        225	        );
        226	
        227	        if (lastAgentWithStage?.metadata) {
        228	          // Use nextStage if available, otherwise fallback to current stage
        229	          requestMetadata.stage = lastAgentWithStage.metadata.nextStage ||
        230	                                 lastAgentWithStage.metadata.stage ||
        231	                                 'initial';
        232	        }
        233	      }
        234	
        235	      // Send message to API
        236	      const response = await chat.sendMessage({
        237	        agentId,
        238	        content,
        239	        metadata: requestMetadata
        240	      });
        241	
        242	      const data = response.data;
        243	
        244	      // Update messages state: replace temporary message and add agent response
        245	      setMessages(prevMessages => {
        246	        console.log('[ChatInterface] Before API response update (legacy):', prevMessages.map(msg => msg.id)); // Log keys before update
        247	        // Find and replace the temporary user message with the actual saved user message
        248	        const updatedMessages = prevMessages.map(msg =>
        249	          msg.id.startsWith('temp-') && msg.content === data.userMessage.content && msg.sender === 'user'
        250	            ? data.userMessage
        251	            : msg
        252	        );
        253	
        254	        // Check if the agent message is already in the list (can happen with initial load + real-time updates)
        255	        const agentMessageExists = updatedMessages.some(msg => msg.id === data.agentMessage.id);
        256	
        257	        // Append the agent message only if it's not already present
        258	        if (!agentMessageExists) {
        259	          updatedMessages.push(data.agentMessage);
        260	        }
        261	        console.log('[ChatInterface] After API response update (legacy):', updatedMessages.map(msg => msg.id)); // Log keys after update
        262	        return updatedMessages;
        263	      });
        264	
        265	      // Check if onboarding is completed from agent response metadata
        266	      if (isOnboarding &&
        267	          data.agentMessage.metadata &&
        268	          (data.agentMessage.metadata.onboardingComplete ||
        269	           data.agentMessage.metadata.completedOnboarding) &&
        270	          onComplete) {
        271	        // Allow a small delay to see the completion message before redirecting
        272	        setTimeout(() => {
        273	          onComplete();
        274	        }, 1500);
        275	      }
        276	    } catch (err: any) {
        277	      setError('Failed to send message. Please try again.');
        278	
        279	      // Remove the temporary message on error and add an error message
        280	      setMessages(prevMessages => {
        281	        // Use a safer approach that doesn't rely on the specific tempUserMessage variable
        282	        const filteredMessages = prevMessages.filter(msg => !msg.id.startsWith('temp-'));
        283	        return [
        284	          ...filteredMessages,
        285	          {
        286	            id: `error-${Date.now()}`,
        287	            content: "I'm sorry, there was an error processing your message. Please try again.",
        288	            sender: "agent",
        289	            timestamp: new Date().toISOString(),
        290	            metadata: { isError: true }
        291	          }
        292	        ];
        293	      });
        294	    } finally {
        295	      setSending(false);
        296	    }
        297	  };
        298	
        299	  return (
        300	    <div className="chat-interface">
        301	      {error && (
        302	        <div className="chat-error">
        303	          {error}
        304	          <button
        305	            className="dismiss-error"
        306	            onClick={() => setError(null)}
        307	          >
        308	            ×
        309	            </button>
        310	        </div>
        311	      )}
        312	
        313	      <div className="chat-container">
        314	        <ChatHistory
        315	          messages={messages}
        316	          loadMore={loadMoreMessages}
        317	          hasMore={hasMore}
        318	          loading={loading}
        319	          agentColor={agentColor} // Use prop
        320	          agentName={agentName} // Use prop
        321	          userName={userName} // Pass userName to ChatHistory
        322	        />
        323	
        324	        <ChatInput
        325	          onSendMessage={sendMessage}
        326	          disabled={sending}
        327	          placeholder={sending ? "Waiting for response..." : "Type your message..."}
        328	        />
        329	      </div>
        330	    </div>
        331	  );
        332	};
        333	
        334	export default ChatInterface;

==============================================
FILE: ./frontend/src/components/chat/ChatMessage.css
==============================================

          1	.chat-message {
          2	  display: flex;
          3	  margin-bottom: 1rem;
          4	  max-width: 100%;
          5	}
          6	
          7	.agent-message {
          8	  justify-content: flex-start;
          9	}
         10	
         11	.user-message {
         12	  justify-content: flex-end;
         13	}
         14	
         15	.message-content {
         16	  border-radius: 8px;
         17	  padding: 10px 15px;
         18	  max-width: 80%;
         19	  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
         20	  position: relative;
         21	  color: #000 !important;
         22	}
         23	
         24	.agent-message .message-content {
         25	  background-color: #f1f5f9;  /* Light blue-gray background for agent */
         26	  border-left: 3px solid #007bff;  /* Default agent color - will be overridden */
         27	  color: #000 !important;
         28	}
         29	
         30	.user-message .message-content {
         31	  background-color: #e9f5ff;  /* Light blue background for user */
         32	  text-align: right;
         33	  color: #000 !important;
         34	}
         35	
         36	.message-header {
         37	  display: flex;
         38	  justify-content: space-between;
         39	  margin-bottom: 4px;
         40	  font-size: 0.85rem;
         41	}
         42	
         43	.message-sender {
         44	  font-weight: 600;
         45	}
         46	
         47	.message-time {
         48	  color: #666;
         49	  font-size: 0.75rem;
         50	}
         51	
         52	.message-text {
         53	  line-height: 1.4;
         54	  white-space: pre-wrap;
         55	  word-break: break-word;
         56	}
         57	
         58	@media (max-width: 768px) {
         59	  .message-content {
         60	    max-width: 90%;
         61	  }
         62	}

==============================================
FILE: ./frontend/src/components/chat/ChatMessage.tsx
==============================================

          1	import React from 'react';
          2	import './ChatMessage.css';
          3	
          4	export interface ChatMessageProps {
          5	  message: {
          6	    id: string;
          7	    content: string;
          8	    sender: "user" | "agent";
          9	    timestamp: string;
         10	    metadata?: any;
         11	  };
         12	  agentColor?: string;
         13	  agentName?: string;
         14	  userName?: string;
         15	}
         16	
         17	const ChatMessage: React.FC<ChatMessageProps> = ({
         18	  message,
         19	  agentColor = '#007bff',
         20	  agentName = 'Agent',
         21	  userName = 'You'
         22	}) => {
         23	  const isAgent = message.sender === 'agent';
         24	  
         25	  // Format timestamp
         26	  const formattedTime = new Date(message.timestamp).toLocaleTimeString([], {
         27	    hour: '2-digit',
         28	    minute: '2-digit'
         29	  });
         30	
         31	  // Debug the names passed to ChatMessage
         32	  console.log(`[DEBUG_NAMES] ChatMessage rendering:`, {
         33	    isAgent,
         34	    sender: message.sender,
         35	    messageName: isAgent ? (message.metadata?.agentName || agentName) : (message.metadata?.userName || userName),
         36	    agentName,
         37	    userName,
         38	    hasMetadata: !!message.metadata,
         39	    metadataAgentName: message.metadata?.agentName,
         40	    metadataUserName: message.metadata?.userName
         41	  });
         42	
         43	  return (
         44	    <div className={`chat-message ${isAgent ? 'agent-message' : 'user-message'}`}>
         45	      <div
         46	        className="message-content"
         47	        style={{
         48	          backgroundColor: isAgent ? `${agentColor}22` : undefined,
         49	          borderLeftColor: isAgent ? agentColor : undefined
         50	        }}
         51	        onClick={() => {
         52	          // Log the applied styles when clicked for debugging
         53	        }}
         54	      >
         55	        <div className="message-header">
         56	          <span className="message-sender">
         57	            {isAgent ?
         58	              // For agent messages: use metadata.agentName if available, otherwise use props agentName
         59	              (message.metadata?.agentName ? `${message.metadata.agentName} (Agent)` : `${agentName} (Agent)`) :
         60	              // For user messages: use metadata.userName if available, otherwise use props userName
         61	              (message.metadata?.userName ? `${message.metadata.userName} (you)` : `${userName} (you)`)}
         62	          </span>
         63	          <span className="message-time">{formattedTime}</span>
         64	        </div>
         65	        <div className="message-text">
         66	          {message.content}
         67	        </div>
         68	      </div>
         69	    </div>
         70	  );
         71	};
         72	
         73	export default ChatMessage;

==============================================
FILE: ./frontend/src/components/dashboard/ActivityAuditTab.tsx
==============================================

          1	import React, { useState } from 'react';
          2	import { useDashboard } from '../../context/DashboardContext';
          3	import { useChatContext } from '../../hooks/useChatContext';
          4	
          5	interface RecentAction {
          6	    id: string;
          7	    type: 'vote' | 'comment';
          8	    proposalTitle: string;
          9	    proposalId: string;
         10	    actionDetails: string;
         11	    timestamp: string;
         12	    canVeto: boolean;
         13	    isOverridden: boolean;
         14	}
         15	
         16	interface VetoFeedbackMessage {
         17	    message: string;
         18	    isError: boolean;
         19	}
         20	
         21	interface ActivityAuditTabProps {
         22	    recentActions: RecentAction[];
         23	    welcomeMessage: string;
         24	    agentColor: string;
         25	    handleVeto: (actionId: string, actionType: 'vote' | 'comment') => Promise<void>;
         26	    isVetoingAction: boolean;
         27	    vetoingActionId: string | null;
         28	    vetoFeedbackMessage: VetoFeedbackMessage | null;
         29	    onChatMaximize?: () => void; // Add prop to maximize chat when discussing an action
         30	}
         31	
         32	/**
         33	 * Tab component for the Activity Audit view in the dashboard
         34	 * Displays a chronological feed of all agent activity with filtering capabilities
         35	 */
         36	const ActivityAuditTab: React.FC<ActivityAuditTabProps> = ({
         37	    recentActions,
         38	    welcomeMessage,
         39	    agentColor,
         40	    handleVeto,
         41	    isVetoingAction,
         42	    vetoingActionId,
         43	    vetoFeedbackMessage,
         44	    onChatMaximize
         45	}) => {
         46	    // Get data and actions from context hooks
         47	    const { selectAction, currentTabData } = useDashboard();
         48	    const { setChatContext } = useChatContext();
         49	
         50	    // Get actions from props or from context if available
         51	    const actions = currentTabData.activity?.recentActions?.length ?
         52	                    currentTabData.activity.recentActions : recentActions;
         53	
         54	    // State for filter controls
         55	    const [filterType, setFilterType] = useState<'all' | 'vote' | 'comment'>('all');
         56	    const [sortOrder, setSortOrder] = useState<'newest' | 'oldest'>('newest');
         57	    
         58	    // Filter actions based on current settings
         59	    const filteredActions = actions.filter(action => {
         60	        if (filterType === 'all') return true;
         61	        return action.type === filterType;
         62	    });
         63	    
         64	    // Sort actions based on current settings
         65	    const sortedActions = [...filteredActions].sort((a, b) => {
         66	        const dateA = new Date(a.timestamp).getTime();
         67	        const dateB = new Date(b.timestamp).getTime();
         68	        return sortOrder === 'newest' ? dateB - dateA : dateA - dateB;
         69	    });
         70	
         71	    // Format timestamp to a more readable format
         72	    const formatTimestamp = (timestamp: string) => {
         73	        const date = new Date(timestamp);
         74	        return date.toLocaleString();
         75	    };
         76	
         77	    // Group actions by date for better visualization
         78	    const groupActionsByDate = (actions: RecentAction[]) => {
         79	        const groups: { [key: string]: RecentAction[] } = {};
         80	        
         81	        actions.forEach(action => {
         82	            const date = new Date(action.timestamp);
         83	            const dateKey = date.toLocaleDateString();
         84	            
         85	            if (!groups[dateKey]) {
         86	                groups[dateKey] = [];
         87	            }
         88	            
         89	            groups[dateKey].push(action);
         90	        });
         91	        
         92	        return groups;
         93	    };
         94	    
         95	    const actionGroups = groupActionsByDate(sortedActions);
         96	
         97	    return (
         98	        <div className="activity-audit-tab">
         99	            <header className="tab-header">
        100	                <h2>{welcomeMessage} here's what you and your agent have been up to</h2>
        101	                <p className="tab-description">
        102	                    This is a record of all actions your agent has taken on your behalf.
        103	                    You can review, filter, and veto recent actions if needed.
        104	                </p>
        105	            </header>
        106	            
        107	            <div className="activity-controls">
        108	                <div className="control-filters">
        109	                    <label htmlFor="filter-select">Filter:</label>
        110	                    <select 
        111	                        id="filter-select"
        112	                        value={filterType}
        113	                        onChange={(e) => setFilterType(e.target.value as 'all' | 'vote' | 'comment')}
        114	                    >
        115	                        <option value="all">All Activities</option>
        116	                        <option value="vote">Votes Only</option>
        117	                        <option value="comment">Comments Only</option>
        118	                    </select>
        119	                </div>
        120	                
        121	                <div className="control-sort">
        122	                    <label htmlFor="sort-select">Sort:</label>
        123	                    <select 
        124	                        id="sort-select"
        125	                        value={sortOrder}
        126	                        onChange={(e) => setSortOrder(e.target.value as 'newest' | 'oldest')}
        127	                    >
        128	                        <option value="newest">Newest First</option>
        129	                        <option value="oldest">Oldest First</option>
        130	                    </select>
        131	                </div>
        132	            </div>
        133	            
        134	            {Object.keys(actionGroups).length === 0 ? (
        135	                <div className="empty-state">
        136	                    <p>No activity found with the current filter settings.</p>
        137	                    {filterType !== 'all' && (
        138	                        <button 
        139	                            className="action-button"
        140	                            style={{ backgroundColor: agentColor }}
        141	                            onClick={() => setFilterType('all')}
        142	                        >
        143	                            Show All Activities
        144	                        </button>
        145	                    )}
        146	                </div>
        147	            ) : (
        148	                <div className="activity-timeline">
        149	                    {Object.entries(actionGroups).map(([date, actions]) => (
        150	                        <div className="activity-date-group" key={date}>
        151	                            <div className="date-header" style={{ borderColor: agentColor }}>
        152	                                <h3>{date}</h3>
        153	                            </div>
        154	                            <ul className="activity-list">
        155	                                {actions.map(action => (
        156	                                    <li key={action.id} className="activity-item">
        157	                                        <div className="activity-icon" style={{ backgroundColor: agentColor }}>
        158	                                            {action.type === 'vote' ? '✓' : '💬'}
        159	                                        </div>
        160	                                        <div className="activity-content">
        161	                                            <div className="activity-header">
        162	                                                <h4>
        163	                                                    <strong>{action.type === 'vote' ? 'Vote' : 'Comment'}</strong> on "{action.proposalTitle}"
        164	                                                </h4>
        165	                                                <span className="activity-time">
        166	                                                    {new Date(action.timestamp).toLocaleTimeString()}
        167	                                                </span>
        168	                                            </div>
        169	                                            <p className="activity-details">{action.actionDetails}</p>
        170	                                            {action.isOverridden && (
        171	                                                <span className="badge override-badge">Overridden by You</span>
        172	                                            )}
        173	                                            <div className="activity-action-buttons">
        174	                                                {action.canVeto && !action.isOverridden && (
        175	                                                    <button
        176	                                                        className="veto-button"
        177	                                                        onClick={() => handleVeto(action.id, action.type)}
        178	                                                        disabled={isVetoingAction}
        179	                                                    >
        180	                                                        {isVetoingAction && vetoingActionId === action.id ? 'Processing...' : 'Veto/Undo'}
        181	                                                    </button>
        182	                                                )}
        183	                                                
        184	                                                <button
        185	                                                    className="discuss-button"
        186	                                                    style={{ backgroundColor: agentColor }}
        187	                                                    onClick={() => {
        188	                                                        // Update UI state in context
        189	                                                        selectAction(action.id);
        190	                                                        
        191	                                                        // Update chat context
        192	                                                        setChatContext({
        193	                                                            type: 'activity',
        194	                                                            data: {
        195	                                                                selectedAction: action
        196	                                                            }
        197	                                                        });
        198	                                                        
        199	                                                        // Maximize the chat panel
        200	                                                        if (onChatMaximize) {
        201	                                                            onChatMaximize();
        202	                                                        }
        203	                                                    }}
        204	                                                >
        205	                                                    Discuss
        206	                                                </button>
        207	                                            </div>
        208	                                            {vetoFeedbackMessage && vetoingActionId === action.id && (
        209	                                                <div className={`feedback-message ${vetoFeedbackMessage.isError ? 'error' : 'success'}`}>
        210	                                                    {vetoFeedbackMessage.message}
        211	                                                </div>
        212	                                            )}
        213	                                        </div>
        214	                                    </li>
        215	                                ))}
        216	                            </ul>
        217	                        </div>
        218	                    ))}
        219	                </div>
        220	            )}
        221	            
        222	            <style>{`
        223	                .activity-audit-tab {
        224	                    padding: 1rem 0;
        225	                }
        226	                
        227	                .tab-header {
        228	                    margin-bottom: 1.5rem;
        229	                }
        230	                
        231	                .tab-header h2 {
        232	                    font-size: 1.5rem;
        233	                    margin-bottom: 0.5rem;
        234	                    color: #2d3748;
        235	                }
        236	                
        237	                .tab-description {
        238	                    color: #4a5568;
        239	                    line-height: 1.5;
        240	                }
        241	                
        242	                .activity-controls {
        243	                    display: flex;
        244	                    justify-content: space-between;
        245	                    align-items: center;
        246	                    margin-bottom: 1.5rem;
        247	                    padding: 0.75rem 1rem;
        248	                    background-color: #f7fafc;
        249	                    border-radius: 8px;
        250	                }
        251	                
        252	                .activity-controls select {
        253	                    padding: 0.35rem 0.5rem;
        254	                    border-radius: 4px;
        255	                    border: 1px solid #e2e8f0;
        256	                    background-color: white;
        257	                    font-size: 0.9rem;
        258	                    margin-left: 8px;
        259	                }
        260	                
        261	                .activity-timeline {
        262	                    margin-bottom: 2rem;
        263	                }
        264	                
        265	                .date-header {
        266	                    margin: 1.5rem 0 1rem;
        267	                    padding-left: 0.75rem;
        268	                    border-left: 3px solid;
        269	                }
        270	                
        271	                .date-header h3 {
        272	                    font-size: 1rem;
        273	                    color: #4a5568;
        274	                    font-weight: 600;
        275	                    margin: 0;
        276	                }
        277	                
        278	                .activity-list {
        279	                    list-style: none;
        280	                    padding: 0;
        281	                    margin: 0;
        282	                }
        283	                
        284	                .activity-item {
        285	                    display: flex;
        286	                    margin-bottom: 1.5rem;
        287	                    position: relative;
        288	                }
        289	                
        290	                .activity-icon {
        291	                    width: 36px;
        292	                    height: 36px;
        293	                    border-radius: 50%;
        294	                    color: white;
        295	                    display: flex;
        296	                    align-items: center;
        297	                    justify-content: center;
        298	                    margin-right: 1rem;
        299	                    flex-shrink: 0;
        300	                }
        301	                
        302	                .activity-content {
        303	                    flex-grow: 1;
        304	                    background-color: white;
        305	                    border-radius: 8px;
        306	                    border: 1px solid #e2e8f0;
        307	                    padding: 1rem;
        308	                    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        309	                }
        310	                
        311	                .activity-header {
        312	                    display: flex;
        313	                    justify-content: space-between;
        314	                    align-items: flex-start;
        315	                    margin-bottom: 0.5rem;
        316	                }
        317	                
        318	                .activity-header h4 {
        319	                    margin: 0;
        320	                    font-size: 0.95rem;
        321	                    color: #2d3748;
        322	                    font-weight: 500;
        323	                }
        324	                
        325	                .activity-time {
        326	                    color: #718096;
        327	                    font-size: 0.85rem;
        328	                }
        329	                
        330	                .activity-details {
        331	                    margin: 0.5rem 0;
        332	                    font-size: 0.9rem;
        333	                    color: #4a5568;
        334	                }
        335	                
        336	                .activity-action-buttons {
        337	                    display: flex;
        338	                    gap: 0.75rem;
        339	                    margin-top: 0.75rem;
        340	                }
        341	                
        342	                .veto-button, .discuss-button {
        343	                    padding: 0.4rem 0.75rem;
        344	                    color: white;
        345	                    border: none;
        346	                    border-radius: 4px;
        347	                    font-size: 0.85rem;
        348	                    cursor: pointer;
        349	                    transition: all 0.2s ease;
        350	                }
        351	                
        352	                .veto-button {
        353	                    background-color: #e53e3e;
        354	                }
        355	                
        356	                .veto-button:hover {
        357	                    background-color: #c53030;
        358	                }
        359	                
        360	                .discuss-button {
        361	                    display: flex;
        362	                    align-items: center;
        363	                    justify-content: center;
        364	                    gap: 0.25rem;
        365	                    font-weight: 500;
        366	                }
        367	                
        368	                .discuss-button:hover {
        369	                    opacity: 0.9;
        370	                    transform: translateY(-1px);
        371	                }
        372	                
        373	                .discuss-button::before {
        374	                    content: "💬";
        375	                    font-size: 0.9rem;
        376	                }
        377	                
        378	                .veto-button:disabled {
        379	                    background-color: #cbd5e0;
        380	                    cursor: not-allowed;
        381	                }
        382	                
        383	                .badge {
        384	                    display: inline-block;
        385	                    padding: 0.25rem 0.5rem;
        386	                    font-size: 0.75rem;
        387	                    font-weight: 600;
        388	                    border-radius: 4px;
        389	                    margin-top: 0.5rem;
        390	                }
        391	                
        392	                .override-badge {
        393	                    background-color: #fed7d7;
        394	                    color: #9b2c2c;
        395	                }
        396	                
        397	                .feedback-message {
        398	                    margin-top: 0.75rem;
        399	                    padding: 0.5rem;
        400	                    border-radius: 4px;
        401	                    font-size: 0.85rem;
        402	                }
        403	                
        404	                .feedback-message.error {
        405	                    background-color: #fed7d7;
        406	                    color: #9b2c2c;
        407	                }
        408	                
        409	                .feedback-message.success {
        410	                    background-color: #c6f6d5;
        411	                    color: #276749;
        412	                }
        413	                
        414	                .empty-state {
        415	                    background-color: #f7fafc;
        416	                    border: 1px dashed #cbd5e0;
        417	                    border-radius: 8px;
        418	                    padding: 2rem;
        419	                    text-align: center;
        420	                    color: #4a5568;
        421	                }
        422	                
        423	                .empty-state p {
        424	                    margin-bottom: 1.5rem;
        425	                }
        426	                
        427	                .action-button {
        428	                    padding: 0.75rem 1.25rem;
        429	                    border-radius: 6px;
        430	                    border: none;
        431	                    color: white;
        432	                    font-weight: 600;
        433	                    cursor: pointer;
        434	                    transition: opacity 0.2s;
        435	                }
        436	                
        437	                .action-button:hover {
        438	                    opacity: 0.9;
        439	                }
        440	                
        441	                @media (max-width: 640px) {
        442	                    .activity-controls {
        443	                        flex-direction: column;
        444	                        align-items: flex-start;
        445	                        gap: 1rem;
        446	                    }
        447	                    
        448	                    .control-filters, .control-sort {
        449	                        width: 100%;
        450	                        display: flex;
        451	                        align-items: center;
        452	                        justify-content: space-between;
        453	                    }
        454	                    
        455	                    .activity-item {
        456	                        flex-direction: column;
        457	                    }
        458	                    
        459	                    .activity-icon {
        460	                        margin-bottom: 0.5rem;
        461	                    }
        462	                    
        463	                    .activity-header {
        464	                        flex-direction: column;
        465	                    }
        466	                    
        467	                    .activity-time {
        468	                        margin-top: 0.25rem;
        469	                    }
        470	                    
        471	                    .activity-action-buttons {
        472	                        flex-direction: column;
        473	                        width: 100%;
        474	                        gap: 0.5rem;
        475	                    }
        476	                    
        477	                    .veto-button, .discuss-button {
        478	                        width: 100%;
        479	                        justify-content: center;
        480	                    }
        481	                    
        482	                    .date-header {
        483	                        padding-left: 0.5rem;
        484	                    }
        485	                }
        486	                
        487	                /* Tablet responsiveness */
        488	                @media (min-width: 641px) and (max-width: 1024px) {
        489	                    .activity-list {
        490	                        padding: 0 0.5rem;
        491	                    }
        492	                    
        493	                    .activity-content {
        494	                        flex: 1;
        495	                    }
        496	                    
        497	                    .activity-action-buttons {
        498	                        flex-wrap: wrap;
        499	                    }
        500	                }
        501	                
        502	                /* Add animation for refreshing content */
        503	                @keyframes refreshPulse {
        504	                    0% { opacity: 1; }
        505	                    50% { opacity: 0.6; }
        506	                    100% { opacity: 1; }
        507	                }
        508	                
        509	                .refreshing {
        510	                    animation: refreshPulse 1.5s infinite;
        511	                }
        512	            `}</style>
        513	        </div>
        514	    );
        515	};
        516	
        517	export default ActivityAuditTab;

==============================================
FILE: ./frontend/src/components/dashboard/PositionsMatrixTab.tsx
==============================================

          1	import React, { useState } from 'react';
          2	import IssuesMatrix, { Issue } from '../IssuesMatrix';
          3	
          4	import { useDashboard } from '../../context/DashboardContext';
          5	import { useChatContext } from '../../hooks/useChatContext';
          6	
          7	interface PositionsMatrixTabProps {
          8	  welcomeMessage: string;
          9	  agentColor: string;
         10	  onChatMaximize: () => void;
         11	}
         12	
         13	/**
         14	 * Tab component for the Positions Matrix view in the dashboard
         15	 * This is an enhanced version of the IssuesMatrix component with filtering capabilities
         16	 */
         17	const PositionsMatrixTab: React.FC<PositionsMatrixTabProps> = ({
         18	  welcomeMessage,
         19	  agentColor,
         20	  onChatMaximize
         21	}) => {
         22	  const { issues, selectIssue } = useDashboard();
         23	  const { setChatContext } = useChatContext();
         24	
         25	  // State for filter controls
         26	  const [showAllIssues, setShowAllIssues] = useState(false);
         27	  const [sortBy, setSortBy] = useState<'recent' | 'priority'>('priority');
         28	  
         29	  // Filter issues based on current settings
         30	  const filteredIssues = issues.filter(issue => {
         31	    // If "Show All" is disabled, only show issues with a stance
         32	    if (!showAllIssues && !issue.stance) {
         33	      return false;
         34	    }
         35	    return true;
         36	  });
         37	  
         38	  // Sort issues based on current settings
         39	  const sortedIssues = [...filteredIssues].sort((a, b) => {
         40	    if (sortBy === 'priority') {
         41	      // Priority issues first, then alphabetically
         42	      if (a.isPriority && !b.isPriority) return -1;
         43	      if (!a.isPriority && b.isPriority) return 1;
         44	      return a.title.localeCompare(b.title);
         45	    } else {
         46	      // We would use timestamp for recent sorting, but we're using title for this demo
         47	      return a.title.localeCompare(b.title);
         48	    }
         49	  });
         50	
         51	  // Handler for "Discuss a New Issue"
         52	  // Handler for "Discuss a New Issue"
         53	  const handleDiscussNewIssue = () => {
         54	    setChatContext({
         55	      type: 'positions',
         56	      data: {
         57	        newIssue: true
         58	      }
         59	    });
         60	    onChatMaximize();
         61	  };
         62	
         63	  // Handler for discussing any existing issue
         64	  const handleDiscussIssue = (issueId: string, title: string) => {
         65	    // Find the issue with the matching ID
         66	    const issue = issues.find(issue => issue.id === issueId);
         67	    
         68	    // Update UI state in dashboard context
         69	    selectIssue(issueId);
         70	    
         71	    // Set the chat context with detailed information
         72	    setChatContext({
         73	      type: 'positions',
         74	      data: {
         75	        selectedIssue: issue || { id: issueId, title }
         76	      }
         77	    });
         78	    
         79	    // Maximize the chat panel
         80	    onChatMaximize();
         81	  };
         82	
         83	  return (
         84	    <div className="positions-matrix-tab">
         85	      <header className="tab-header">
         86	        <h2>{welcomeMessage} here are your positions</h2>
         87	        <p className="tab-description">
         88	          This is where your positions on important issues live. 
         89	          You can filter, sort, and discuss any issue with your agent.
         90	        </p>
         91	      </header>
         92	      
         93	      <div className="matrix-controls">
         94	        <div className="control-filters">
         95	          <label className="toggle-switch">
         96	            <input 
         97	              type="checkbox" 
         98	              checked={showAllIssues} 
         99	              onChange={() => setShowAllIssues(!showAllIssues)}
        100	            />
        101	            <span className="toggle-slider"></span>
        102	            <span className="toggle-label">Show all issues</span>
        103	          </label>
        104	        </div>
        105	        
        106	        <div className="control-sort">
        107	          <label htmlFor="sort-select">Sort by:</label>
        108	          <select 
        109	            id="sort-select"
        110	            value={sortBy}
        111	            onChange={(e) => setSortBy(e.target.value as 'recent' | 'priority')}
        112	          >
        113	            <option value="priority">Priority</option>
        114	            <option value="recent">Most Recent</option>
        115	          </select>
        116	        </div>
        117	      </div>
        118	      
        119	      {filteredIssues.length === 0 ? (
        120	        <div className="empty-state">
        121	          <p>
        122	            {showAllIssues 
        123	              ? "No issues found. You haven't taken positions on any issues yet." 
        124	              : "No issues with positions found. Toggle 'Show all issues' to see all available issues."}
        125	          </p>
        126	          <button 
        127	            className="action-button"
        128	            style={{ backgroundColor: agentColor }}
        129	            onClick={() => setShowAllIssues(true)}
        130	          >
        131	            Explore Available Issues
        132	          </button>
        133	        </div>
        134	      ) : (
        135	        <div className="issues-matrix-wrapper">
        136	          <IssuesMatrix
        137	            selectedIssues={sortedIssues}
        138	            step={7} // Use step 7 for dashboard view
        139	            agentColor={agentColor}
        140	            onDiscussIssue={handleDiscussIssue}
        141	          />
        142	        </div>
        143	      )}
        144	
        145	      <div className="issue-actions">
        146	        <button 
        147	          className="action-button"
        148	          style={{ backgroundColor: agentColor }}
        149	          onClick={handleDiscussNewIssue}
        150	        >
        151	          Discuss a New Issue
        152	        </button>
        153	      </div>
        154	      
        155	      <style>{`
        156	        .positions-matrix-tab {
        157	          padding: 1rem 0;
        158	        }
        159	        
        160	        .tab-header {
        161	          margin-bottom: 1.5rem;
        162	        }
        163	        
        164	        .tab-header h2 {
        165	          font-size: 1.5rem;
        166	          margin-bottom: 0.5rem;
        167	          color: #2d3748;
        168	        }
        169	        
        170	        .tab-description {
        171	          color: #4a5568;
        172	          line-height: 1.5;
        173	        }
        174	        
        175	        .matrix-controls {
        176	          display: flex;
        177	          justify-content: space-between;
        178	          align-items: center;
        179	          margin-bottom: 1.5rem;
        180	          padding: 0.75rem 1rem;
        181	          background-color: #f7fafc;
        182	          border-radius: 8px;
        183	        }
        184	        
        185	        .toggle-switch {
        186	          position: relative;
        187	          display: inline-flex;
        188	          align-items: center;
        189	          cursor: pointer;
        190	        }
        191	        
        192	        .toggle-switch input {
        193	          opacity: 0;
        194	          width: 0;
        195	          height: 0;
        196	        }
        197	        
        198	        .toggle-slider {
        199	          position: relative;
        200	          display: inline-block;
        201	          width: 36px;
        202	          height: 20px;
        203	          background-color: #cbd5e0;
        204	          border-radius: 20px;
        205	          margin-right: 10px;
        206	          transition: 0.3s;
        207	        }
        208	        
        209	        .toggle-slider:before {
        210	          content: "";
        211	          position: absolute;
        212	          height: 16px;
        213	          width: 16px;
        214	          left: 2px;
        215	          bottom: 2px;
        216	          background-color: white;
        217	          border-radius: 50%;
        218	          transition: 0.3s;
        219	        }
        220	        
        221	        input:checked + .toggle-slider {
        222	          background-color: #4299e1;
        223	        }
        224	        
        225	        input:checked + .toggle-slider:before {
        226	          transform: translateX(16px);
        227	        }
        228	        
        229	        .toggle-label {
        230	          font-size: 0.9rem;
        231	          color: #4a5568;
        232	        }
        233	        
        234	        .control-sort select {
        235	          padding: 0.35rem 0.5rem;
        236	          border-radius: 4px;
        237	          border: 1px solid #e2e8f0;
        238	          background-color: white;
        239	          font-size: 0.9rem;
        240	          margin-left: 8px;
        241	        }
        242	        
        243	        .issues-matrix-wrapper {
        244	          margin-bottom: 2rem;
        245	        }
        246	        
        247	        .issue-actions {
        248	          display: flex;
        249	          justify-content: center;
        250	          margin-top: 2rem;
        251	        }
        252	        
        253	        .action-button {
        254	          padding: 0.75rem 1.25rem;
        255	          border-radius: 6px;
        256	          border: none;
        257	          color: white;
        258	          font-weight: 600;
        259	          cursor: pointer;
        260	          transition: opacity 0.2s;
        261	        }
        262	        
        263	        .action-button:hover {
        264	          opacity: 0.9;
        265	        }
        266	        
        267	        .empty-state {
        268	          background-color: #f7fafc;
        269	          border: 1px dashed #cbd5e0;
        270	          border-radius: 8px;
        271	          padding: 2rem;
        272	          text-align: center;
        273	          color: #4a5568;
        274	        }
        275	        
        276	        .empty-state p {
        277	          margin-bottom: 1.5rem;
        278	        }
        279	        
        280	        @media (max-width: 640px) {
        281	            .matrix-controls {
        282	                flex-direction: column;
        283	                align-items: flex-start;
        284	                gap: 1rem;
        285	            }
        286	            
        287	            .control-sort {
        288	                width: 100%;
        289	                display: flex;
        290	                justify-content: space-between;
        291	            }
        292	            
        293	            .issue-actions {
        294	                flex-direction: column;
        295	                width: 100%;
        296	            }
        297	            
        298	            .action-button {
        299	                width: 100%;
        300	                margin: 0.5rem 0;
        301	                padding: 1rem;
        302	            }
        303	            
        304	            .tab-header h2 {
        305	                font-size: 1.25rem;
        306	            }
        307	        }
        308	        
        309	        /* Tablet responsiveness */
        310	        @media (min-width: 641px) and (max-width: 1024px) {
        311	            .issues-matrix-wrapper {
        312	                overflow-x: auto;
        313	            }
        314	        }
        315	        
        316	        /* Data refresh animation */
        317	        @keyframes refreshPulse {
        318	            0% { opacity: 1; }
        319	            50% { opacity: 0.6; }
        320	            100% { opacity: 1; }
        321	        }
        322	        
        323	        .refreshing {
        324	            animation: refreshPulse 1.5s infinite;
        325	        }
        326	      `}</style>
        327	    </div>
        328	  );
        329	};
        330	
        331	export default PositionsMatrixTab;

==============================================
FILE: ./frontend/src/components/dashboard/ProposalsTab.tsx
==============================================

          1	import React, { useState, useEffect } from 'react';
          2	import { useDashboard } from '../../context/DashboardContext';
          3	import { useChatContext } from '../../hooks/useChatContext';
          4	
          5	interface Proposal {
          6	    id: string;
          7	    title: string;
          8	    description: string;
          9	    status: 'draft' | 'open' | 'closed' | 'approved' | 'rejected';
         10	    createdAt: string;
         11	    closeAt?: string;
         12	    isNegotiated?: boolean;
         13	}
         14	
         15	interface ProposalsTabProps {
         16	    welcomeMessage: string;
         17	    agentColor: string;
         18	    onChatMaximize?: () => void; // Add prop to maximize chat when discussing a proposal
         19	}
         20	
         21	/**
         22	 * Tab component for the Proposals view in the dashboard
         23	 * Manages proposal creation and existing proposals
         24	 */
         25	const ProposalsTab: React.FC<ProposalsTabProps> = ({
         26	    welcomeMessage,
         27	    agentColor,
         28	    onChatMaximize
         29	}) => {
         30	    // Get data from context
         31	    const { currentTabData, selectProposal } = useDashboard();
         32	    const { setChatContext } = useChatContext();
         33	
         34	    // State for filter controls
         35	    const [filterStatus, setFilterStatus] = useState<'all' | 'open' | 'closed'>('all');
         36	    const [filterType, setFilterType] = useState<'all' | 'negotiated' | 'direct'>('all');
         37	    
         38	    // State for the proposal creation dialog
         39	    const [showNewProposalDialog, setShowNewProposalDialog] = useState(false);
         40	    
         41	    // Get proposals from context or use default if not available
         42	    const proposals = currentTabData.proposals?.proposals || [];
         43	    
         44	    // Filter proposals based on current settings
         45	    const filteredProposals = proposals.filter(proposal => {
         46	        // Filter by status
         47	        if (filterStatus !== 'all') {
         48	            if (filterStatus === 'open' && (proposal.status !== 'open' && proposal.status !== 'draft')) {
         49	                return false;
         50	            }
         51	            if (filterStatus === 'closed' && (proposal.status !== 'closed' && proposal.status !== 'approved' && proposal.status !== 'rejected')) {
         52	                return false;
         53	            }
         54	        }
         55	        
         56	        // Filter by type
         57	        if (filterType !== 'all') {
         58	            if (filterType === 'negotiated' && !proposal.isNegotiated) {
         59	                return false;
         60	            }
         61	            if (filterType === 'direct' && proposal.isNegotiated) {
         62	                return false;
         63	            }
         64	        }
         65	        
         66	        return true;
         67	    });
         68	    
         69	    // Format dates
         70	    const formatDate = (dateString: string) => {
         71	        const date = new Date(dateString);
         72	        return date.toLocaleDateString();
         73	    };
         74	    
         75	    // Calculate days remaining
         76	    const getDaysRemaining = (closeDate?: string) => {
         77	        if (!closeDate) return 'No deadline';
         78	        
         79	        const now = new Date();
         80	        const close = new Date(closeDate);
         81	        const diffTime = close.getTime() - now.getTime();
         82	        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
         83	        
         84	        if (diffDays < 0) return 'Closed';
         85	        if (diffDays === 0) return 'Closes today';
         86	        return `${diffDays} day${diffDays !== 1 ? 's' : ''} remaining`;
         87	    };
         88	    
         89	    // Get status badge style
         90	    const getStatusBadgeStyle = (status: string) => {
         91	        switch (status) {
         92	            case 'draft':
         93	                return { backgroundColor: '#cbd5e0', color: '#2d3748' };
         94	            case 'open':
         95	                return { backgroundColor: '#90cdf4', color: '#2c5282' };
         96	            case 'closed':
         97	                return { backgroundColor: '#e2e8f0', color: '#4a5568' };
         98	            case 'approved':
         99	                return { backgroundColor: '#9ae6b4', color: '#276749' };
        100	            case 'rejected':
        101	                return { backgroundColor: '#fed7d7', color: '#9b2c2c' };
        102	            default:
        103	                return { backgroundColor: '#e2e8f0', color: '#4a5568' };
        104	        }
        105	    };
        106	    
        107	    return (
        108	        <div className="proposals-tab">
        109	            <header className="tab-header">
        110	                <h2>{welcomeMessage} this is where your ideas take shape</h2>
        111	                <p className="tab-description">
        112	                    Create and manage proposals, from initial draft to final result.
        113	                    You can work directly or collaborate with your agent to refine your ideas.
        114	                </p>
        115	            </header>
        116	            
        117	            <div className="proposal-controls">
        118	                <div className="filter-controls">
        119	                    <div className="filter-group">
        120	                        <label htmlFor="status-filter">Status:</label>
        121	                        <select
        122	                            id="status-filter"
        123	                            value={filterStatus}
        124	                            onChange={(e) => setFilterStatus(e.target.value as 'all' | 'open' | 'closed')}
        125	                        >
        126	                            <option value="all">All Statuses</option>
        127	                            <option value="open">Active</option>
        128	                            <option value="closed">Completed</option>
        129	                        </select>
        130	                    </div>
        131	                    
        132	                    <div className="filter-group">
        133	                        <label htmlFor="type-filter">Type:</label>
        134	                        <select
        135	                            id="type-filter"
        136	                            value={filterType}
        137	                            onChange={(e) => setFilterType(e.target.value as 'all' | 'negotiated' | 'direct')}
        138	                        >
        139	                            <option value="all">All Types</option>
        140	                            <option value="negotiated">Agent-Negotiated</option>
        141	                            <option value="direct">Direct</option>
        142	                        </select>
        143	                    </div>
        144	                </div>
        145	                
        146	                <button
        147	                    className="new-proposal-button"
        148	                    style={{ backgroundColor: agentColor }}
        149	                    onClick={() => setShowNewProposalDialog(true)}
        150	                >
        151	                    New Proposal
        152	                </button>
        153	            </div>
        154	            
        155	            {filteredProposals.length === 0 ? (
        156	                <div className="empty-state">
        157	                    <p>No proposals found with the current filter settings.</p>
        158	                    <button
        159	                        className="action-button"
        160	                        style={{ backgroundColor: agentColor }}
        161	                        onClick={() => {
        162	                            setFilterStatus('all');
        163	                            setFilterType('all');
        164	                        }}
        165	                    >
        166	                        Show All Proposals
        167	                    </button>
        168	                    <p>- or -</p>
        169	                    <button
        170	                        className="action-button"
        171	                        style={{ backgroundColor: agentColor }}
        172	                        onClick={() => setShowNewProposalDialog(true)}
        173	                    >
        174	                        Create New Proposal
        175	                    </button>
        176	                </div>
        177	            ) : (
        178	                <div className="proposals-list">
        179	                    {filteredProposals.map(proposal => (
        180	                        <div className="proposal-card" key={proposal.id}>
        181	                            <div className="proposal-header">
        182	                                <h3 className="proposal-title">{proposal.title}</h3>
        183	                                <div className="proposal-badges">
        184	                                    <span className="status-badge" style={getStatusBadgeStyle(proposal.status)}>
        185	                                        {proposal.status.charAt(0).toUpperCase() + proposal.status.slice(1)}
        186	                                    </span>
        187	                                    {proposal.isNegotiated && (
        188	                                        <span className="type-badge">
        189	                                            Agent-Negotiated
        190	                                        </span>
        191	                                    )}
        192	                                </div>
        193	                            </div>
        194	                            
        195	                            <p className="proposal-description">{proposal.description}</p>
        196	                            
        197	                            <div className="proposal-footer">
        198	                                <div className="proposal-dates">
        199	                                    <span>Created: {formatDate(proposal.createdAt)}</span>
        200	                                    {proposal.closeAt && (
        201	                                        <span className="proposal-deadline">
        202	                                            {getDaysRemaining(proposal.closeAt)}
        203	                                        </span>
        204	                                    )}
        205	                                </div>
        206	                                
        207	                                <div className="proposal-actions">
        208	                                    <button className="view-button">
        209	                                        View Details
        210	                                    </button>
        211	                                    {(proposal.status === 'draft' || proposal.status === 'open') && (
        212	                                        <button className="edit-button">
        213	                                            Edit
        214	                                        </button>
        215	                                    )}
        216	                                    <button
        217	                                        className="discuss-button"
        218	                                        style={{ backgroundColor: agentColor }}
        219	                                        onClick={() => {
        220	                                            // Update UI state
        221	                                            selectProposal(proposal.id);
        222	                                            
        223	                                            // Update chat context
        224	                                            setChatContext({
        225	                                                type: 'proposals',
        226	                                                data: {
        227	                                                    selectedProposal: proposal
        228	                                                }
        229	                                            });
        230	                                            
        231	                                            // Maximize chat panel if handler provided
        232	                                            if (onChatMaximize) {
        233	                                                onChatMaximize();
        234	                                            }
        235	                                        }}
        236	                                    >
        237	                                        Discuss
        238	                                    </button>
        239	                                </div>
        240	                            </div>
        241	                        </div>
        242	                    ))}
        243	                </div>
        244	            )}
        245	            
        246	            {/* New Proposal Dialog (simple mockup) */}
        247	            {showNewProposalDialog && (
        248	                <div className="dialog-overlay">
        249	                    <div className="dialog-content">
        250	                        <div className="dialog-header">
        251	                            <h3>Create New Proposal</h3>
        252	                            <button className="close-button" onClick={() => setShowNewProposalDialog(false)}>×</button>
        253	                        </div>
        254	                        <div className="dialog-body">
        255	                            <div className="creation-options">
        256	                                <button 
        257	                                    className="creation-option" 
        258	                                    style={{ borderColor: agentColor }}
        259	                                    onClick={() => setShowNewProposalDialog(false)}
        260	                                >
        261	                                    <div className="option-icon" style={{ backgroundColor: agentColor }}>
        262	                                        💬
        263	                                    </div>
        264	                                    <div className="option-text">
        265	                                        <h4>Collaborative Creation</h4>
        266	                                        <p>Work with your agent to refine your idea through conversation</p>
        267	                                    </div>
        268	                                </button>
        269	                                
        270	                                <button 
        271	                                    className="creation-option"
        272	                                    style={{ borderColor: agentColor }}
        273	                                    onClick={() => setShowNewProposalDialog(false)}
        274	                                >
        275	                                    <div className="option-icon" style={{ backgroundColor: agentColor }}>
        276	                                        📝
        277	                                    </div>
        278	                                    <div className="option-text">
        279	                                        <h4>Direct Creation</h4>
        280	                                        <p>Create a proposal directly using the form editor</p>
        281	                                    </div>
        282	                                </button>
        283	                                
        284	                                <button 
        285	                                    className="creation-option"
        286	                                    style={{ borderColor: agentColor }}
        287	                                    onClick={() => setShowNewProposalDialog(false)}
        288	                                >
        289	                                    <div className="option-icon" style={{ backgroundColor: agentColor }}>
        290	                                        🤝
        291	                                    </div>
        292	                                    <div className="option-text">
        293	                                        <h4>Start Negotiation</h4>
        294	                                        <p>Begin a multi-agent negotiation that will become a proposal</p>
        295	                                    </div>
        296	                                </button>
        297	                            </div>
        298	                        </div>
        299	                    </div>
        300	                </div>
        301	            )}
        302	            
        303	            <style>{`
        304	                .proposals-tab {
        305	                    padding: 1rem 0;
        306	                    position: relative;
        307	                }
        308	                
        309	                .tab-header {
        310	                    margin-bottom: 1.5rem;
        311	                }
        312	                
        313	                .tab-header h2 {
        314	                    font-size: 1.5rem;
        315	                    margin-bottom: 0.5rem;
        316	                    color: #2d3748;
        317	                }
        318	                
        319	                .tab-description {
        320	                    color: #4a5568;
        321	                    line-height: 1.5;
        322	                }
        323	                
        324	                .proposal-controls {
        325	                    display: flex;
        326	                    justify-content: space-between;
        327	                    align-items: center;
        328	                    margin-bottom: 1.5rem;
        329	                    padding: 0.75rem 1rem;
        330	                    background-color: #f7fafc;
        331	                    border-radius: 8px;
        332	                }
        333	                
        334	                .filter-controls {
        335	                    display: flex;
        336	                    gap: 1rem;
        337	                }
        338	                
        339	                .filter-group {
        340	                    display: flex;
        341	                    align-items: center;
        342	                    gap: 0.5rem;
        343	                }
        344	                
        345	                .filter-group select {
        346	                    padding: 0.35rem 0.5rem;
        347	                    border-radius: 4px;
        348	                    border: 1px solid #e2e8f0;
        349	                    background-color: white;
        350	                    font-size: 0.9rem;
        351	                }
        352	                
        353	                .new-proposal-button {
        354	                    padding: 0.5rem 1rem;
        355	                    border-radius: 6px;
        356	                    color: white;
        357	                    font-weight: 600;
        358	                    border: none;
        359	                    cursor: pointer;
        360	                }
        361	                
        362	                .proposals-list {
        363	                    display: grid;
        364	                    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        365	                    gap: 1.5rem;
        366	                    margin-bottom: 2rem;
        367	                }
        368	                
        369	                .proposal-card {
        370	                    background-color: white;
        371	                    border-radius: 8px;
        372	                    border: 1px solid #e2e8f0;
        373	                    padding: 1.25rem;
        374	                    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        375	                    transition: all 0.2s ease;
        376	                    display: flex;
        377	                    flex-direction: column;
        378	                }
        379	                
        380	                .proposal-card:hover {
        381	                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        382	                    transform: translateY(-2px);
        383	                }
        384	                
        385	                .proposal-header {
        386	                    display: flex;
        387	                    flex-direction: column;
        388	                    margin-bottom: 0.75rem;
        389	                }
        390	                
        391	                .proposal-title {
        392	                    margin: 0 0 0.75rem;
        393	                    font-size: 1.1rem;
        394	                    color: #2d3748;
        395	                    line-height: 1.3;
        396	                }
        397	                
        398	                .proposal-badges {
        399	                    display: flex;
        400	                    gap: 0.5rem;
        401	                    margin-bottom: 0.5rem;
        402	                }
        403	                
        404	                .status-badge, .type-badge {
        405	                    font-size: 0.75rem;
        406	                    padding: 0.2rem 0.5rem;
        407	                    border-radius: 4px;
        408	                    font-weight: 600;
        409	                }
        410	                
        411	                .type-badge {
        412	                    background-color: #e9d8fd;
        413	                    color: #553c9a;
        414	                }
        415	                
        416	                .proposal-description {
        417	                    color: #4a5568;
        418	                    font-size: 0.9rem;
        419	                    line-height: 1.5;
        420	                    margin: 0.5rem 0 1rem;
        421	                    flex-grow: 1;
        422	                }
        423	                
        424	                .proposal-footer {
        425	                    border-top: 1px solid #e2e8f0;
        426	                    padding-top: 1rem;
        427	                    margin-top: auto;
        428	                }
        429	                
        430	                .proposal-dates {
        431	                    display: flex;
        432	                    justify-content: space-between;
        433	                    color: #718096;
        434	                    font-size: 0.85rem;
        435	                    margin-bottom: 0.75rem;
        436	                }
        437	                
        438	                .proposal-deadline {
        439	                    font-weight: 600;
        440	                }
        441	                
        442	                .proposal-actions {
        443	                    display: flex;
        444	                    justify-content: flex-end;
        445	                    gap: 0.75rem;
        446	                }
        447	                
        448	                .view-button, .edit-button, .discuss-button {
        449	                    padding: 0.4rem 0.75rem;
        450	                    border-radius: 4px;
        451	                    font-size: 0.85rem;
        452	                    cursor: pointer;
        453	                    transition: all 0.2s ease;
        454	                }
        455	                
        456	                .view-button {
        457	                    background-color: #e2e8f0;
        458	                    color: #2d3748;
        459	                    border: none;
        460	                }
        461	                
        462	                .view-button:hover {
        463	                    background-color: #cbd5e0;
        464	                }
        465	                
        466	                .edit-button {
        467	                    background-color: #4299e1;
        468	                    color: white;
        469	                    border: none;
        470	                }
        471	                
        472	                .edit-button:hover {
        473	                    background-color: #3182ce;
        474	                }
        475	                
        476	                .discuss-button {
        477	                    color: white;
        478	                    border: none;
        479	                    font-weight: 500;
        480	                    display: flex;
        481	                    align-items: center;
        482	                    justify-content: center;
        483	                    gap: 0.25rem;
        484	                }
        485	                
        486	                .discuss-button:hover {
        487	                    opacity: 0.9;
        488	                    transform: translateY(-1px);
        489	                }
        490	                
        491	                .discuss-button::before {
        492	                    content: "💬";
        493	                    font-size: 0.9rem;
        494	                }
        495	                
        496	                .empty-state {
        497	                    background-color: #f7fafc;
        498	                    border: 1px dashed #cbd5e0;
        499	                    border-radius: 8px;
        500	                    padding: 2rem;
        501	                    text-align: center;
        502	                    color: #4a5568;
        503	                }
        504	                
        505	                .empty-state p {
        506	                    margin-bottom: 1.5rem;
        507	                }
        508	                
        509	                .action-button {
        510	                    padding: 0.75rem 1.25rem;
        511	                    border-radius: 6px;
        512	                    border: none;
        513	                    color: white;
        514	                    font-weight: 600;
        515	                    cursor: pointer;
        516	                    transition: opacity 0.2s;
        517	                    margin: 0 auto;
        518	                    display: block;
        519	                }
        520	                
        521	                .dialog-overlay {
        522	                    position: fixed;
        523	                    top: 0;
        524	                    left: 0;
        525	                    right: 0;
        526	                    bottom: 0;
        527	                    background-color: rgba(0, 0, 0, 0.5);
        528	                    display: flex;
        529	                    align-items: center;
        530	                    justify-content: center;
        531	                    z-index: 1000;
        532	                }
        533	                
        534	                .dialog-content {
        535	                    background-color: white;
        536	                    border-radius: 8px;
        537	                    width: 90%;
        538	                    max-width: 600px;
        539	                    max-height: 90vh;
        540	                    overflow-y: auto;
        541	                    box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        542	                }
        543	                
        544	                .dialog-header {
        545	                    display: flex;
        546	                    justify-content: space-between;
        547	                    align-items: center;
        548	                    padding: 1rem 1.5rem;
        549	                    border-bottom: 1px solid #e2e8f0;
        550	                }
        551	                
        552	                .dialog-header h3 {
        553	                    margin: 0;
        554	                    font-size: 1.25rem;
        555	                    color: #2d3748;
        556	                }
        557	                
        558	                .close-button {
        559	                    background: none;
        560	                    border: none;
        561	                    font-size: 1.5rem;
        562	                    color: #718096;
        563	                    cursor: pointer;
        564	                }
        565	                
        566	                .dialog-body {
        567	                    padding: 1.5rem;
        568	                }
        569	                
        570	                .creation-options {
        571	                    display: flex;
        572	                    flex-direction: column;
        573	                    gap: 1rem;
        574	                }
        575	                
        576	                .creation-option {
        577	                    display: flex;
        578	                    align-items: center;
        579	                    padding: 1.25rem;
        580	                    border-radius: 8px;
        581	                    border: 2px solid;
        582	                    background-color: white;
        583	                    cursor: pointer;
        584	                    text-align: left;
        585	                    transition: all 0.2s ease;
        586	                }
        587	                
        588	                .creation-option:hover {
        589	                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        590	                    transform: translateY(-2px);
        591	                }
        592	                
        593	                .option-icon {
        594	                    width: 45px;
        595	                    height: 45px;
        596	                    border-radius: 50%;
        597	                    color: white;
        598	                    display: flex;
        599	                    align-items: center;
        600	                    justify-content: center;
        601	                    margin-right: 1rem;
        602	                    flex-shrink: 0;
        603	                    font-size: 1.25rem;
        604	                }
        605	                
        606	                .option-text {
        607	                    flex-grow: 1;
        608	                }
        609	                
        610	                .option-text h4 {
        611	                    margin: 0 0 0.25rem;
        612	                    font-size: 1.1rem;
        613	                    color: #2d3748;
        614	                }
        615	                
        616	                .option-text p {
        617	                    margin: 0;
        618	                    font-size: 0.9rem;
        619	                    color: #4a5568;
        620	                }
        621	                
        622	                @media (max-width: 640px) {
        623	                    .proposal-controls {
        624	                        flex-direction: column;
        625	                        gap: 1rem;
        626	                    }
        627	                    
        628	                    .filter-controls {
        629	                        flex-direction: column;
        630	                        width: 100%;
        631	                    }
        632	                    
        633	                    .filter-group {
        634	                        width: 100%;
        635	                        justify-content: space-between;
        636	                    }
        637	                    
        638	                    .new-proposal-button {
        639	                        width: 100%;
        640	                    }
        641	                    
        642	                    .proposals-list {
        643	                        grid-template-columns: 1fr;
        644	                    }
        645	                    
        646	                    .proposal-actions {
        647	                        flex-wrap: wrap;
        648	                        gap: 0.5rem;
        649	                    }
        650	                    
        651	                    .proposal-actions button {
        652	                        flex: 1;
        653	                        min-width: calc(50% - 0.25rem);
        654	                        justify-content: center;
        655	                    }
        656	                    
        657	                    .proposal-header {
        658	                        flex-direction: column;
        659	                        align-items: flex-start;
        660	                    }
        661	                    
        662	                    .proposal-badges {
        663	                        margin-top: 0.5rem;
        664	                    }
        665	                    
        666	                    .dialog-content {
        667	                        width: 95%;
        668	                    }
        669	                    
        670	                    .creation-option {
        671	                        flex-direction: column;
        672	                        text-align: center;
        673	                    }
        674	                    
        675	                    .option-icon {
        676	                        margin-right: 0;
        677	                        margin-bottom: 0.5rem;
        678	                    }
        679	                }
        680	                
        681	                /* Tablet responsiveness */
        682	                @media (min-width: 641px) and (max-width: 1024px) {
        683	                    .proposals-list {
        684	                        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        685	                    }
        686	                    
        687	                    .proposal-actions {
        688	                        flex-wrap: wrap;
        689	                    }
        690	                }
        691	                
        692	                /* Data refresh animation */
        693	                @keyframes refreshPulse {
        694	                    0% { opacity: 1; }
        695	                    50% { opacity: 0.6; }
        696	                    100% { opacity: 1; }
        697	                }
        698	                
        699	                .refreshing {
        700	                    animation: refreshPulse 1.5s infinite;
        701	                }
        702	            `}</style>
        703	        </div>
        704	    );
        705	};
        706	
        707	export default ProposalsTab;

==============================================
FILE: ./frontend/src/context/AuthContext.tsx
==============================================

          1	import React, { createContext, useState, useEffect, useContext, ReactNode } from 'react';
          2	import { useNavigate } from 'react-router-dom';
          3	import { auth as authApi } from '../api/apiClient';
          4	
          5	interface AuthContextType {
          6	  isAuthenticated: boolean;
          7	  user: any;
          8	  loading: boolean;
          9	  login: (token: string) => void;
         10	  logout: () => void;
         11	}
         12	
         13	const AuthContext = createContext<AuthContextType | null>(null);
         14	
         15	export const useAuth = () => {
         16	  const context = useContext(AuthContext);
         17	  if (!context) {
         18	    throw new Error('useAuth must be used within an AuthProvider');
         19	  }
         20	  return context;
         21	};
         22	
         23	interface AuthProviderProps {
         24	  children: ReactNode;
         25	}
         26	
         27	export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
         28	  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
         29	  const [user, setUser] = useState<any>(null);
         30	  const [loading, setLoading] = useState<boolean>(true);
         31	  const navigate = useNavigate();
         32	
         33	  useEffect(() => {
         34	    // Check if user is logged in
         35	    const checkAuth = async () => {
         36	      const token = localStorage.getItem('token');
         37	      console.log('[DEBUG-AUTH-FIX] checkAuth running, token exists:', !!token);
         38	      
         39	      if (!token) {
         40	        console.log('[DEBUG-AUTH-FIX] No token found, setting unauthenticated state');
         41	        setIsAuthenticated(false);
         42	        setUser(null);
         43	        setLoading(false);
         44	        return;
         45	      }
         46	      
         47	      try {
         48	        console.log('[DEBUG-AUTH-FIX] Token found, fetching user data');
         49	        console.log('[DEBUG-AUTH-FIX] Token value:', token ? token.substring(0, 15) + '...' : 'null');
         50	        console.log('[DEBUG-AUTH-FIX] Token length:', token ? token.length : 0);
         51	        // Fetch user data
         52	        const response = await authApi.getUser();
         53	        console.log('[DEBUG-AUTH-FIX] User data fetch successful:', response.data ? {
         54	          id: response.data.id,
         55	          email: response.data.email,
         56	          hasAgent: !!response.data.agent
         57	        } : 'No data returned');
         58	        
         59	        setUser(response.data);
         60	        setIsAuthenticated(true);
         61	        console.log('[DEBUG-AUTH-FIX] Authentication successful, user set');
         62	        
         63	        // Check if we should redirect to onboarding
         64	        const shouldRedirectToOnboarding = response.data?.agent && !response.data.agent.onboardingCompleted;
         65	        const isRegistration = localStorage.getItem('just_registered') === 'true';
         66	        
         67	        console.log('[DEBUG-AUTH-FIX] Onboarding check:', {
         68	          shouldRedirect: shouldRedirectToOnboarding,
         69	          isRegistration: isRegistration,
         70	          onboardingCompleted: response.data?.agent?.onboardingCompleted
         71	        });
         72	        
         73	        if (isRegistration && shouldRedirectToOnboarding) {
         74	          console.log('[DEBUG-AUTH-FIX] New registration detected, redirecting to onboarding');
         75	          localStorage.removeItem('just_registered');
         76	          setTimeout(() => {
         77	            window.location.href = '/onboarding';
         78	          }, 100);
         79	        }
         80	      } catch (error) {
         81	        console.error('[DEBUG-AUTH] Auth check failed:', error);
         82	        // Token invalid, clear it
         83	        localStorage.removeItem('token');
         84	        console.log('[DEBUG-AUTH] Token removed due to authentication failure');
         85	        setIsAuthenticated(false);
         86	        setUser(null);
         87	      } finally {
         88	        setLoading(false);
         89	        console.log('[DEBUG-AUTH] Authentication check completed, loading set to false');
         90	      }
         91	    };
         92	    
         93	    checkAuth();
         94	  }, []);
         95	
         96	  const login = (token: string) => {
         97	    console.log('[DEBUG-AUTH-FIX] Login called with token:', token ? token.substring(0, 15) + '...' : 'null');
         98	    console.log('[DEBUG-AUTH-FIX] Token length:', token ? token.length : 0);
         99	    localStorage.setItem('token', token);
        100	    setIsAuthenticated(true);
        101	    // Fetch user data after login
        102	    fetchUser(token);
        103	  };
        104	
        105	  const fetchUser = async (token: string) => {
        106	    try {
        107	      console.log('[DEBUG-AUTH] Fetching user data after login');
        108	      const response = await authApi.getUser();
        109	      console.log('[DEBUG-AUTH] User data fetch successful after login:', response.data ? {
        110	        id: response.data.id,
        111	        email: response.data.email,
        112	        hasAgent: !!response.data.agent,
        113	        agentData: response.data.agent ? {
        114	          id: response.data.agent.id,
        115	          onboardingCompleted: response.data.agent.onboardingCompleted
        116	        } : null
        117	      } : 'No data returned');
        118	      
        119	      setUser(response.data);
        120	    } catch (error) {
        121	      console.error('[DEBUG-AUTH] Failed to fetch user data after login:', error);
        122	    }
        123	  };
        124	
        125	  const logout = () => {
        126	    console.log('[DEBUG-AUTH] Logout called');
        127	    localStorage.removeItem('token');
        128	    setIsAuthenticated(false);
        129	    setUser(null);
        130	    navigate('/login');
        131	  };
        132	
        133	  return (
        134	    <AuthContext.Provider value={{ isAuthenticated, user, loading, login, logout }}>
        135	      {children}
        136	    </AuthContext.Provider>
        137	  );
        138	};
        139	
        140	export default AuthContext;

==============================================
FILE: ./frontend/src/context/DashboardContext.tsx
==============================================

          1	import React, { createContext, useState, useContext, ReactNode, useCallback } from 'react';
          2	
          3	// Define types for tab data
          4	interface IssueType {
          5	  id: string;
          6	  title: string;
          7	  description: string;
          8	  stance?: string | null;
          9	  reason?: string;
         10	  isPriority?: boolean;
         11	}
         12	
         13	interface RecentActionType {
         14	  id: string;
         15	  type: 'vote' | 'comment';
         16	  proposalTitle: string;
         17	  proposalId: string;
         18	  actionDetails: string;
         19	  timestamp: string;
         20	  canVeto: boolean;
         21	  isOverridden: boolean;
         22	}
         23	
         24	interface ProposalType {
         25	  id: string;
         26	  title: string;
         27	  description: string;
         28	  type: string;
         29	  status: string;
         30	  createdAt: string;
         31	}
         32	
         33	// Define the type for the current tab data
         34	interface CurrentTabDataType {
         35	  positions?: {
         36	    issues: IssueType[];
         37	    selectedIssue?: IssueType | null;
         38	  };
         39	  activity?: {
         40	    recentActions: RecentActionType[];
         41	    selectedAction?: RecentActionType | null;
         42	  };
         43	  proposals?: {
         44	    proposals: ProposalType[];
         45	    selectedProposal?: ProposalType | null;
         46	  };
         47	}
         48	
         49	interface DashboardContextType {
         50	  currentTab: string;
         51	  setCurrentTab: (tab: string) => void;
         52	  issues: any[];
         53	  setIssues: (issues: any[]) => void;
         54	  isLoading: boolean;
         55	  setIsLoading: (loading: boolean) => void;
         56	  error: string | null;
         57	  setError: (error: string | null) => void;
         58	  refreshData: () => Promise<void>;
         59	  
         60	  // New fields for enhanced context sharing
         61	  currentTabData: CurrentTabDataType;
         62	  setCurrentTabData: (data: CurrentTabDataType) => void;
         63	  updateCurrentTabData: (data: Partial<CurrentTabDataType>) => void;
         64	  selectIssue: (issueId: string | null) => void;
         65	  selectAction: (actionId: string | null) => void;
         66	  selectProposal: (proposalId: string | null) => void;
         67	}
         68	
         69	const DashboardContext = createContext<DashboardContextType | undefined>(undefined);
         70	
         71	export const DashboardProvider: React.FC<{children: ReactNode}> = ({ children }) => {
         72	  const [currentTab, setCurrentTab] = useState('positions');
         73	  const [issues, setIssues] = useState<any[]>([]);
         74	  const [isLoading, setIsLoading] = useState(false);
         75	  const [error, setError] = useState<string | null>(null);
         76	  
         77	  // Initialize the currentTabData state
         78	  const [currentTabData, setCurrentTabData] = useState<CurrentTabDataType>({
         79	    positions: { issues: [] },
         80	    activity: { recentActions: [] },
         81	    proposals: { proposals: [] }
         82	  });
         83	
         84	  // Function to update partial tab data
         85	  const updateCurrentTabData = useCallback((data: Partial<CurrentTabDataType>) => {
         86	    setCurrentTabData(prev => ({
         87	      ...prev,
         88	      ...data
         89	    }));
         90	  }, []);
         91	
         92	  // Function to select a specific issue
         93	  const selectIssue = useCallback((issueId: string | null) => {
         94	    if (!issueId) {
         95	      setCurrentTabData(prev => ({
         96	        ...prev,
         97	        positions: {
         98	          ...prev.positions,
         99	          selectedIssue: null
        100	        }
        101	      }));
        102	      return;
        103	    }
        104	    
        105	    setCurrentTabData(prev => {
        106	      const issues = prev.positions?.issues || [];
        107	      const selectedIssue = issues.find(issue => issue.id === issueId) || null;
        108	      
        109	      return {
        110	        ...prev,
        111	        positions: {
        112	          ...prev.positions,
        113	          selectedIssue
        114	        }
        115	      };
        116	    });
        117	  }, []);
        118	
        119	  // Function to select a specific action
        120	  const selectAction = useCallback((actionId: string | null) => {
        121	    if (!actionId) {
        122	      setCurrentTabData(prev => ({
        123	        ...prev,
        124	        activity: {
        125	          ...prev.activity,
        126	          selectedAction: null
        127	        }
        128	      }));
        129	      return;
        130	    }
        131	    
        132	    setCurrentTabData(prev => {
        133	      const recentActions = prev.activity?.recentActions || [];
        134	      const selectedAction = recentActions.find(action => action.id === actionId) || null;
        135	      
        136	      return {
        137	        ...prev,
        138	        activity: {
        139	          ...prev.activity,
        140	          selectedAction
        141	        }
        142	      };
        143	    });
        144	  }, []);
        145	
        146	  // Function to select a specific proposal
        147	  const selectProposal = useCallback((proposalId: string | null) => {
        148	    if (!proposalId) {
        149	      setCurrentTabData(prev => ({
        150	        ...prev,
        151	        proposals: {
        152	          ...prev.proposals,
        153	          selectedProposal: null
        154	        }
        155	      }));
        156	      return;
        157	    }
        158	    
        159	    setCurrentTabData(prev => {
        160	      const proposals = prev.proposals?.proposals || [];
        161	      const selectedProposal = proposals.find(proposal => proposal.id === proposalId) || null;
        162	      
        163	      return {
        164	        ...prev,
        165	        proposals: {
        166	          ...prev.proposals,
        167	          selectedProposal
        168	        }
        169	      };
        170	    });
        171	  }, []);
        172	
        173	  // Fetch issues from API
        174	  const refreshData = useCallback(async () => {
        175	    setIsLoading(true);
        176	    setError(null);
        177	    try {
        178	      // First, try to get agent data to check if onboarding is complete
        179	      const agentResponse = await fetch('/api/agents/me', {
        180	        headers: {
        181	          'Authorization': `Bearer ${localStorage.getItem('token')}`
        182	        }
        183	      });
        184	      
        185	      if (!agentResponse.ok) {
        186	        throw new Error('Failed to fetch agent data');
        187	      }
        188	      
        189	      const agentData = await agentResponse.json();
        190	      console.log('[DEBUG_DASHBOARD_CONTEXT] Agent data:', agentData);
        191	      
        192	      // Then get the issues data
        193	      const response = await fetch('/api/issues/user', {
        194	        headers: {
        195	          'Authorization': `Bearer ${localStorage.getItem('token')}`
        196	        }
        197	      });
        198	      
        199	      if (!response.ok) throw new Error('Failed to fetch issues');
        200	      
        201	      const data = await response.json();
        202	      console.log('[DEBUG_DASHBOARD_CONTEXT] Issues data:', data);
        203	      
        204	      // Determine which issues data to use
        205	      const issuesData = Array.isArray(data) && data.length > 0
        206	        ? data
        207	        : (agentData?.preferences?.issuesMatrix &&
        208	           Array.isArray(agentData.preferences.issuesMatrix) &&
        209	           agentData.preferences.issuesMatrix.length > 0)
        210	          ? agentData.preferences.issuesMatrix
        211	          : [];
        212	      
        213	      // Update the regular issues state
        214	      setIssues(issuesData);
        215	      
        216	      // Mock data for recent actions (in a real implementation, this would come from an API)
        217	      const recentActions = [
        218	        { id: 'v1', type: 'vote', proposalTitle: 'Increase Budget', proposalId: 'p1', actionDetails: 'Voted YES (Confidence: 90%)', timestamp: new Date(Date.now() - 3600000).toISOString(), canVeto: true, isOverridden: false },
        219	        { id: 'c1', type: 'comment', proposalTitle: 'New Policy', proposalId: 'p2', actionDetails: 'Commented: "Looks good."', timestamp: new Date(Date.now() - 7200000).toISOString(), canVeto: false, isOverridden: false },
        220	        { id: 'v2', type: 'vote', proposalTitle: 'Old Proposal', proposalId: 'p3', actionDetails: 'Voted NO (Confidence: 75%)', timestamp: new Date(Date.now() - 86400000).toISOString(), canVeto: false, isOverridden: true },
        221	      ];
        222	      
        223	      // Mock data for proposals (in a real implementation, this would come from an API)
        224	      const proposals = [
        225	        { id: 'p1', title: 'Increase Budget', description: 'A proposal to increase the operational budget by 10%.', type: 'monetary', status: 'open', createdAt: new Date(Date.now() - 86400000).toISOString() },
        226	        { id: 'p2', title: 'New Policy', description: 'Implementing a new policy for remote work.', type: 'standard', status: 'open', createdAt: new Date(Date.now() - 172800000).toISOString() },
        227	        { id: 'p3', title: 'Old Proposal', description: 'A previously discussed proposal that was voted down.', type: 'standard', status: 'closed', createdAt: new Date(Date.now() - 259200000).toISOString() },
        228	      ];
        229	      
        230	      // Update the currentTabData with the fetched and mock data
        231	      setCurrentTabData({
        232	        positions: {
        233	          issues: issuesData,
        234	          selectedIssue: null
        235	        },
        236	        activity: {
        237	          recentActions,
        238	          selectedAction: null
        239	        },
        240	        proposals: {
        241	          proposals,
        242	          selectedProposal: null
        243	        }
        244	      });
        245	      
        246	      if (Array.isArray(data) && data.length > 0) {
        247	        console.log('[DEBUG_DASHBOARD_CONTEXT] Using issues data from API');
        248	      } else if (agentData?.preferences?.issuesMatrix &&
        249	                 Array.isArray(agentData.preferences.issuesMatrix) &&
        250	                 agentData.preferences.issuesMatrix.length > 0) {
        251	        // Fallback to preferences.issuesMatrix if the issues API didn't return data
        252	        console.log('[DEBUG_DASHBOARD_CONTEXT] Using issuesMatrix from agent preferences');
        253	      } else {
        254	        console.log('[DEBUG_DASHBOARD_CONTEXT] No issues data found');
        255	      }
        256	    } catch (err: any) {
        257	      console.error('[DEBUG_DASHBOARD_CONTEXT] Error loading data:', err);
        258	      setError(err.message || 'Failed to load dashboard data.');
        259	    } finally {
        260	      setIsLoading(false);
        261	    }
        262	  }, []);
        263	
        264	  return (
        265	    <DashboardContext.Provider value={{
        266	      currentTab,
        267	      setCurrentTab,
        268	      issues,
        269	      setIssues,
        270	      isLoading,
        271	      setIsLoading,
        272	      error,
        273	      setError,
        274	      refreshData,
        275	      // Add the new context values
        276	      currentTabData,
        277	      setCurrentTabData,
        278	      updateCurrentTabData,
        279	      selectIssue,
        280	      selectAction,
        281	      selectProposal
        282	    }}>
        283	      {children}
        284	    </DashboardContext.Provider>
        285	  );
        286	};
        287	
        288	export const useDashboard = () => {
        289	  const context = useContext(DashboardContext);
        290	  if (context === undefined) {
        291	    throw new Error('useDashboard must be used within a DashboardProvider');
        292	  }
        293	  return context;
        294	};

==============================================
FILE: ./frontend/src/hooks/useChatContext.tsx
==============================================

          1	import React, { createContext, useContext, useState, ReactNode } from 'react';
          2	
          3	// Define the various context types for different tabs
          4	type PositionsContextType = {
          5	  issues: any[];
          6	};
          7	
          8	type ActivityContextType = {
          9	  recentActions: any[];
         10	};
         11	
         12	type ProposalsContextType = {
         13	  // Proposal-specific context data
         14	};
         15	
         16	// Union type for different tab contexts
         17	type ChatContextType = {
         18	  type: 'positions' | 'activity' | 'proposals' | null;
         19	  data: PositionsContextType | ActivityContextType | ProposalsContextType | null;
         20	};
         21	
         22	// Create the initial context state
         23	const initialContext: ChatContextType = {
         24	  type: null,
         25	  data: null
         26	};
         27	
         28	// Create context
         29	const ChatContext = createContext<{
         30	  chatContext: ChatContextType;
         31	  setChatContext: React.Dispatch<React.SetStateAction<ChatContextType>>;
         32	}>({
         33	  chatContext: initialContext,
         34	  setChatContext: () => {}
         35	});
         36	
         37	// Create provider component
         38	export const ChatContextProvider = ({ children }: { children: ReactNode }) => {
         39	  const [chatContext, setChatContext] = useState<ChatContextType>(initialContext);
         40	
         41	  return (
         42	    <ChatContext.Provider value={{ chatContext, setChatContext }}>
         43	      {children}
         44	    </ChatContext.Provider>
         45	  );
         46	};
         47	
         48	// Custom hook for using the chat context
         49	export const useChatContext = () => {
         50	  const context = useContext(ChatContext);
         51	  if (context === undefined) {
         52	    throw new Error('useChatContext must be used within a ChatContextProvider');
         53	  }
         54	  return context;
         55	};

==============================================
FILE: ./frontend/src/index.css
==============================================

          1	/* Basic CSS Reset */
          2	body {
          3	  margin: 0;
          4	  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
          5	    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
          6	    sans-serif;
          7	  -webkit-font-smoothing: antialiased;
          8	  -moz-osx-font-smoothing: grayscale;
          9	}
         10	
         11	code {
         12	  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
         13	    monospace;
         14	}
         15	
         16	/* Layout and general styles */
         17	:root {
         18	  --primary-color: #4a90e2;
         19	  --secondary-color: #5cb85c;
         20	  --error-color: #d9534f;
         21	  --text-color: #333;
         22	  --border-color: #ddd;
         23	  --background-color: #f9f9f9;
         24	}
         25	
         26	/* Basic layout */
         27	#root {
         28	  max-width: 1200px;
         29	  margin: 0 auto;
         30	  padding: 20px;
         31	}
         32	
         33	nav ul {
         34	  display: flex;
         35	  list-style: none;
         36	  padding: 0;
         37	  margin: 0;
         38	  gap: 20px;
         39	}
         40	
         41	nav ul li a {
         42	  text-decoration: none;
         43	  color: var(--primary-color);
         44	  font-weight: 500;
         45	}
         46	
         47	nav ul li a:hover {
         48	  text-decoration: underline;
         49	}
         50	
         51	footer {
         52	  margin-top: 40px;
         53	  border-top: 1px solid var(--border-color);
         54	  padding-top: 20px;
         55	  text-align: center;
         56	}
         57	
         58	/* Auth Forms */
         59	.login-container,
         60	.register-container {
         61	  max-width: 400px;
         62	  margin: 40px auto;
         63	  padding: 20px;
         64	  border-radius: 8px;
         65	  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
         66	  background-color: white;
         67	}
         68	
         69	.login-container h1,
         70	.register-container h1 {
         71	  margin-top: 0;
         72	  color: var(--primary-color);
         73	  text-align: center;
         74	}
         75	
         76	.form-group {
         77	  margin-bottom: 20px;
         78	}
         79	
         80	.form-group label {
         81	  display: block;
         82	  margin-bottom: 8px;
         83	  font-weight: 500;
         84	}
         85	
         86	.form-group input {
         87	  width: 100%;
         88	  padding: 10px;
         89	  border: 1px solid var(--border-color);
         90	  border-radius: 4px;
         91	  font-size: 16px;
         92	}
         93	
         94	button {
         95	  width: 100%;
         96	  padding: 12px;
         97	  background-color: var(--primary-color);
         98	  color: white;
         99	  border: none;
        100	  border-radius: 4px;
        101	  font-size: 16px;
        102	  cursor: pointer;
        103	  transition: background-color 0.2s;
        104	}
        105	
        106	button:hover {
        107	  background-color: #357ab8;
        108	}
        109	
        110	button:disabled {
        111	  background-color: #b3d1f0;
        112	  cursor: not-allowed;
        113	}
        114	
        115	.error-message {
        116	  background-color: #f8d7da;
        117	  color: var(--error-color);
        118	  padding: 10px;
        119	  border-radius: 4px;
        120	  margin-bottom: 20px;
        121	  text-align: center;
        122	}
        123	
        124	.login-link,
        125	.register-link {
        126	  text-align: center;
        127	  margin-top: 20px;
        128	}
        129	
        130	.login-link a,
        131	.register-link a {
        132	  color: var(--primary-color);
        133	  text-decoration: none;
        134	}
        135	
        136	.login-link a:hover,
        137	.register-link a:hover {
        138	  text-decoration: underline;
        139	}
        140	
        141	/* Onboarding Wizard */
        142	.onboarding-container {
        143	  max-width: 600px;
        144	  margin: 40px auto;
        145	  padding: 30px;
        146	  border-radius: 8px;
        147	  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        148	  background-color: white;
        149	}
        150	
        151	.onboarding-container h2 {
        152	  color: var(--primary-color);
        153	  margin-top: 0;
        154	  text-align: center;
        155	  margin-bottom: 20px;
        156	}
        157	
        158	.onboarding-container h3 {
        159	  margin-top: 0;
        160	  color: var(--text-color);
        161	  border-bottom: 1px solid var(--border-color);
        162	  padding-bottom: 10px;
        163	  margin-bottom: 20px;
        164	}
        165	
        166	.preference-group {
        167	  margin-bottom: 20px;
        168	}
        169	
        170	.preference-group label {
        171	  display: block;
        172	  margin-bottom: 8px;
        173	  font-weight: 500;
        174	}
        175	
        176	.preference-group select {
        177	  width: 100%;
        178	  padding: 10px;
        179	  border: 1px solid var(--border-color);
        180	  border-radius: 4px;
        181	  font-size: 16px;
        182	  background-color: white;
        183	}
        184	
        185	.onboarding-container button {
        186	  margin-top: 10px;
        187	  display: inline-block;
        188	  width: 48%;
        189	}
        190	
        191	.onboarding-container button:first-of-type {
        192	  margin-right: 4%;
        193	}
        194	
        195	.onboarding-container hr {
        196	  margin: 30px 0 20px;
        197	  border: none;
        198	  border-top: 1px solid var(--border-color);
        199	}
        200	
        201	.onboarding-container input[type="color"] {
        202	  height: 40px;
        203	  width: 100px;
        204	}
        205	
        206	.onboarding-container input[type="text"],
        207	.onboarding-container input[type="number"] {
        208	  width: 100%;
        209	  padding: 10px;
        210	  border: 1px solid var(--border-color);
        211	  border-radius: 4px;
        212	  font-size: 16px;
        213	  margin-bottom: 15px;
        214	}

==============================================
FILE: ./frontend/src/main.tsx
==============================================

          1	import React from 'react'
          2	import ReactDOM from 'react-dom/client'
          3	import App from './App'
          4	import './index.css' // We'll create this next
          5	import { ChatContextProvider } from './hooks/useChatContext'
          6	import { DashboardProvider } from './context/DashboardContext'
          7	
          8	ReactDOM.createRoot(document.getElementById('root')!).render(
          9	  <React.StrictMode>
         10	    <DashboardProvider>
         11	      <ChatContextProvider>
         12	        <App />
         13	      </ChatContextProvider>
         14	    </DashboardProvider>
         15	  </React.StrictMode>,
         16	)

==============================================
FILE: ./frontend/src/pages/DashboardPage.tsx
==============================================

          1	import React, { useState, useEffect } from 'react';
          2	import apiClient, { agents } from '../api/apiClient';
          3	import AgentChatPanel from '../components/AgentChatPanel';
          4	
          5	import { useNavigate } from 'react-router-dom';
          6	
          7	// Tab content components
          8	import PositionsMatrixTab from '../components/dashboard/PositionsMatrixTab';
          9	import ActivityAuditTab from '../components/dashboard/ActivityAuditTab';
         10	import ProposalsTab from '../components/dashboard/ProposalsTab';
         11	
         12	// Custom hooks
         13	import { useChatContext } from '../hooks/useChatContext';
         14	import { useDashboard } from '../context/DashboardContext';
         15	// Placeholder types - replace with actual types from Prisma schema if shared
         16	interface AgentData {
         17	    id: string;
         18	    name: string;
         19	    color: string;
         20	    alignmentScore: number;
         21	    pausedUntil: string | null;
         22	    userName?: string; // Added for personalized dashboard welcome
         23	    // Add other relevant fields
         24	}
         25	
         26	interface RecentAction {
         27	    id: string;
         28	    type: 'vote' | 'comment'; // Example types
         29	    proposalTitle: string;
         30	    proposalId: string;
         31	    actionDetails: string; // e.g., "Voted YES", "Commented: ..."
         32	    timestamp: string;
         33	    canVeto: boolean; // Whether the veto window is still open
         34	    isOverridden: boolean;
         35	}
         36	
         37	// Define the available tabs
         38	type TabType = 'positions' | 'activity' | 'proposals';
         39	
         40	const DashboardPage: React.FC = () => {
         41	    // Dashboard state
         42	    const navigate = useNavigate();
         43	    const [agentData, setAgentData] = useState<AgentData | null>(null);
         44	    const [recentActions, setRecentActions] = useState<RecentAction[]>([]);
         45	    const [isPausing, setIsPausing] = useState(false);
         46	    const [isVetoingAction, setIsVetoingAction] = useState(false);
         47	    const [vetoingActionId, setVetoingActionId] = useState<string | null>(null);
         48	    const [vetoFeedbackMessage, setVetoFeedbackMessage] = useState<{message: string, isError: boolean} | null>(null);
         49	
         50	    // Dashboard context
         51	    const {
         52	      currentTab,
         53	      setCurrentTab,
         54	      issues,
         55	      isLoading,
         56	      error,
         57	      refreshData,
         58	      currentTabData  // Add the currentTabData
         59	    } = useDashboard();
         60	
         61	    // Chat panel state
         62	    const [isChatMinimized, setIsChatMinimized] = useState(true);
         63	
         64	    // Chat context for sharing context between tabs and chat panel
         65	    const { setChatContext } = useChatContext();
         66	
         67	    // Fetch agent data and recent actions on mount
         68	    useEffect(() => {
         69	        // Fetch agent data
         70	        const fetchAgent = async () => {
         71	            try {
         72	                const response = await fetch('/api/agents/me', {
         73	                    headers: {
         74	                        'Authorization': `Bearer ${localStorage.getItem('token')}`
         75	                    }
         76	                });
         77	                if (response.ok) {
         78	                    const data = await response.json();
         79	                    console.log("[DEBUG_NAMES] Dashboard received agent data:", {
         80	                        id: data.id,
         81	                        name: data.name,           // Original name field
         82	                        agentName: data.agentName, // Explicit agent name (new field)
         83	                        userName: data.userName,   // User's name
         84	                        color: data.color,
         85	                    });
         86	                    
         87	                    // Add debugging to understand name data
         88	                    console.log('[DEBUG_DASHBOARD] Received data from /api/agents/me:', {
         89	                        id: data.id,
         90	                        name: data.name,
         91	                        agentName: data.agentName,
         92	                        userName: data.userName,
         93	                        color: data.color
         94	                    });
         95	                    
         96	                    setAgentData({
         97	                        id: data.id || 'agent-123',
         98	                        // Use explicit agent name field for agent's name
         99	                        name: data.agentName || data.name || 'Test Agent',
        100	                        color: data.color || '#ff0000',
        101	                        alignmentScore: data.alignmentScore || 0.85,
        102	                        pausedUntil: data.pausedUntil || null,
        103	                        // Store the real user name (NOT agent name)
        104	                        userName: data.userName || 'User'
        105	                    });
        106	                } else {
        107	                    setAgentData({
        108	                        id: 'agent-123', name: 'Test Agent', color: '#ff0000', alignmentScore: 0.85, pausedUntil: null, userName: 'User'
        109	                    });
        110	                }
        111	            } catch (err) {
        112	                setAgentData({
        113	                    id: 'agent-123', name: 'Test Agent', color: '#ff0000', alignmentScore: 0.85, pausedUntil: null, userName: 'User'
        114	                });
        115	            }
        116	        };
        117	        fetchAgent();
        118	        refreshData();
        119	        // TODO: Fetch recent actions from API
        120	        setRecentActions([
        121	            { id: 'v1', type: 'vote', proposalTitle: 'Increase Budget', proposalId: 'p1', actionDetails: 'Voted YES (Confidence: 90%)', timestamp: new Date(Date.now() - 3600000).toISOString(), canVeto: true, isOverridden: false },
        122	            { id: 'c1', type: 'comment', proposalTitle: 'New Policy', proposalId: 'p2', actionDetails: 'Commented: "Looks good."', timestamp: new Date(Date.now() - 7200000).toISOString(), canVeto: false, isOverridden: false },
        123	            { id: 'v2', type: 'vote', proposalTitle: 'Old Proposal', proposalId: 'p3', actionDetails: 'Voted NO (Confidence: 75%)', timestamp: new Date(Date.now() - 86400000).toISOString(), canVeto: false, isOverridden: true },
        124	        ]);
        125	    }, [refreshData]);
        126	    const handlePauseAgent = async () => {
        127	        if (!agentData) return;
        128	        setIsPausing(true);
        129	        // setError(null); // No longer needed, handled by context
        130	        try {
        131	            // Calculate pause duration (e.g., 24 hours from now)
        132	            const pauseUntil = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();
        133	
        134	            console.log(`Pausing agent ${agentData.id} until ${pauseUntil}`);
        135	            
        136	            // Simulate API delay
        137	            await new Promise(resolve => setTimeout(resolve, 500));
        138	
        139	            // Update local state to reflect pause
        140	            setAgentData(prev => prev ? { ...prev, pausedUntil: pauseUntil } : null);
        141	
        142	        } catch (err: any) {
        143	            // setError(err.message || 'An error occurred while pausing the agent.'); // Use context error if needed
        144	            console.error("Pause agent error:", err);
        145	        } finally {
        146	            setIsPausing(false);
        147	        }
        148	    };
        149	
        150	    const handleVeto = async (actionId: string, actionType: 'vote' | 'comment') => {
        151	        // Clear any previous veto feedback messages
        152	        setVetoFeedbackMessage(null);
        153	        
        154	        const reason = prompt('Please provide a reason for the veto/undo:');
        155	        if (!reason) {
        156	            setVetoFeedbackMessage({
        157	                message: 'Veto reason is required.',
        158	                isError: true
        159	            });
        160	            return;
        161	        }
        162	        
        163	        if (!agentData) {
        164	            setVetoFeedbackMessage({
        165	                message: 'Agent data not loaded.',
        166	                isError: true
        167	            });
        168	            return;
        169	        }
        170	        
        171	        // Set loading state
        172	        setIsVetoingAction(true);
        173	        setVetoingActionId(actionId);
        174	        
        175	        try {
        176	            console.log(`Attempting to veto ${actionType} with ID ${actionId} for agent ${agentData.id}`);
        177	            
        178	            // Set timeout to prevent hanging requests
        179	            const timeoutPromise = new Promise((_, reject) =>
        180	                setTimeout(() => reject(new Error('Request timed out after 15 seconds')), 15000)
        181	            );
        182	            
        183	            if (actionType === 'vote') {
        184	                // Use the already imported apiClient
        185	                const votePromise = agents.feedback(agentData.id, {
        186	                    voteId: actionId,
        187	                    reason,
        188	                });
        189	                
        190	                // Race between the actual request and the timeout
        191	                await Promise.race([votePromise, timeoutPromise]);
        192	                
        193	            } else if (actionType === 'comment') {
        194	                // Feedback on comments not implemented yet
        195	                throw new Error('Veto on comments is not implemented yet.');
        196	            }
        197	            
        198	            // Success - update UI without page reload
        199	            setVetoFeedbackMessage({
        200	                message: 'Veto/Undo submitted successfully.',
        201	                isError: false
        202	            });
        203	            
        204	            // Update local state to reflect the veto
        205	            setRecentActions(prevActions =>
        206	                prevActions.map(action =>
        207	                    action.id === actionId
        208	                        ? { ...action, isOverridden: true, canVeto: false }
        209	                        : action
        210	                )
        211	            );
        212	            
        213	        } catch (error) {
        214	            console.error('Veto error details:', error);
        215	            setVetoFeedbackMessage({
        216	                message: `Failed to submit veto/undo: ${error instanceof Error ? error.message : 'Unknown error'}`,
        217	                isError: true
        218	            });
        219	        } finally {
        220	            setIsVetoingAction(false);
        221	            setVetoingActionId(null);
        222	            
        223	            // Refresh data in the background after a short delay
        224	            setTimeout(() => {
        225	                refreshData();
        226	            }, 2000);
        227	        }
        228	    };
        229	
        230	    if (isLoading) return <div>Loading Dashboard...</div>;
        231	    if (error) return <div style={{ color: 'red' }}>Error: {error}</div>;
        232	    if (!agentData) return <div>Agent data not found.</div>;
        233	    
        234	    const isPaused = agentData.pausedUntil && new Date(agentData.pausedUntil) > new Date();
        235	    const alignmentPercentage = (agentData.alignmentScore * 100).toFixed(1);
        236	    
        237	    // Create personalized welcome message with user's name
        238	    // userName should contain the human user's name (e.g., "Adam")
        239	    const userFirstName = (agentData.userName || '').split(' ')[0];
        240	    console.log("[DEBUG_NAMES] Creating welcome message with:", {
        241	        agentData_name: agentData.name,       // Should be agent's name (e.g., "Prax")
        242	        agentData_userName: agentData.userName, // Should be user's name (e.g., "Adam")
        243	        userFirstName: userFirstName
        244	    });
        245	    
        246	    // Use the actual user's name for the welcome message, not the agent name
        247	    const welcomeMessage = `Hi ${userFirstName || 'User'},`;
        248	    
        249	    // Handle tab switching with context awareness for chat panel
        250	    const handleTabChange = (tab: TabType) => {
        251	      setCurrentTab(tab);
        252	      
        253	      // Update chat context based on active tab with more structured data
        254	      switch (tab) {
        255	        case 'positions':
        256	          setChatContext({
        257	            type: 'positions',
        258	            data: {
        259	              issues: currentTabData.positions?.issues || issues,
        260	              selectedIssue: currentTabData.positions?.selectedIssue
        261	            }
        262	          });
        263	          break;
        264	        case 'activity':
        265	          setChatContext({
        266	            type: 'activity',
        267	            data: {
        268	              recentActions: currentTabData.activity?.recentActions || recentActions,
        269	              selectedAction: currentTabData.activity?.selectedAction
        270	            }
        271	          });
        272	          break;
        273	        case 'proposals':
        274	          setChatContext({
        275	            type: 'proposals',
        276	            data: {
        277	              proposals: currentTabData.proposals?.proposals || [],
        278	              selectedProposal: currentTabData.proposals?.selectedProposal
        279	            }
        280	          });
        281	          break;
        282	      }
        283	      
        284	      // Log for debugging purposes
        285	      console.log(`[Dashboard] Switched to tab: ${tab}, updated chat context`);
        286	    };
        287	
        288	    return (
        289	        <div className="dashboard-container">
        290	            {/* Tab Navigation */}
        291	            <div className="dashboard-tabs">
        292	                <button
        293	                    className={`tab-button ${currentTab === 'positions' ? 'active' : ''}`}
        294	                    onClick={() => handleTabChange('positions')}
        295	                    aria-label="Positions Matrix Tab"
        296	                >
        297	                    Positions Matrix
        298	                </button>
        299	                <button
        300	                    className={`tab-button ${currentTab === 'activity' ? 'active' : ''}`}
        301	                    onClick={() => handleTabChange('activity')}
        302	                    aria-label="Activity Audit Tab"
        303	                >
        304	                    Activity Audit
        305	                </button>
        306	                <button
        307	                    className={`tab-button ${currentTab === 'proposals' ? 'active' : ''}`}
        308	                    onClick={() => handleTabChange('proposals')}
        309	                    aria-label="Proposals Tab"
        310	                >
        311	                    Proposals
        312	                </button>
        313	            </div>
        314	            
        315	            {/* Tab Content Area */}
        316	            <div className="dashboard-content">
        317	                {currentTab === 'positions' && (
        318	                    <PositionsMatrixTab
        319	                        welcomeMessage={welcomeMessage}
        320	                        agentColor={agentData.color}
        321	                        onChatMaximize={() => setIsChatMinimized(false)}
        322	                    />
        323	                )}
        324	                
        325	                {currentTab === 'activity' && (
        326	                    <ActivityAuditTab
        327	                        recentActions={recentActions}
        328	                        welcomeMessage={welcomeMessage}
        329	                        agentColor={agentData.color}
        330	                        handleVeto={handleVeto}
        331	                        isVetoingAction={isVetoingAction}
        332	                        vetoingActionId={vetoingActionId}
        333	                        vetoFeedbackMessage={vetoFeedbackMessage}
        334	                        onChatMaximize={() => setIsChatMinimized(false)}
        335	                    />
        336	                )}
        337	                
        338	                {currentTab === 'proposals' && (
        339	                    <ProposalsTab
        340	                        welcomeMessage={welcomeMessage}
        341	                        agentColor={agentData.color}
        342	                        onChatMaximize={() => setIsChatMinimized(false)}
        343	                    />
        344	                )}
        345	            </div>
        346	            
        347	            {/* Agent Status Panel (Always Visible) */}
        348	            <div className="agent-status-panel">
        349	                <div className="agent-status-header" style={{ borderColor: agentData.color }}>
        350	                    <div>
        351	                        <span className="status-dot" style={{ 
        352	                            backgroundColor: isPaused ? '#718096' : agentData.color 
        353	                        }}></span>
        354	                        <span>{isPaused ? 'Paused' : 'Active'}</span>
        355	                    </div>
        356	                    <div>
        357	                        <span>Alignment: {alignmentPercentage}%</span>
        358	                    </div>
        359	                </div>
        360	                <button
        361	                    className="pause-button"
        362	                    onClick={handlePauseAgent}
        363	                    disabled={isPausing || !!isPaused}
        364	                    aria-label="Pause Agent for 24 hours"
        365	                >
        366	                    {isPausing ? 'Pausing...' : 'Pause Agent (24h)'}
        367	                </button>
        368	            </div>
        369	
        370	            {/* Agent Chat Panel - Persistent Across Tabs */}
        371	            {agentData && (
        372	                <AgentChatPanel
        373	                    agentId={agentData.id}
        374	                    minimized={isChatMinimized}
        375	                    onMinimize={() => setIsChatMinimized(true)}
        376	                    onMaximize={() => setIsChatMinimized(false)}
        377	                    contextualHelp={currentTab as "positions" | "activity" | "proposals"}
        378	                    userName={agentData.userName}
        379	                />
        380	            )}
        381	            
        382	            {/* Add Dashboard CSS (using regular style tag) */}
        383	            <style>{`
        384	                .dashboard-container {
        385	                    padding: 1rem;
        386	                    max-width: 1200px;
        387	                    margin: 0 auto;
        388	                }
        389	                
        390	                .dashboard-tabs {
        391	                    display: flex;
        392	                    border-bottom: 1px solid #e2e8f0;
        393	                    margin-bottom: 1.5rem;
        394	                    overflow-x: auto; /* Enable horizontal scroll on small screens */
        395	                    scrollbar-width: thin;
        396	                    -ms-overflow-style: none; /* IE and Edge */
        397	                }
        398	                
        399	                .dashboard-tabs::-webkit-scrollbar {
        400	                    height: 4px;
        401	                }
        402	                
        403	                .dashboard-tabs::-webkit-scrollbar-thumb {
        404	                    background-color: rgba(0, 0, 0, 0.2);
        405	                    border-radius: 4px;
        406	                }
        407	                
        408	                .tab-button {
        409	                    padding: 0.75rem 1.5rem;
        410	                    background: none;
        411	                    border: none;
        412	                    font-size: 1rem;
        413	                    font-weight: 500;
        414	                    color: #4a5568;
        415	                    cursor: pointer;
        416	                    position: relative;
        417	                }
        418	                
        419	                .tab-button:hover {
        420	                    color: #3182ce;
        421	                }
        422	                
        423	                .tab-button.active {
        424	                    color: #3182ce;
        425	                    font-weight: 600;
        426	                }
        427	                
        428	                .tab-button.active::after {
        429	                    content: '';
        430	                    position: absolute;
        431	                    bottom: -1px;
        432	                    left: 0;
        433	                    right: 0;
        434	                    height: 2px;
        435	                    background-color: #3182ce;
        436	                }
        437	                
        438	                .dashboard-content {
        439	                    min-height: 400px;
        440	                    padding-bottom: 80px; /* Make room for the status panel */
        441	                }
        442	                
        443	                .agent-status-panel {
        444	                    position: fixed;
        445	                    bottom: 0;
        446	                    left: 0;
        447	                    width: 100%;
        448	                    background-color: white;
        449	                    border-top: 1px solid #e2e8f0;
        450	                    padding: 0.75rem 1rem;
        451	                    display: flex;
        452	                    justify-content: space-between;
        453	                    align-items: center;
        454	                    z-index: 10;
        455	                    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
        456	                }
        457	                
        458	                .agent-status-header {
        459	                    display: flex;
        460	                    align-items: center;
        461	                    gap: 1.5rem;
        462	                    padding-left: 0.5rem;
        463	                    border-left: 3px solid;
        464	                }
        465	                
        466	                .status-dot {
        467	                    display: inline-block;
        468	                    width: 8px;
        469	                    height: 8px;
        470	                    border-radius: 50%;
        471	                    margin-right: 8px;
        472	                }
        473	                
        474	                .pause-button {
        475	                    padding: 0.5rem 1rem;
        476	                    border-radius: 4px;
        477	                    background-color: #e53e3e;
        478	                    color: white;
        479	                    border: none;
        480	                    cursor: pointer;
        481	                    font-weight: 500;
        482	                }
        483	                
        484	                .pause-button:hover {
        485	                    background-color: #c53030;
        486	                }
        487	                
        488	                .pause-button:disabled {
        489	                    background-color: #cbd5e0;
        490	                    cursor: not-allowed;
        491	                }
        492	                
        493	                @media (max-width: 640px) {
        494	                    .dashboard-tabs {
        495	                        overflow-x: auto;
        496	                        white-space: nowrap;
        497	                    }
        498	                    
        499	                    .tab-button {
        500	                        padding: 0.75rem 1rem;
        501	                        font-size: 0.9rem;
        502	                    }
        503	                    
        504	                    .agent-status-panel {
        505	                        flex-direction: column;
        506	                        gap: 0.5rem;
        507	                        padding: 1rem;
        508	                    }
        509	                    
        510	                    .agent-status-header {
        511	                        width: 100%;
        512	                        justify-content: space-between;
        513	                        margin-bottom: 0.5rem;
        514	                    }
        515	                    
        516	                    .pause-button {
        517	                        width: 100%;
        518	                        padding: 0.75rem;
        519	                    }
        520	                    
        521	                    .dashboard-content {
        522	                        padding-bottom: 140px; /* Increase padding for mobile status panel */
        523	                    }
        524	                    
        525	                    .dashboard-container {
        526	                        padding: 0.5rem;
        527	                    }
        528	                }
        529	                
        530	                /* Tablet responsiveness */
        531	                @media (min-width: 641px) and (max-width: 1024px) {
        532	                    .dashboard-content {
        533	                        padding-bottom: 100px;
        534	                    }
        535	                    
        536	                    .agent-status-panel {
        537	                        padding: 0.75rem 2rem;
        538	                    }
        539	                }
        540	                
        541	                /* Add a smooth transition effect for panel layouts */
        542	                .agent-chat-panel, .dashboard-content {
        543	                    transition: all 0.3s ease;
        544	                }
        545	            `}</style>
        546	        </div>
        547	    );
        548	};
        549	
        550	export default DashboardPage;

==============================================
FILE: ./frontend/src/pages/LoginPage.tsx
==============================================

          1	import React, { useState } from 'react';
          2	import { useNavigate, Link } from 'react-router-dom';
          3	import { useAuth } from '../context/AuthContext';
          4	import { auth } from '../api/apiClient';
          5	
          6	const LoginPage: React.FC = () => {
          7	  const [formData, setFormData] = useState({
          8	    email: '',
          9	    password: '',
         10	  });
         11	  const [error, setError] = useState<string | null>(null);
         12	  const [loading, setLoading] = useState(false);
         13	  const navigate = useNavigate();
         14	  const { login } = useAuth();
         15	
         16	  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
         17	    const { name, value } = e.target;
         18	    setFormData(prevState => ({
         19	      ...prevState,
         20	      [name]: value
         21	    }));
         22	  };
         23	
         24	  const handleSubmit = async (e: React.FormEvent) => {
         25	    e.preventDefault();
         26	    setError(null);
         27	    setLoading(true);
         28	
         29	    try {
         30	      const response = await auth.login({
         31	        email: formData.email,
         32	        password: formData.password,
         33	      });
         34	
         35	      // Use the login function from context
         36	      login(response.data.token);
         37	      
         38	      // Navigate to dashboard
         39	      navigate('/dashboard');
         40	    } catch (err: any) {
         41	      console.error('Login error:', err);
         42	      setError(err.message || 'Failed to login. Please check your connection and try again.');
         43	    } finally {
         44	      setLoading(false);
         45	    }
         46	  };
         47	
         48	  return (
         49	    <div className="login-container">
         50	      <h1>Login</h1>
         51	      
         52	      {error && (
         53	        <div className="error-message">
         54	          {error}
         55	        </div>
         56	      )}
         57	      
         58	      <form onSubmit={handleSubmit}>
         59	        <div className="form-group">
         60	          <label htmlFor="email">Email</label>
         61	          <input
         62	            type="email"
         63	            id="email"
         64	            name="email"
         65	            value={formData.email}
         66	            onChange={handleChange}
         67	            required
         68	          />
         69	        </div>
         70	        
         71	        <div className="form-group">
         72	          <label htmlFor="password">Password</label>
         73	          <input
         74	            type="password"
         75	            id="password"
         76	            name="password"
         77	            value={formData.password}
         78	            onChange={handleChange}
         79	            required
         80	          />
         81	        </div>
         82	        
         83	        <button type="submit" disabled={loading}>
         84	          {loading ? 'Logging in...' : 'Login'}
         85	        </button>
         86	      </form>
         87	      
         88	      <div className="register-link">
         89	        <p>Don't have an account? <a href="/register">Register</a></p>
         90	      </div>
         91	    </div>
         92	  );
         93	};
         94	
         95	export default LoginPage;

==============================================
FILE: ./frontend/src/pages/ProposalDetail.css
==============================================

          1	.proposal-detail {
          2	  max-width: 1200px;
          3	  margin: 0 auto;
          4	  padding: 1rem;
          5	}
          6	
          7	.proposal-detail h1 {
          8	  color: #2c3e50;
          9	  margin-bottom: 1.5rem;
         10	  font-size: 2rem;
         11	}
         12	
         13	.proposal-meta {
         14	  display: grid;
         15	  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
         16	  gap: 1rem;
         17	  background-color: #f8f9fa;
         18	  padding: 1.5rem;
         19	  border-radius: 8px;
         20	  margin-bottom: 2rem;
         21	}
         22	
         23	.proposal-meta p {
         24	  margin: 0;
         25	}
         26	
         27	.proposal-description {
         28	  background-color: #fff;
         29	  padding: 1.5rem;
         30	  border: 1px solid #e9ecef;
         31	  border-radius: 8px;
         32	  margin-bottom: 2rem;
         33	  line-height: 1.6;
         34	}
         35	
         36	.proposal-description p {
         37	  margin-bottom: 1rem;
         38	}
         39	
         40	.proposal-description p:last-child {
         41	  margin-bottom: 0;
         42	}
         43	
         44	.negotiation-summary {
         45	  background-color: #e8f4f8;
         46	  padding: 1.5rem;
         47	  border-radius: 8px;
         48	  margin-bottom: 2rem;
         49	  border-left: 4px solid #0078d4;
         50	}
         51	
         52	.summary-content {
         53	  font-style: italic;
         54	  color: #37474f;
         55	}
         56	
         57	.votes-list, .comments-list {
         58	  list-style: none;
         59	  padding: 0;
         60	}
         61	
         62	.votes-list li, .comments-list li {
         63	  padding: 0.75rem;
         64	  background-color: #fff;
         65	  border-bottom: 1px solid #e9ecef;
         66	}
         67	
         68	.votes-list li:nth-child(even), .comments-list li:nth-child(even) {
         69	  background-color: #f8f9fa;
         70	}
         71	
         72	.negotiation-section {
         73	  margin-top: 3rem;
         74	  border-top: 2px solid #e9ecef;
         75	  padding-top: 1.5rem;
         76	}
         77	
         78	.negotiation-section h2 {
         79	  color: #2c3e50;
         80	  margin-bottom: 1.5rem;
         81	}
         82	
         83	.live-negotiation {
         84	  margin-top: 2rem;
         85	}
         86	
         87	.live-negotiation h3 {
         88	  margin-bottom: 1rem;
         89	  color: #37474f;
         90	}
         91	
         92	.negotiation-feedback-container {
         93	  margin-top: 2rem;
         94	}
         95	
         96	/* Responsive adjustments */
         97	@media (max-width: 768px) {
         98	  .proposal-meta {
         99	    grid-template-columns: 1fr;
        100	  }
        101	  
        102	  .proposal-detail h1 {
        103	    font-size: 1.75rem;
        104	  }
        105	}

==============================================
FILE: ./frontend/src/pages/ProposalDetail.tsx
==============================================

          1	import React, { useEffect, useState } from 'react';
          2	import { useParams } from 'react-router-dom';
          3	import './ProposalDetail.css';
          4	import apiClient, { agents } from '../api/apiClient';
          5	import NegotiationThread from '../components/NegotiationThread';
          6	import NegotiationFeedback from '../components/NegotiationFeedback';
          7	import NegotiationHistory from '../components/NegotiationHistory';
          8	
          9	interface Vote {
         10	  id: string;
         11	  value: 'yes' | 'no' | 'abstain';
         12	  createdAt: string;
         13	}
         14	
         15	interface Comment {
         16	  id: string;
         17	  content: string;
         18	  createdAt: string;
         19	  agentName?: string;
         20	}
         21	
         22	interface ProposalDetail {
         23	  id: string;
         24	  title: string;
         25	  description: string;
         26	  type: 'standard' | 'monetary';
         27	  amount?: number;
         28	  status: 'open' | 'closed' | 'withdrawn';
         29	  createdAt: string;
         30	  closeAt: string;
         31	  votes: Vote[];
         32	  comments: Comment[];
         33	  negotiationId?: string;
         34	  isNegotiated: boolean;
         35	  negotiationSummary?: string;
         36	}
         37	
         38	const ProposalDetail: React.FC = () => {
         39	  const { id } = useParams<{ id: string }>();
         40	  const [proposal, setProposal] = useState<ProposalDetail | null>(null);
         41	  const [loading, setLoading] = useState<boolean>(true);
         42	  const [agentId, setAgentId] = useState<string | null>(null);
         43	
         44	  useEffect(() => {
         45	    const fetchProposal = async () => {
         46	      setLoading(true);
         47	      try {
         48	        const response = await apiClient.get<ProposalDetail>(`/api/proposals/${id}`);
         49	        setProposal(response.data);
         50	      } catch (error) {
         51	        console.error('Failed to fetch proposal', error);
         52	      } finally {
         53	        setLoading(false);
         54	      }
         55	    };
         56	    if (id) {
         57	      fetchProposal();
         58	    }
         59	  }, [id]);
         60	
         61	  useEffect(() => {
         62	    const fetchAgent = async () => {
         63	      try {
         64	        const res = await agents.getAgent();
         65	        setAgentId(res.data.id);
         66	      } catch (err) {
         67	        setAgentId(null);
         68	      }
         69	    };
         70	    fetchAgent();
         71	  }, []);
         72	
         73	  if (loading) {
         74	    return <p>Loading proposal...</p>;
         75	  }
         76	
         77	  if (!proposal) {
         78	    return <p>Proposal not found.</p>;
         79	  }
         80	
         81	  return (
         82	    <div className="proposal-detail">
         83	      <h1>{proposal.title}</h1>
         84	      
         85	      <div className="proposal-meta">
         86	        <p><strong>Status:</strong> {proposal.status}</p>
         87	        <p><strong>Type:</strong> {proposal.type}</p>
         88	        {proposal.type === 'monetary' && proposal.amount !== undefined && (
         89	          <p><strong>Amount:</strong> ${proposal.amount.toLocaleString()}</p>
         90	        )}
         91	        <p><strong>Created:</strong> {new Date(proposal.createdAt).toLocaleString()}</p>
         92	        <p><strong>Closes:</strong> {new Date(proposal.closeAt).toLocaleString()}</p>
         93	      </div>
         94	
         95	      <h2>Description</h2>
         96	      <div className="proposal-description">
         97	        {proposal.description.split('\n').map((paragraph, i) => (
         98	          <p key={i}>{paragraph}</p>
         99	        ))}
        100	      </div>
        101	      
        102	      {/* Negotiation Summary (if proposal came from negotiation) */}
        103	      {proposal.isNegotiated && proposal.negotiationSummary && (
        104	        <div className="negotiation-summary">
        105	          <h2>Negotiation Summary</h2>
        106	          <div className="summary-content">
        107	            <p>{proposal.negotiationSummary}</p>
        108	          </div>
        109	        </div>
        110	      )}
        111	
        112	      <h2>Votes</h2>
        113	      <ul className="votes-list">
        114	        {proposal.votes.map((vote) => (
        115	          <li key={vote.id}>
        116	            {vote.value.toUpperCase()} at {new Date(vote.createdAt).toLocaleString()}
        117	          </li>
        118	        ))}
        119	      </ul>
        120	
        121	      <h2>Comments</h2>
        122	      <ul className="comments-list">
        123	        {proposal.comments.map((comment) => (
        124	          <li key={comment.id}>
        125	            {comment.agentName ? `${comment.agentName}: ` : ''}
        126	            {comment.content} ({new Date(comment.createdAt).toLocaleString()})
        127	          </li>
        128	        ))}
        129	      </ul>
        130	
        131	      {/* Negotiation Details Section */}
        132	      {proposal.negotiationId && (
        133	        <div className="negotiation-section">
        134	          <h2>Negotiation Details</h2>
        135	          
        136	          {/* Negotiation History Component */}
        137	          <NegotiationHistory negotiationId={proposal.negotiationId} />
        138	          
        139	          {/* Live Negotiation Thread */}
        140	          {agentId && (
        141	            <div className="live-negotiation">
        142	              <h3>Participate in Negotiation</h3>
        143	              <NegotiationThread negotiationId={proposal.negotiationId} agentId={agentId} />
        144	            </div>
        145	          )}
        146	          
        147	          {/* Feedback Component */}
        148	          {agentId && proposal.isNegotiated && (
        149	            <div className="negotiation-feedback-container">
        150	              <NegotiationFeedback
        151	                negotiationId={proposal.negotiationId}
        152	                agentId={agentId}
        153	              />
        154	            </div>
        155	          )}
        156	        </div>
        157	      )}
        158	    </div>
        159	  );
        160	};
        161	
        162	export default ProposalDetail;

==============================================
FILE: ./frontend/src/pages/ProposalList.tsx
==============================================

          1	import React, { useEffect, useState } from 'react';
          2	import { Link } from 'react-router-dom';
          3	import apiClient from '../api/apiClient';
          4	
          5	interface Proposal {
          6	  id: string;
          7	  title: string;
          8	  status: 'open' | 'closed' | 'withdrawn';
          9	  type: 'standard' | 'monetary';
         10	  createdAt: string;
         11	  closeAt: string;
         12	}
         13	
         14	const ProposalList: React.FC = () => {
         15	  const [proposals, setProposals] = useState<Proposal[]>([]);
         16	  const [filter, setFilter] = useState<'all' | 'open' | 'closed' | 'withdrawn'>('all');
         17	  const [loading, setLoading] = useState<boolean>(true);
         18	
         19	  useEffect(() => {
         20	    const fetchProposals = async () => {
         21	      setLoading(true);
         22	      try {
         23	        const response = await apiClient.get<Proposal[]>('/api/proposals');
         24	        setProposals(response.data);
         25	      } catch (error) {
         26	        console.error('Failed to fetch proposals', error);
         27	      } finally {
         28	        setLoading(false);
         29	      }
         30	    };
         31	    fetchProposals();
         32	  }, []);
         33	
         34	  const filteredProposals = proposals.filter((p) => {
         35	    if (filter === 'all') return true;
         36	    return p.status === filter;
         37	  });
         38	
         39	  return (
         40	    <div>
         41	      <h1>Proposals</h1>
         42	      <div>
         43	        <label>Filter: </label>
         44	        <select value={filter} onChange={(e) => setFilter(e.target.value as any)}>
         45	          <option value="all">All</option>
         46	          <option value="open">Open</option>
         47	          <option value="closed">Closed</option>
         48	          <option value="withdrawn">Withdrawn</option>
         49	        </select>
         50	      </div>
         51	      {loading ? (
         52	        <p>Loading proposals...</p>
         53	      ) : (
         54	        <ul>
         55	          {filteredProposals.map((proposal) => (
         56	            <li key={proposal.id}>
         57	              <Link to={`/proposal/${proposal.id}`}>
         58	                {proposal.title} [{proposal.status}] [{proposal.type}]
         59	              </Link>
         60	              <div>
         61	                Created: {new Date(proposal.createdAt).toLocaleDateString()} | Closes: {new Date(proposal.closeAt).toLocaleDateString()}
         62	              </div>
         63	            </li>
         64	          ))}
         65	        </ul>
         66	      )}
         67	      <Link to="/proposal/new">
         68	        <button>Create New Proposal</button>
         69	      </Link>
         70	    </div>
         71	  );
         72	};
         73	
         74	export default ProposalList;

==============================================
FILE: ./frontend/src/pages/RegisterPage.tsx
==============================================

          1	import React, { useState } from 'react';
          2	import { useNavigate, Link } from 'react-router-dom';
          3	import { useAuth } from '../context/AuthContext';
          4	import { auth } from '../api/apiClient';
          5	
          6	const RegisterPage: React.FC = () => {
          7	  const [formData, setFormData] = useState({
          8	    email: '',
          9	    password: '',
         10	    confirmPassword: '',
         11	  });
         12	  const [error, setError] = useState<string | null>(null);
         13	  const [loading, setLoading] = useState(false);
         14	  const navigate = useNavigate();
         15	  const { login } = useAuth();
         16	
         17	  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
         18	    const { name, value } = e.target;
         19	    setFormData(prevState => ({
         20	      ...prevState,
         21	      [name]: value
         22	    }));
         23	  };
         24	
         25	  const handleSubmit = async (e: React.FormEvent) => {
         26	    e.preventDefault();
         27	    setError(null);
         28	
         29	    // Validate passwords match
         30	    if (formData.password !== formData.confirmPassword) {
         31	      setError('Passwords do not match');
         32	      return;
         33	    }
         34	
         35	    setLoading(true);
         36	
         37	    try {
         38	      const response = await auth.register({
         39	        email: formData.email,
         40	        password: formData.password,
         41	      });
         42	
         43	      // Flag that this is a new registration
         44	      localStorage.setItem('just_registered', 'true');
         45	      
         46	      // Get the token and validate it
         47	      const token = response.data.token;
         48	      if (!token) {
         49	        console.error('[DEBUG-CRITICAL] Registration returned success but no token was received');
         50	        setError('Registration completed but authentication failed. Please try logging in.');
         51	        return;
         52	      }
         53	      
         54	      // Log registration success with token details
         55	      console.log('[DEBUG-CRITICAL] Registration successful, token info:', {
         56	        tokenPrefix: token.substring(0, 15) + '...',
         57	        tokenLength: token.length
         58	      });
         59	      
         60	      // Use the login function from context and handle errors
         61	      try {
         62	        console.log('[DEBUG-CRITICAL] Calling login with token...');
         63	        login(token);
         64	        
         65	        // Add a longer delay to ensure login processing & token validation completes
         66	        console.log('[DEBUG-CRITICAL] Will navigate to onboarding in 1000ms...');
         67	        setTimeout(() => {
         68	          // Double check token is still in localStorage before navigating
         69	          const storedToken = localStorage.getItem('token');
         70	          if (!storedToken) {
         71	            console.error('[DEBUG-CRITICAL] Token missing from localStorage before navigation');
         72	            setError('Authentication issue occurred. Please try logging in manually.');
         73	            return;
         74	          }
         75	          
         76	          console.log('[DEBUG-CRITICAL] Token verified, navigating to /onboarding now');
         77	          // New users should be directed to onboarding
         78	          navigate('/onboarding');
         79	          
         80	          // As a fallback, if navigation fails, force a hard redirect
         81	          setTimeout(() => {
         82	            console.log('[DEBUG-CRITICAL] Fallback navigation check triggered');
         83	            if (window.location.pathname !== '/onboarding') {
         84	              console.log('[DEBUG-CRITICAL] Forcing hard navigation to /onboarding');
         85	              window.location.href = '/onboarding';
         86	            }
         87	          }, 500);
         88	        }, 1000);
         89	      } catch (loginErr) {
         90	        console.error('[DEBUG-CRITICAL] Error during login process:', loginErr);
         91	        setError('Failed to complete authentication. Please try logging in manually.');
         92	      }
         93	    } catch (err: any) {
         94	      console.error('[DEBUG-REG-FIX] Registration error:', err);
         95	      console.error('[DEBUG-REG-FIX] Error details:', JSON.stringify(err));
         96	      setError(err.message || 'Failed to register. Please check your connection and try again.');
         97	    } finally {
         98	      setLoading(false);
         99	    }
        100	  };
        101	
        102	  return (
        103	    <div className="register-container">
        104	      <h1>Create Account</h1>
        105	      
        106	      {error && (
        107	        <div className="error-message">
        108	          {error}
        109	        </div>
        110	      )}
        111	      
        112	      <form onSubmit={handleSubmit}>
        113	        <div className="form-group">
        114	          <label htmlFor="email">Email</label>
        115	          <input
        116	            type="email"
        117	            id="email"
        118	            name="email"
        119	            value={formData.email}
        120	            onChange={handleChange}
        121	            required
        122	          />
        123	        </div>
        124	        
        125	        <div className="form-group">
        126	          <label htmlFor="password">Password</label>
        127	          <input
        128	            type="password"
        129	            id="password"
        130	            name="password"
        131	            value={formData.password}
        132	            onChange={handleChange}
        133	            required
        134	            minLength={8}
        135	          />
        136	        </div>
        137	        
        138	        <div className="form-group">
        139	          <label htmlFor="confirmPassword">Confirm Password</label>
        140	          <input
        141	            type="password"
        142	            id="confirmPassword"
        143	            name="confirmPassword"
        144	            value={formData.confirmPassword}
        145	            onChange={handleChange}
        146	            required
        147	            minLength={8}
        148	          />
        149	        </div>
        150	        
        151	        <button type="submit" disabled={loading}>
        152	          {loading ? 'Creating Account...' : 'Register'}
        153	        </button>
        154	      </form>
        155	      
        156	      <div className="login-link">
        157	        <p>Already have an account? <Link to="/login">Login</Link></p>
        158	      </div>
        159	    </div>
        160	  );
        161	};
        162	
        163	export default RegisterPage;

==============================================
FILE: ./frontend/src/pages/SettingsPage.tsx
==============================================

          1	import React, { useState, useEffect } from 'react';
          2	import { auth, agents, onboarding } from '../api/apiClient';
          3	
          4	const SettingsPage: React.FC = () => {
          5	  const [email, setEmail] = useState('');
          6	  const [agentName, setAgentName] = useState('');
          7	  const [agentColor, setAgentColor] = useState('#000000');
          8	  const [digestFrequency, setDigestFrequency] = useState(24);
          9	  const [digestTone, setDigestTone] = useState('neutral');
         10	  const [loading, setLoading] = useState(true);
         11	  const [error, setError] = useState<string | null>(null);
         12	  const [success, setSuccess] = useState<string | null>(null);
         13	
         14	  useEffect(() => {
         15	    const fetchSettings = async () => {
         16	      setLoading(true);
         17	      try {
         18	        const userRes = await auth.getUser();
         19	        const agentRes = await agents.getAgent();
         20	        setEmail(userRes.data.email);
         21	        setDigestFrequency(userRes.data.digestFrequency || 24);
         22	        setDigestTone(userRes.data.digestTone || 'neutral');
         23	        setAgentName(agentRes.data.name || '');
         24	        setAgentColor(agentRes.data.color || '#000000');
         25	      } catch (err) {
         26	        setError('Failed to load settings.');
         27	      } finally {
         28	        setLoading(false);
         29	      }
         30	    };
         31	    fetchSettings();
         32	  }, []);
         33	
         34	  const handleSave = async () => {
         35	    setError(null);
         36	    setSuccess(null);
         37	    try {
         38	      await agents.updatePreferences({
         39	        name: agentName,
         40	        color: agentColor,
         41	        preferences: {}, // Extend as needed
         42	      });
         43	      await onboarding.saveStep(3, {
         44	        digestFrequency,
         45	        digestTone,
         46	      });
         47	      setSuccess('Settings saved successfully.');
         48	    } catch (err) {
         49	      setError('Failed to save settings.');
         50	    }
         51	  };
         52	
         53	  if (loading) return <div>Loading settings...</div>;
         54	
         55	  return (
         56	    <div>
         57	      <h1>Settings</h1>
         58	      {error && <p style={{ color: 'red' }}>{error}</p>}
         59	      {success && <p style={{ color: 'green' }}>{success}</p>}
         60	
         61	      <section>
         62	        <h2>Profile Settings</h2>
         63	        <label>Email (read-only):</label>
         64	        <input type="email" value={email} readOnly />
         65	      </section>
         66	
         67	      <section>
         68	        <h2>Agent Settings</h2>
         69	        <label>Name:</label>
         70	        <input value={agentName} onChange={e => setAgentName(e.target.value)} />
         71	        <label>Color:</label>
         72	        <input type="color" value={agentColor} onChange={e => setAgentColor(e.target.value)} />
         73	      </section>
         74	
         75	      <section>
         76	        <h2>Notification Settings</h2>
         77	        <label>Digest Frequency (hours):</label>
         78	        <input
         79	          type="number"
         80	          value={digestFrequency}
         81	          onChange={e => setDigestFrequency(Number(e.target.value))}
         82	          min={1}
         83	          max={168}
         84	        />
         85	        <label>Digest Tone:</label>
         86	        <select value={digestTone} onChange={e => setDigestTone(e.target.value)}>
         87	          <option value="neutral">Neutral</option>
         88	          <option value="friendly">Friendly</option>
         89	          <option value="formal">Formal</option>
         90	        </select>
         91	      </section>
         92	
         93	      <button onClick={handleSave}>Save Settings</button>
         94	    </div>
         95	  );
         96	};
         97	
         98	export default SettingsPage;

==============================================
FILE: ./frontend/tsconfig.json
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./frontend/vite.config.ts
==============================================

          1	import { defineConfig } from "vite";
          2	import react from "@vitejs/plugin-react";
          3	
          4	export default defineConfig({
          5	  plugins: [react()],
          6	  server: {
          7	    proxy: {
          8	      "/api": {
          9	        target: "http://localhost:4000",
         10	        changeOrigin: true,
         11	        secure: false,
         12	      },
         13	    },
         14	  },
         15	});

==============================================
FILE: ./images/praxisagent.png
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./images/praxisagent.svg
==============================================

          1	﻿<?xml version="1.0" encoding="utf-8"?><Error><Code>AuthenticationFailed</Code><Message>Server failed to authenticate the request. Make sure the value of Authorization header is formed correctly including the signature.
          2	RequestId:780fb2b1-401e-00cb-0d94-b40264000000
          3	Time:2025-04-23T21:13:36.3290062Z</Message><AuthenticationErrorDetail>Signed expiry time [Wed, 23 Apr 2025 20:49:41 GMT] must be after signed start time [Wed, 23 Apr 2025 21:13:36 GMT]</AuthenticationErrorDetail></Error>

==============================================
FILE: ./logs/image-1.png
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./logs/image.png
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./logs/log1.md
==============================================

          1	LLM usage logged successfully.
          2	[Onboarding/FSM] LLM response received: (step 3/7) Of the issues we discussed (Water Treatment Plant, Wildfire Risk Utility, Transportation System), which ONE matters most to you right now?
          3	[Onboarding] Saved user message: { id: 'd5354eb8-3327-41a1-80ab-a96100f9fcd9' }
          4	[Onboarding] Saved agent message: {
          5	  id: 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3',
          6	  contentLength: 149,
          7	  step: 3,
          8	  nextStep: 4
          9	}
         10	[Onboarding/FSM] Returning partial extractedPreferences: {"issuesMatrix":[{"id":"1","title":"Water-Treatment Plant Funding Gap","reason":"Safe water is non-negotiable; bite the bullet now.","stance":"A","summary":"Safe water is non-negotiable; bite the bullet now.","isPriority":false,"description":"Issue a 25-year municipal revenue bond and raise residential water rates 12% to close the $50M shortfall after FEMA's BRIC grant was cancelled."},{"id":"3","title":"Wildfire-Risk Utility Surcharge","reason":"Favor, emphasize tourism reliability.","stance":"C","summary":"Favor, emphasize tourism reliability.","isPriority":false,"description":"Endorse Pacific Power's plan to add a temporary $2/month surcharge to speed undergrounding and covered-conductor projects (500 mi planned, 100 mi in 2025)."},{"id":"4","title":"Transportation System Plan (TSP) Priority Package","reason":"+ C","stance":"B","summary":"Oppose—predict worse congestion.","isPriority":false,"description":"Adopt the TSP's \"Active Streets\" scenario, reallocating $5M from road-widening to bike & sidewalk links near two I-5 interchanges."}],"selectedIssues":["1","3","4"]}
         11	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
         12	[requireAuth] Authenticated user: {
         13	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
         14	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
         15	  iat: 1745533414,
         16	  exp: 1745537014
         17	}
         18	[AgentMe] GET /api/agents/me called
         19	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
         20	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
         21	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":false}
         22	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
         23	[requireAuth] Authenticated user: {
         24	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
         25	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
         26	  iat: 1745533414,
         27	  exp: 1745537014
         28	}
         29	[Onboarding/FSM] userId: 4becea93-e95b-4a50-8844-fe7663c835a0 agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874 step: 4 message: water
         30	[Onboarding/FSM] LLM SYSTEM PROMPT: You are a Praxis Agent performing FAST onboarding.
         31	
         32	Rules:
         33	• Follow steps 0-7 strictly; ONE prompt per step. No meta-discussion.
         34	• Use the live issue list from the database.
         35	• At Step 1, present the numbered list exactly as provided; accept comma-separated replies.
         36	• At Step 2, iterate ONLY over issues the user selected, in the order they listed.
         37	  Provide balanced perspectives on each issue before asking for their stance.
         38	  Present both sides' viewpoints fairly, then ask: "After considering these perspectives, do you prefer approach A, B, C or something else? One-line reason."
         39	• Do not ask how to negotiate or how governance works.
         40	• Store answers in memory under keys:
         41	  agentNickname, selectedIssues[], issueStances[], topPriorityIssue,
         42	  dealBreakers[], notifyPref, initialIdeas[].
         43	• After Step 7, send JSON summary then say:
         44	  "All set! Ask me anything or explore proposals whenever you're ready."
         45	
         46	Tone:
         47	  Friendly, concise (≤2 sentences each turn).
         48	Progress tags:
         49	  Prefix each step with "(step / total)".
         50	
         51	The 7 steps are:
         52	Step 0: Ask user for a nickname for you
         53	Step 1: Present list of numbered issues and ask which ones they care about
         54	Step 2: For each selected issue, first present balanced perspectives from different viewpoints, showing how different people view the problem in good faith. Then ask where they stand: approach A, B, C or something else
         55	Step 3: Ask which ONE issue matters most to them right now
         56	Step 4: Ask about any absolute deal-breakers
         57	Step 5: Ask about notification preferences (A-major only, B-weekly, C-every decision)
         58	Step 6: Ask if they have any initial ideas/proposals for later
         59	Step 7: Provide summary and completion
         60	
         61	        Current onboarding step: 4
         62	        Current issues: 1-Water Treatment Plant  2-Downtown Homeless  3-Wildfire Risk Utility  4-Transportation System  5-Cannabis Compliance  6-Lodging Tax Reallocation
         63	
         64	        (5/9) Of those issues, which ONE matters most to you right now?
         65	[Onboarding/FSM] Full prompt array: [
         66	  {
         67	    "role": "system",
         68	    "content": "You are a Praxis Agent performing FAST onboarding.\n\nRules:\n• Follow steps 0-7 strictly; ONE prompt per step. No meta-discussion.\n• Use the live issue list from the database.\n• At Step 1, present the numbered list exactly as provided; accept comma-separated replies.\n• At Step 2, iterate ONLY over issues the user selected, in the order they listed.\n  Provide balanced perspectives on each issue before asking for their stance.\n  Present both sides' viewpoints fairly, then ask: \"After considering these perspectives, do you prefer approach A, B, C or something else? One-line reason.\"\n• Do not ask how to negotiate or how governance works.\n• Store answers in memory under keys:\n  agentNickname, selectedIssues[], issueStances[], topPriorityIssue,\n  dealBreakers[], notifyPref, initialIdeas[].\n• After Step 7, send JSON summary then say:\n  \"All set! Ask me anything or explore proposals whenever you're ready.\"\n\nTone:\n  Friendly, concise (≤2 sentences each turn).\nProgress tags:\n  Prefix each step with \"(step / total)\".\n\nThe 7 steps are:\nStep 0: Ask user for a nickname for you\nStep 1: Present list of numbered issues and ask which ones they care about\nStep 2: For each selected issue, first present balanced perspectives from different viewpoints, showing how different people view the problem in good faith. Then ask where they stand: approach A, B, C or something else\nStep 3: Ask which ONE issue matters most to them right now\nStep 4: Ask about any absolute deal-breakers\nStep 5: Ask about notification preferences (A-major only, B-weekly, C-every decision)\nStep 6: Ask if they have any initial ideas/proposals for later\nStep 7: Provide summary and completion\n\n        Current onboarding step: 4\n        Current issues: 1-Water Treatment Plant  2-Downtown Homeless  3-Wildfire Risk Utility  4-Transportation System  5-Cannabis Compliance  6-Lodging Tax Reallocation\n\n        (5/9) Of those issues, which ONE matters most to you right now?"
         69	  },
         70	  {
         71	    "role": "assistant",
         72	    "content": "(1/9) Welcome! What is your name?"
         73	  },
         74	  {
         75	    "role": "user",
         76	    "content": "Adam"
         77	  },
         78	  {
         79	    "role": "assistant",
         80	    "content": "(step 0/7) Thanks, Adam! What nickname would you like to give me for this process?"
         81	  },
         82	  {
         83	    "role": "user",
         84	    "content": "Prax"
         85	  },
         86	  {
         87	    "role": "assistant",
         88	    "content": "(step 1/7) Great! Here are the current issues:\n1-Water Treatment Plant\n2-Downtown Homeless\n3-Wildfire Risk Utility\n4-Transportation System\n5-Cannabis Compliance\n6-Lodging Tax Reallocation\n\nWhich numbers do you care about? (Reply with a comma-separated list, e.g. 1,3,5)"
         89	  },
         90	  {
         91	    "role": "user",
         92	    "content": "1, 3, 4"
         93	  },
         94	  {
         95	    "role": "assistant",
         96	    "content": "(step 2/7) Let's go through each of your selected issues one by one, starting with:\n\n1 - Water Treatment Plant\n\nBalanced perspectives:\nApproach A - Some advocate for fast-tracking upgrades to the water treatment plant, prioritizing public health, water quality, and future drought resilience, even if it means higher short-term costs.\nApproach B - Others stress fiscal caution, preferring to perform only necessary repairs and delay larger investments until stricter regulations or urgent failure require action, prioritizing affordability for ratepayers.\nApproach C - Some suggest a phased approach: immediate critical repairs now, with incremental upgrades as technology improves and funding becomes available, balancing cost and benefit.\n\nAfter considering these perspectives, do you prefer approach A, B, C or something else? One-line reason."
         97	  },
         98	  {
         99	    "role": "user",
        100	    "content": "A"
        101	  },
        102	  {
        103	    "role": "assistant",
        104	    "content": "(step 2/7) Issue 3 – Wildfire Risk Utility\n\nBalanced perspectives:\nApproach A - Supporters want to establish a dedicated utility fee now to boost wildfire prevention, forest thinning, and public education, citing increasing fire risks and insurance losses.\nApproach B - Critics prefer using existing emergency reserves and pursuing grants, pointing to economic stress and skepticism about creating a new municipal utility fee.\nApproach C - Others propose a pilot program targeting high-risk neighborhoods first, assessing results before citywide expansion.\n\nAfter considering these perspectives, do you prefer approach A, B, C, or something else? One-line reason."
        105	  },
        106	  {
        107	    "role": "user",
        108	    "content": "C"
        109	  },
        110	  {
        111	    "role": "assistant",
        112	    "content": "(step 2/7) Issue 4 – Transportation System\n\nBalanced perspectives:\nApproach A - Urban planners and climate advocates support rapid transit expansion and protected bike lanes, aiming for lower emissions, less congestion, and greater mobility options.\nApproach B - Budget-conscious groups and some local businesses favor focusing on road repairs and modest upgrades, emphasizing immediate vehicle and delivery access needs.\nApproach C - Others support flexible incremental reforms, combining limited upgrades in public transit, walking, and driving infrastructure to balance cost and community input.\n\nAfter considering these perspectives, do you prefer approach A, B, C, or something else? One-line reason."
        113	  },
        114	  {
        115	    "role": "user",
        116	    "content": "B + C"
        117	  },
        118	  {
        119	    "role": "assistant",
        120	    "content": "(step 3/7) Of the issues we discussed (Water Treatment Plant, Wildfire Risk Utility, Transportation System), which ONE matters most to you right now?"
        121	  },
        122	  {
        123	    "role": "user",
        124	    "content": "water"
        125	  }
        126	]
        127	LLM usage logged successfully.
        128	[Onboarding/FSM] LLM response received: (step 4/7) Are there any absolute deal-breakers or lines you won’t cross on any of these issues? (For example: No new taxes, must meet environmental standards, etc.)
        129	[Onboarding] Saved user message: { id: 'bfaa802a-cb9f-4425-b930-81c90efbf4af' }
        130	[Onboarding] Saved agent message: {
        131	  id: '331aa36f-d34f-4355-9bdd-536da2015198',
        132	  contentLength: 165,
        133	  step: 4,
        134	  nextStep: 5
        135	}
        136	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        137	[requireAuth] Authenticated user: {
        138	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        139	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        140	  iat: 1745533414,
        141	  exp: 1745537014
        142	}
        143	[AgentMe] GET /api/agents/me called
        144	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        145	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        146	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":false}
        147	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        148	[requireAuth] Authenticated user: {
        149	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        150	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        151	  iat: 1745533414,
        152	  exp: 1745537014
        153	}
        154	[Onboarding/FSM] userId: 4becea93-e95b-4a50-8844-fe7663c835a0 agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874 step: 5 message: no
        155	[Onboarding/FSM] Updated priority issue in matrix: [{"id":"1","title":"Water-Treatment Plant Funding Gap","reason":"Safe water is non-negotiable; bite the bullet now.","stance":"A","summary":"Safe water is non-negotiable; bite the bullet now.","isPriority":true,"description":"Issue a 25-year municipal revenue bond and raise residential water rates 12% to close the $50M shortfall after FEMA's BRIC grant was cancelled."},{"id":"3","title":"Wildfire-Risk Utility Surcharge","reason":"Favor, emphasize tourism reliability.","stance":"C","summary":"Favor, emphasize tourism reliability.","isPriority":false,"description":"Endorse Pacific Power's plan to add a temporary $2/month surcharge to speed undergrounding and covered-conductor projects (500 mi planned, 100 mi in 2025)."},{"id":"4","title":"Transportation System Plan (TSP) Priority Package","reason":"+ C","stance":"B","summary":"Oppose—predict worse congestion.","isPriority":false,"description":"Adopt the TSP's \"Active Streets\" scenario, reallocating $5M from road-widening to bike & sidewalk links near two I-5 interchanges."}]
        156	[Onboarding/FSM] LLM SYSTEM PROMPT: You are a Praxis Agent performing FAST onboarding.
        157	
        158	Rules:
        159	• Follow steps 0-7 strictly; ONE prompt per step. No meta-discussion.
        160	• Use the live issue list from the database.
        161	• At Step 1, present the numbered list exactly as provided; accept comma-separated replies.
        162	• At Step 2, iterate ONLY over issues the user selected, in the order they listed.
        163	  Provide balanced perspectives on each issue before asking for their stance.
        164	  Present both sides' viewpoints fairly, then ask: "After considering these perspectives, do you prefer approach A, B, C or something else? One-line reason."
        165	• Do not ask how to negotiate or how governance works.
        166	• Store answers in memory under keys:
        167	  agentNickname, selectedIssues[], issueStances[], topPriorityIssue,
        168	  dealBreakers[], notifyPref, initialIdeas[].
        169	• After Step 7, send JSON summary then say:
        170	  "All set! Ask me anything or explore proposals whenever you're ready."
        171	
        172	Tone:
        173	  Friendly, concise (≤2 sentences each turn).
        174	Progress tags:
        175	  Prefix each step with "(step / total)".
        176	
        177	The 7 steps are:
        178	Step 0: Ask user for a nickname for you
        179	Step 1: Present list of numbered issues and ask which ones they care about
        180	Step 2: For each selected issue, first present balanced perspectives from different viewpoints, showing how different people view the problem in good faith. Then ask where they stand: approach A, B, C or something else
        181	Step 3: Ask which ONE issue matters most to them right now
        182	Step 4: Ask about any absolute deal-breakers
        183	Step 5: Ask about notification preferences (A-major only, B-weekly, C-every decision)
        184	Step 6: Ask if they have any initial ideas/proposals for later
        185	Step 7: Provide summary and completion
        186	
        187	        Current onboarding step: 5
        188	        Current issues: 1-Water Treatment Plant  2-Downtown Homeless  3-Wildfire Risk Utility  4-Transportation System  5-Cannabis Compliance  6-Lodging Tax Reallocation
        189	
        190	        (6/9) Is there any outcome you absolutely could NOT accept in group decisions? One sentence or type 'none'.
        191	[Onboarding/FSM] Full prompt array: [
        192	  {
        193	    "role": "system",
        194	    "content": "You are a Praxis Agent performing FAST onboarding.\n\nRules:\n• Follow steps 0-7 strictly; ONE prompt per step. No meta-discussion.\n• Use the live issue list from the database.\n• At Step 1, present the numbered list exactly as provided; accept comma-separated replies.\n• At Step 2, iterate ONLY over issues the user selected, in the order they listed.\n  Provide balanced perspectives on each issue before asking for their stance.\n  Present both sides' viewpoints fairly, then ask: \"After considering these perspectives, do you prefer approach A, B, C or something else? One-line reason.\"\n• Do not ask how to negotiate or how governance works.\n• Store answers in memory under keys:\n  agentNickname, selectedIssues[], issueStances[], topPriorityIssue,\n  dealBreakers[], notifyPref, initialIdeas[].\n• After Step 7, send JSON summary then say:\n  \"All set! Ask me anything or explore proposals whenever you're ready.\"\n\nTone:\n  Friendly, concise (≤2 sentences each turn).\nProgress tags:\n  Prefix each step with \"(step / total)\".\n\nThe 7 steps are:\nStep 0: Ask user for a nickname for you\nStep 1: Present list of numbered issues and ask which ones they care about\nStep 2: For each selected issue, first present balanced perspectives from different viewpoints, showing how different people view the problem in good faith. Then ask where they stand: approach A, B, C or something else\nStep 3: Ask which ONE issue matters most to them right now\nStep 4: Ask about any absolute deal-breakers\nStep 5: Ask about notification preferences (A-major only, B-weekly, C-every decision)\nStep 6: Ask if they have any initial ideas/proposals for later\nStep 7: Provide summary and completion\n\n        Current onboarding step: 5\n        Current issues: 1-Water Treatment Plant  2-Downtown Homeless  3-Wildfire Risk Utility  4-Transportation System  5-Cannabis Compliance  6-Lodging Tax Reallocation\n\n        (6/9) Is there any outcome you absolutely could NOT accept in group decisions? One sentence or type 'none'."
        195	  },
        196	  {
        197	    "role": "assistant",
        198	    "content": "(1/9) Welcome! What is your name?"
        199	  },
        200	  {
        201	    "role": "user",
        202	    "content": "Adam"
        203	  },
        204	  {
        205	    "role": "assistant",
        206	    "content": "(step 0/7) Thanks, Adam! What nickname would you like to give me for this process?"
        207	  },
        208	  {
        209	    "role": "user",
        210	    "content": "Prax"
        211	  },
        212	  {
        213	    "role": "assistant",
        214	    "content": "(step 1/7) Great! Here are the current issues:\n1-Water Treatment Plant\n2-Downtown Homeless\n3-Wildfire Risk Utility\n4-Transportation System\n5-Cannabis Compliance\n6-Lodging Tax Reallocation\n\nWhich numbers do you care about? (Reply with a comma-separated list, e.g. 1,3,5)"
        215	  },
        216	  {
        217	    "role": "user",
        218	    "content": "1, 3, 4"
        219	  },
        220	  {
        221	    "role": "assistant",
        222	    "content": "(step 2/7) Let's go through each of your selected issues one by one, starting with:\n\n1 - Water Treatment Plant\n\nBalanced perspectives:\nApproach A - Some advocate for fast-tracking upgrades to the water treatment plant, prioritizing public health, water quality, and future drought resilience, even if it means higher short-term costs.\nApproach B - Others stress fiscal caution, preferring to perform only necessary repairs and delay larger investments until stricter regulations or urgent failure require action, prioritizing affordability for ratepayers.\nApproach C - Some suggest a phased approach: immediate critical repairs now, with incremental upgrades as technology improves and funding becomes available, balancing cost and benefit.\n\nAfter considering these perspectives, do you prefer approach A, B, C or something else? One-line reason."
        223	  },
        224	  {
        225	    "role": "user",
        226	    "content": "A"
        227	  },
        228	  {
        229	    "role": "assistant",
        230	    "content": "(step 2/7) Issue 3 – Wildfire Risk Utility\n\nBalanced perspectives:\nApproach A - Supporters want to establish a dedicated utility fee now to boost wildfire prevention, forest thinning, and public education, citing increasing fire risks and insurance losses.\nApproach B - Critics prefer using existing emergency reserves and pursuing grants, pointing to economic stress and skepticism about creating a new municipal utility fee.\nApproach C - Others propose a pilot program targeting high-risk neighborhoods first, assessing results before citywide expansion.\n\nAfter considering these perspectives, do you prefer approach A, B, C, or something else? One-line reason."
        231	  },
        232	  {
        233	    "role": "user",
        234	    "content": "C"
        235	  },
        236	  {
        237	    "role": "assistant",
        238	    "content": "(step 2/7) Issue 4 – Transportation System\n\nBalanced perspectives:\nApproach A - Urban planners and climate advocates support rapid transit expansion and protected bike lanes, aiming for lower emissions, less congestion, and greater mobility options.\nApproach B - Budget-conscious groups and some local businesses favor focusing on road repairs and modest upgrades, emphasizing immediate vehicle and delivery access needs.\nApproach C - Others support flexible incremental reforms, combining limited upgrades in public transit, walking, and driving infrastructure to balance cost and community input.\n\nAfter considering these perspectives, do you prefer approach A, B, C, or something else? One-line reason."
        239	  },
        240	  {
        241	    "role": "user",
        242	    "content": "B + C"
        243	  },
        244	  {
        245	    "role": "assistant",
        246	    "content": "(step 3/7) Of the issues we discussed (Water Treatment Plant, Wildfire Risk Utility, Transportation System), which ONE matters most to you right now?"
        247	  },
        248	  {
        249	    "role": "user",
        250	    "content": "water"
        251	  },
        252	  {
        253	    "role": "assistant",
        254	    "content": "(step 4/7) Are there any absolute deal-breakers or lines you won’t cross on any of these issues? (For example: No new taxes, must meet environmental standards, etc.)"
        255	  },
        256	  {
        257	    "role": "user",
        258	    "content": "no"
        259	  }
        260	]
        261	LLM usage logged successfully.
        262	[Onboarding/FSM] LLM response received: (step 5/7) How do you want to be notified about group decisions?  
        263	A - Major updates only  
        264	B - Weekly summary  
        265	C - Every decision
        266	[Onboarding] Saved user message: { id: '90b08857-623c-4137-bab3-bd721e3aa5a9' }
        267	[Onboarding] Saved agent message: {
        268	  id: '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5',
        269	  contentLength: 131,
        270	  step: 5,
        271	  nextStep: 6
        272	}
        273	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        274	[requireAuth] Authenticated user: {
        275	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        276	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        277	  iat: 1745533414,
        278	  exp: 1745537014
        279	}
        280	[AgentMe] GET /api/agents/me called
        281	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        282	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        283	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":false}
        284	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        285	[requireAuth] Authenticated user: {
        286	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        287	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        288	  iat: 1745533414,
        289	  exp: 1745537014
        290	}
        291	[Onboarding/FSM] userId: 4becea93-e95b-4a50-8844-fe7663c835a0 agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874 step: 6 message: C
        292	[Onboarding/FSM] LLM SYSTEM PROMPT: You are a Praxis Agent performing FAST onboarding.
        293	
        294	Rules:
        295	• Follow steps 0-7 strictly; ONE prompt per step. No meta-discussion.
        296	• Use the live issue list from the database.
        297	• At Step 1, present the numbered list exactly as provided; accept comma-separated replies.
        298	• At Step 2, iterate ONLY over issues the user selected, in the order they listed.
        299	  Provide balanced perspectives on each issue before asking for their stance.
        300	  Present both sides' viewpoints fairly, then ask: "After considering these perspectives, do you prefer approach A, B, C or something else? One-line reason."
        301	• Do not ask how to negotiate or how governance works.
        302	• Store answers in memory under keys:
        303	  agentNickname, selectedIssues[], issueStances[], topPriorityIssue,
        304	  dealBreakers[], notifyPref, initialIdeas[].
        305	• After Step 7, send JSON summary then say:
        306	  "All set! Ask me anything or explore proposals whenever you're ready."
        307	
        308	Tone:
        309	  Friendly, concise (≤2 sentences each turn).
        310	Progress tags:
        311	  Prefix each step with "(step / total)".
        312	
        313	The 7 steps are:
        314	Step 0: Ask user for a nickname for you
        315	Step 1: Present list of numbered issues and ask which ones they care about
        316	Step 2: For each selected issue, first present balanced perspectives from different viewpoints, showing how different people view the problem in good faith. Then ask where they stand: approach A, B, C or something else
        317	Step 3: Ask which ONE issue matters most to them right now
        318	Step 4: Ask about any absolute deal-breakers
        319	Step 5: Ask about notification preferences (A-major only, B-weekly, C-every decision)
        320	Step 6: Ask if they have any initial ideas/proposals for later
        321	Step 7: Provide summary and completion
        322	
        323	        Current onboarding step: 6
        324	        Current issues: 1-Water Treatment Plant  2-Downtown Homeless  3-Wildfire Risk Utility  4-Transportation System  5-Cannabis Compliance  6-Lodging Tax Reallocation
        325	
        326	        (7/9) How often should I brief you? A-major items only B-weekly digest C-every decision.
        327	[Onboarding/FSM] Full prompt array: [
        328	  {
        329	    "role": "system",
        330	    "content": "You are a Praxis Agent performing FAST onboarding.\n\nRules:\n• Follow steps 0-7 strictly; ONE prompt per step. No meta-discussion.\n• Use the live issue list from the database.\n• At Step 1, present the numbered list exactly as provided; accept comma-separated replies.\n• At Step 2, iterate ONLY over issues the user selected, in the order they listed.\n  Provide balanced perspectives on each issue before asking for their stance.\n  Present both sides' viewpoints fairly, then ask: \"After considering these perspectives, do you prefer approach A, B, C or something else? One-line reason.\"\n• Do not ask how to negotiate or how governance works.\n• Store answers in memory under keys:\n  agentNickname, selectedIssues[], issueStances[], topPriorityIssue,\n  dealBreakers[], notifyPref, initialIdeas[].\n• After Step 7, send JSON summary then say:\n  \"All set! Ask me anything or explore proposals whenever you're ready.\"\n\nTone:\n  Friendly, concise (≤2 sentences each turn).\nProgress tags:\n  Prefix each step with \"(step / total)\".\n\nThe 7 steps are:\nStep 0: Ask user for a nickname for you\nStep 1: Present list of numbered issues and ask which ones they care about\nStep 2: For each selected issue, first present balanced perspectives from different viewpoints, showing how different people view the problem in good faith. Then ask where they stand: approach A, B, C or something else\nStep 3: Ask which ONE issue matters most to them right now\nStep 4: Ask about any absolute deal-breakers\nStep 5: Ask about notification preferences (A-major only, B-weekly, C-every decision)\nStep 6: Ask if they have any initial ideas/proposals for later\nStep 7: Provide summary and completion\n\n        Current onboarding step: 6\n        Current issues: 1-Water Treatment Plant  2-Downtown Homeless  3-Wildfire Risk Utility  4-Transportation System  5-Cannabis Compliance  6-Lodging Tax Reallocation\n\n        (7/9) How often should I brief you? A-major items only B-weekly digest C-every decision."
        331	  },
        332	  {
        333	    "role": "assistant",
        334	    "content": "(1/9) Welcome! What is your name?"
        335	  },
        336	  {
        337	    "role": "user",
        338	    "content": "Adam"
        339	  },
        340	  {
        341	    "role": "assistant",
        342	    "content": "(step 0/7) Thanks, Adam! What nickname would you like to give me for this process?"
        343	  },
        344	  {
        345	    "role": "user",
        346	    "content": "Prax"
        347	  },
        348	  {
        349	    "role": "assistant",
        350	    "content": "(step 1/7) Great! Here are the current issues:\n1-Water Treatment Plant\n2-Downtown Homeless\n3-Wildfire Risk Utility\n4-Transportation System\n5-Cannabis Compliance\n6-Lodging Tax Reallocation\n\nWhich numbers do you care about? (Reply with a comma-separated list, e.g. 1,3,5)"
        351	  },
        352	  {
        353	    "role": "user",
        354	    "content": "1, 3, 4"
        355	  },
        356	  {
        357	    "role": "assistant",
        358	    "content": "(step 2/7) Let's go through each of your selected issues one by one, starting with:\n\n1 - Water Treatment Plant\n\nBalanced perspectives:\nApproach A - Some advocate for fast-tracking upgrades to the water treatment plant, prioritizing public health, water quality, and future drought resilience, even if it means higher short-term costs.\nApproach B - Others stress fiscal caution, preferring to perform only necessary repairs and delay larger investments until stricter regulations or urgent failure require action, prioritizing affordability for ratepayers.\nApproach C - Some suggest a phased approach: immediate critical repairs now, with incremental upgrades as technology improves and funding becomes available, balancing cost and benefit.\n\nAfter considering these perspectives, do you prefer approach A, B, C or something else? One-line reason."
        359	  },
        360	  {
        361	    "role": "user",
        362	    "content": "A"
        363	  },
        364	  {
        365	    "role": "assistant",
        366	    "content": "(step 2/7) Issue 3 – Wildfire Risk Utility\n\nBalanced perspectives:\nApproach A - Supporters want to establish a dedicated utility fee now to boost wildfire prevention, forest thinning, and public education, citing increasing fire risks and insurance losses.\nApproach B - Critics prefer using existing emergency reserves and pursuing grants, pointing to economic stress and skepticism about creating a new municipal utility fee.\nApproach C - Others propose a pilot program targeting high-risk neighborhoods first, assessing results before citywide expansion.\n\nAfter considering these perspectives, do you prefer approach A, B, C, or something else? One-line reason."
        367	  },
        368	  {
        369	    "role": "user",
        370	    "content": "C"
        371	  },
        372	  {
        373	    "role": "assistant",
        374	    "content": "(step 2/7) Issue 4 – Transportation System\n\nBalanced perspectives:\nApproach A - Urban planners and climate advocates support rapid transit expansion and protected bike lanes, aiming for lower emissions, less congestion, and greater mobility options.\nApproach B - Budget-conscious groups and some local businesses favor focusing on road repairs and modest upgrades, emphasizing immediate vehicle and delivery access needs.\nApproach C - Others support flexible incremental reforms, combining limited upgrades in public transit, walking, and driving infrastructure to balance cost and community input.\n\nAfter considering these perspectives, do you prefer approach A, B, C, or something else? One-line reason."
        375	  },
        376	  {
        377	    "role": "user",
        378	    "content": "B + C"
        379	  },
        380	  {
        381	    "role": "assistant",
        382	    "content": "(step 3/7) Of the issues we discussed (Water Treatment Plant, Wildfire Risk Utility, Transportation System), which ONE matters most to you right now?"
        383	  },
        384	  {
        385	    "role": "user",
        386	    "content": "water"
        387	  },
        388	  {
        389	    "role": "assistant",
        390	    "content": "(step 4/7) Are there any absolute deal-breakers or lines you won’t cross on any of these issues? (For example: No new taxes, must meet environmental standards, etc.)"
        391	  },
        392	  {
        393	    "role": "user",
        394	    "content": "no"
        395	  },
        396	  {
        397	    "role": "assistant",
        398	    "content": "(step 5/7) How do you want to be notified about group decisions?  \nA - Major updates only  \nB - Weekly summary  \nC - Every decision"
        399	  },
        400	  {
        401	    "role": "user",
        402	    "content": "C"
        403	  }
        404	]
        405	LLM usage logged successfully.
        406	[Onboarding/FSM] LLM response received: (step 6/7) Do you have any initial ideas or proposals you want to save for later discussion on these issues? (Just a short note if so—optional.)
        407	[Onboarding] Saved user message: { id: '71d91d83-9ff5-459c-b92f-2917bbf588f4' }
        408	[Onboarding] Saved agent message: {
        409	  id: '50cc9b8b-c849-47ba-813e-a927246e0be2',
        410	  contentLength: 144,
        411	  step: 6,
        412	  nextStep: 7
        413	}
        414	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        415	[requireAuth] Authenticated user: {
        416	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        417	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        418	  iat: 1745533414,
        419	  exp: 1745537014
        420	}
        421	[AgentMe] GET /api/agents/me called
        422	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        423	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        424	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":false}
        425	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        426	[requireAuth] Authenticated user: {
        427	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        428	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        429	  iat: 1745533414,
        430	  exp: 1745537014
        431	}
        432	[Onboarding/FSM] userId: 4becea93-e95b-4a50-8844-fe7663c835a0 agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874 step: 7 message: No
        433	[Onboarding/FSM] LLM SYSTEM PROMPT: You are a Praxis Agent performing FAST onboarding.
        434	
        435	Rules:
        436	• Follow steps 0-7 strictly; ONE prompt per step. No meta-discussion.
        437	• Use the live issue list from the database.
        438	• At Step 1, present the numbered list exactly as provided; accept comma-separated replies.
        439	• At Step 2, iterate ONLY over issues the user selected, in the order they listed.
        440	  Provide balanced perspectives on each issue before asking for their stance.
        441	  Present both sides' viewpoints fairly, then ask: "After considering these perspectives, do you prefer approach A, B, C or something else? One-line reason."
        442	• Do not ask how to negotiate or how governance works.
        443	• Store answers in memory under keys:
        444	  agentNickname, selectedIssues[], issueStances[], topPriorityIssue,
        445	  dealBreakers[], notifyPref, initialIdeas[].
        446	• After Step 7, send JSON summary then say:
        447	  "All set! Ask me anything or explore proposals whenever you're ready."
        448	
        449	Tone:
        450	  Friendly, concise (≤2 sentences each turn).
        451	Progress tags:
        452	  Prefix each step with "(step / total)".
        453	
        454	The 7 steps are:
        455	Step 0: Ask user for a nickname for you
        456	Step 1: Present list of numbered issues and ask which ones they care about
        457	Step 2: For each selected issue, first present balanced perspectives from different viewpoints, showing how different people view the problem in good faith. Then ask where they stand: approach A, B, C or something else
        458	Step 3: Ask which ONE issue matters most to them right now
        459	Step 4: Ask about any absolute deal-breakers
        460	Step 5: Ask about notification preferences (A-major only, B-weekly, C-every decision)
        461	Step 6: Ask if they have any initial ideas/proposals for later
        462	Step 7: Provide summary and completion
        463	
        464	        Current onboarding step: 7
        465	        Current issues: 1-Water Treatment Plant  2-Downtown Homeless  3-Wildfire Risk Utility  4-Transportation System  5-Cannabis Compliance  6-Lodging Tax Reallocation
        466	
        467	        (8/9) Any idea or proposal you'd like me to log for later? If none, just say 'done'.
        468	[Onboarding/FSM] Full prompt array: [
        469	  {
        470	    "role": "system",
        471	    "content": "You are a Praxis Agent performing FAST onboarding.\n\nRules:\n• Follow steps 0-7 strictly; ONE prompt per step. No meta-discussion.\n• Use the live issue list from the database.\n• At Step 1, present the numbered list exactly as provided; accept comma-separated replies.\n• At Step 2, iterate ONLY over issues the user selected, in the order they listed.\n  Provide balanced perspectives on each issue before asking for their stance.\n  Present both sides' viewpoints fairly, then ask: \"After considering these perspectives, do you prefer approach A, B, C or something else? One-line reason.\"\n• Do not ask how to negotiate or how governance works.\n• Store answers in memory under keys:\n  agentNickname, selectedIssues[], issueStances[], topPriorityIssue,\n  dealBreakers[], notifyPref, initialIdeas[].\n• After Step 7, send JSON summary then say:\n  \"All set! Ask me anything or explore proposals whenever you're ready.\"\n\nTone:\n  Friendly, concise (≤2 sentences each turn).\nProgress tags:\n  Prefix each step with \"(step / total)\".\n\nThe 7 steps are:\nStep 0: Ask user for a nickname for you\nStep 1: Present list of numbered issues and ask which ones they care about\nStep 2: For each selected issue, first present balanced perspectives from different viewpoints, showing how different people view the problem in good faith. Then ask where they stand: approach A, B, C or something else\nStep 3: Ask which ONE issue matters most to them right now\nStep 4: Ask about any absolute deal-breakers\nStep 5: Ask about notification preferences (A-major only, B-weekly, C-every decision)\nStep 6: Ask if they have any initial ideas/proposals for later\nStep 7: Provide summary and completion\n\n        Current onboarding step: 7\n        Current issues: 1-Water Treatment Plant  2-Downtown Homeless  3-Wildfire Risk Utility  4-Transportation System  5-Cannabis Compliance  6-Lodging Tax Reallocation\n\n        (8/9) Any idea or proposal you'd like me to log for later? If none, just say 'done'."
        472	  },
        473	  {
        474	    "role": "assistant",
        475	    "content": "(1/9) Welcome! What is your name?"
        476	  },
        477	  {
        478	    "role": "user",
        479	    "content": "Adam"
        480	  },
        481	  {
        482	    "role": "assistant",
        483	    "content": "(step 0/7) Thanks, Adam! What nickname would you like to give me for this process?"
        484	  },
        485	  {
        486	    "role": "user",
        487	    "content": "Prax"
        488	  },
        489	  {
        490	    "role": "assistant",
        491	    "content": "(step 1/7) Great! Here are the current issues:\n1-Water Treatment Plant\n2-Downtown Homeless\n3-Wildfire Risk Utility\n4-Transportation System\n5-Cannabis Compliance\n6-Lodging Tax Reallocation\n\nWhich numbers do you care about? (Reply with a comma-separated list, e.g. 1,3,5)"
        492	  },
        493	  {
        494	    "role": "user",
        495	    "content": "1, 3, 4"
        496	  },
        497	  {
        498	    "role": "assistant",
        499	    "content": "(step 2/7) Let's go through each of your selected issues one by one, starting with:\n\n1 - Water Treatment Plant\n\nBalanced perspectives:\nApproach A - Some advocate for fast-tracking upgrades to the water treatment plant, prioritizing public health, water quality, and future drought resilience, even if it means higher short-term costs.\nApproach B - Others stress fiscal caution, preferring to perform only necessary repairs and delay larger investments until stricter regulations or urgent failure require action, prioritizing affordability for ratepayers.\nApproach C - Some suggest a phased approach: immediate critical repairs now, with incremental upgrades as technology improves and funding becomes available, balancing cost and benefit.\n\nAfter considering these perspectives, do you prefer approach A, B, C or something else? One-line reason."
        500	  },
        501	  {
        502	    "role": "user",
        503	    "content": "A"
        504	  },
        505	  {
        506	    "role": "assistant",
        507	    "content": "(step 2/7) Issue 3 – Wildfire Risk Utility\n\nBalanced perspectives:\nApproach A - Supporters want to establish a dedicated utility fee now to boost wildfire prevention, forest thinning, and public education, citing increasing fire risks and insurance losses.\nApproach B - Critics prefer using existing emergency reserves and pursuing grants, pointing to economic stress and skepticism about creating a new municipal utility fee.\nApproach C - Others propose a pilot program targeting high-risk neighborhoods first, assessing results before citywide expansion.\n\nAfter considering these perspectives, do you prefer approach A, B, C, or something else? One-line reason."
        508	  },
        509	  {
        510	    "role": "user",
        511	    "content": "C"
        512	  },
        513	  {
        514	    "role": "assistant",
        515	    "content": "(step 2/7) Issue 4 – Transportation System\n\nBalanced perspectives:\nApproach A - Urban planners and climate advocates support rapid transit expansion and protected bike lanes, aiming for lower emissions, less congestion, and greater mobility options.\nApproach B - Budget-conscious groups and some local businesses favor focusing on road repairs and modest upgrades, emphasizing immediate vehicle and delivery access needs.\nApproach C - Others support flexible incremental reforms, combining limited upgrades in public transit, walking, and driving infrastructure to balance cost and community input.\n\nAfter considering these perspectives, do you prefer approach A, B, C, or something else? One-line reason."
        516	  },
        517	  {
        518	    "role": "user",
        519	    "content": "B + C"
        520	  },
        521	  {
        522	    "role": "assistant",
        523	    "content": "(step 3/7) Of the issues we discussed (Water Treatment Plant, Wildfire Risk Utility, Transportation System), which ONE matters most to you right now?"
        524	  },
        525	  {
        526	    "role": "user",
        527	    "content": "water"
        528	  },
        529	  {
        530	    "role": "assistant",
        531	    "content": "(step 4/7) Are there any absolute deal-breakers or lines you won’t cross on any of these issues? (For example: No new taxes, must meet environmental standards, etc.)"
        532	  },
        533	  {
        534	    "role": "user",
        535	    "content": "no"
        536	  },
        537	  {
        538	    "role": "assistant",
        539	    "content": "(step 5/7) How do you want to be notified about group decisions?  \nA - Major updates only  \nB - Weekly summary  \nC - Every decision"
        540	  },
        541	  {
        542	    "role": "user",
        543	    "content": "C"
        544	  },
        545	  {
        546	    "role": "assistant",
        547	    "content": "(step 6/7) Do you have any initial ideas or proposals you want to save for later discussion on these issues? (Just a short note if so—optional.)"
        548	  },
        549	  {
        550	    "role": "user",
        551	    "content": "No"
        552	  }
        553	]
        554	LLM usage logged successfully.
        555	[Onboarding/FSM] JSON detected in final step response, replacing with standard message
        556	[Onboarding/FSM] Final step detected, marking onboarding as completed
        557	[Onboarding/FSM] LLM response received: All set! Ask me anything or explore proposals whenever you're ready.
        558	[Onboarding] Saved user message: { id: '596f42e1-5c7e-42fb-a1f9-36b34113375d' }
        559	[Onboarding] Saved agent message: {
        560	  id: '8cac9cf7-dbb3-43c8-af6a-dd5188c25df6',
        561	  contentLength: 68,
        562	  step: 7,
        563	  nextStep: 8
        564	}
        565	[Onboarding/FSM] Marking onboarding as completed for agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        566	[Onboarding/FSM] Agent onboardingCompleted status: true
        567	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        568	[requireAuth] Authenticated user: {
        569	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        570	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        571	  iat: 1745533414,
        572	  exp: 1745537014
        573	}
        574	[AgentMe] GET /api/agents/me called
        575	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        576	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        577	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":true}
        578	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        579	[requireAuth] Authenticated user: {
        580	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        581	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        582	  iat: 1745533414,
        583	  exp: 1745537014
        584	}
        585	[AgentMe] GET /api/agents/me called
        586	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        587	[requireAuth] Authenticated user: {
        588	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        589	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        590	  iat: 1745533414,
        591	  exp: 1745537014
        592	}
        593	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        594	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        595	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":true}
        596	[Issues] /api/issues/user for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        597	[Issues] Returning issues: []
        598	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        599	[requireAuth] Authenticated user: {
        600	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        601	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        602	  iat: 1745533414,
        603	  exp: 1745537014
        604	}
        605	[AgentMe] GET /api/agents/me called
        606	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        607	[requireAuth] Authenticated user: {
        608	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        609	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        610	  iat: 1745533414,
        611	  exp: 1745537014
        612	}
        613	[Issues] /api/issues/user for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        614	[Issues] Returning issues: []
        615	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        616	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        617	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":true}
        618	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        619	[requireAuth] Authenticated user: {
        620	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        621	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        622	  iat: 1745533414,
        623	  exp: 1745537014
        624	}
        625	[AgentMe] GET /api/agents/me called
        626	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        627	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        628	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":true}
        629	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        630	[requireAuth] Authenticated user: {
        631	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        632	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        633	  iat: 1745533414,
        634	  exp: 1745537014
        635	}
        636	[AgentMe] GET /api/agents/me called
        637	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        638	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        639	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":true}
        640	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        641	[requireAuth] Authenticated user: {
        642	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        643	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        644	  iat: 1745533414,
        645	  exp: 1745537014
        646	}
        647	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        648	[requireAuth] Authenticated user: {
        649	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        650	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        651	  iat: 1745533414,
        652	  exp: 1745537014
        653	}
        654	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        655	[requireAuth] Authenticated user: {
        656	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        657	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        658	  iat: 1745533414,
        659	  exp: 1745537014
        660	}
        661	[AgentMe] GET /api/agents/me called
        662	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        663	[requireAuth] Authenticated user: {
        664	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        665	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        666	  iat: 1745533414,
        667	  exp: 1745537014
        668	}
        669	[AgentMe] GET /api/agents/me called
        670	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        671	[requireAuth] Authenticated user: {
        672	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        673	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        674	  iat: 1745533414,
        675	  exp: 1745537014
        676	}
        677	[Issues] /api/issues/user for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        678	[Issues] Returning issues: []
        679	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        680	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        681	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":true}
        682	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        683	[requireAuth] Authenticated user: {
        684	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        685	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        686	  iat: 1745533414,
        687	  exp: 1745537014
        688	}
        689	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        690	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        691	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":true}
        692	[Issues] /api/issues/user for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        693	[Issues] Returning issues: []
        694	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        695	[requireAuth] Authenticated user: {
        696	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        697	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        698	  iat: 1745533414,
        699	  exp: 1745537014
        700	}
        701	[AgentMe] GET /api/agents/me called
        702	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        703	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        704	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":true}
        705	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        706	[requireAuth] Authenticated user: {
        707	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        708	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        709	  iat: 1745533414,
        710	  exp: 1745537014
        711	}
        712	[AgentMe] GET /api/agents/me called
        713	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        714	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        715	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":true}
        716	[requireAuth] Authorization header: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI0YmVjZWE5My1lOTViLTRhNTAtODg0NC1mZTc2NjNjODM1YTAiLCJhZ2VudElkIjoiY2U2MzI5OWItZTI3ZS00YjdhLTkyNjAtNDBiNGNhZmM1ODc0IiwiaWF0IjoxNzQ1NTMzNDE0LCJleHAiOjE3NDU1MzcwMTR9.C0EwW02BiojjjSM8Q5odTXOMu_ip8gKDDR-2WaCgYj8
        717	[requireAuth] Authenticated user: {
        718	  userId: '4becea93-e95b-4a50-8844-fe7663c835a0',
        719	  agentId: 'ce63299b-e27e-4b7a-9260-40b4cafc5874',
        720	  iat: 1745533414,
        721	  exp: 1745537014
        722	}
        723	[AgentMe] GET /api/agents/me called
        724	[DEBUG_COLOR] /me endpoint - Agent color value: #000000
        725	[AgentMe] Returning personalized agent for userId: 4becea93-e95b-4a50-8844-fe7663c835a0, agentId: ce63299b-e27e-4b7a-9260-40b4cafc5874
        726	[DEBUG_COLOR] /me endpoint - Full agent object: {"id":"ce63299b-e27e-4b7a-9260-40b4cafc5874","name":"Prax","color":"#000000","onboardingCompleted":true}
        727	
        728	
        729	[OnboardingChat] Initial agent fetch - onboardingCompleted status: false
        730	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: [{…}] agentName: asdqn2
        731	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: []
        732	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['d400537f-8bb0-4949-8a19-aa41e63ab1c3'] Updated messages: ['d400537f-8bb0-4949-8a19-aa41e63ab1c3']
        733	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: [{…}] agentName: asdqn2
        734	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: ['d400537f-8bb0-4949-8a19-aa41e63ab1c3']
        735	ChatInterface.tsx:105 [ChatInterface] Appending new messages: [] Updated messages: ['d400537f-8bb0-4949-8a19-aa41e63ab1c3']
        736	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: ['d400537f-8bb0-4949-8a19-aa41e63ab1c3']
        737	ChatInterface.tsx:105 [ChatInterface] Appending new messages: [] Updated messages: ['d400537f-8bb0-4949-8a19-aa41e63ab1c3']
        738	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (2) [{…}, {…}] agentName: asdqn2
        739	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: ['d400537f-8bb0-4949-8a19-aa41e63ab1c3']
        740	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533419308'] Updated messages: (2) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', 'temp-1745533419308']
        741	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: ['d400537f-8bb0-4949-8a19-aa41e63ab1c3']
        742	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533419308'] Updated messages: (2) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', 'temp-1745533419308']
        743	OnboardingChat.tsx:334 [OnboardingChat] Checking onboarding completion flags: {dataCompletedFlag: false, step: 0, nextStep: 1, messageMetadata: {…}}
        744	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (3) [{…}, {…}, {…}] agentName: asdqn2
        745	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (2) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', 'temp-1745533419308']
        746	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508'] Updated messages: (3) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508']
        747	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (2) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', 'temp-1745533419308']
        748	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508'] Updated messages: (3) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508']
        749	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (4) [{…}, {…}, {…}, {…}] agentName: asdqn2
        750	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (3) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508']
        751	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533425916'] Updated messages: (4) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'temp-1745533425916']
        752	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (3) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508']
        753	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533425916'] Updated messages: (4) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'temp-1745533425916']
        754	OnboardingChat.tsx:334 [OnboardingChat] Checking onboarding completion flags: {dataCompletedFlag: false, step: 1, nextStep: 2, messageMetadata: {…}}
        755	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (5) [{…}, {…}, {…}, {…}, {…}] agentName: Prax
        756	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (4) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'temp-1745533425916']
        757	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e'] Updated messages: (5) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e']
        758	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (4) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'temp-1745533425916']
        759	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e'] Updated messages: (5) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e']
        760	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (6) [{…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        761	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (5) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e']
        762	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533431926'] Updated messages: (6) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'temp-1745533431926']
        763	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (5) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e']
        764	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533431926'] Updated messages: (6) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'temp-1745533431926']
        765	OnboardingChat.tsx:267 [OnboardingChat] Received issuesMatrix from backend: [{"id":"1","title":"Water-Treatment Plant Funding Gap","reason":"","stance":null,"summary":"","isPriority":false,"description":"Issue a 25-year municipal revenue bond and raise residential water rates 12% to close the $50M shortfall after FEMA's BRIC grant was cancelled."},{"id":"3","title":"Wildfire-Risk Utility Surcharge","reason":"","stance":null,"summary":"","isPriority":false,"description":"Endorse Pacific Power's plan to add a temporary $2/month surcharge to speed undergrounding and covered-conductor projects (500 mi planned, 100 mi in 2025)."},{"id":"4","title":"Transportation System Plan (TSP) Priority Package","reason":"","stance":null,"summary":"","isPriority":false,"description":"Adopt the TSP's \"Active Streets\" scenario, reallocating $5M from road-widening to bike & sidewalk links near two I-5 interchanges."}]
        766	OnboardingChat.tsx:280 [OnboardingChat] Updated issue matrix: [{"id":"1","title":"Water-Treatment Plant Funding Gap","stance":null,"reason":"","description":"Issue a 25-year municipal revenue bond and raise residential water rates 12% to close the $50M shortfall after FEMA's BRIC grant was cancelled.","isPriority":false},{"id":"3","title":"Wildfire-Risk Utility Surcharge","stance":null,"reason":"","description":"Endorse Pacific Power's plan to add a temporary $2/month surcharge to speed undergrounding and covered-conductor projects (500 mi planned, 100 mi in 2025).","isPriority":false},{"id":"4","title":"Transportation System Plan (TSP) Priority Package","stance":null,"reason":"","description":"Adopt the TSP's \"Active Streets\" scenario, reallocating $5M from road-widening to bike & sidewalk links near two I-5 interchanges.","isPriority":false}]
        767	OnboardingChat.tsx:334 [OnboardingChat] Checking onboarding completion flags: {dataCompletedFlag: false, step: 2, nextStep: 3, messageMetadata: {…}}
        768	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (7) [{…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        769	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (6) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'temp-1745533431926']
        770	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['d3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545'] Updated messages: (7) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545']
        771	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (6) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'temp-1745533431926']
        772	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['d3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545'] Updated messages: (7) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545']
        773	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (8) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        774	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (7) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545']
        775	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533443062'] Updated messages: (8) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'temp-1745533443062']
        776	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (7) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545']
        777	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533443062'] Updated messages: (8) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'temp-1745533443062']
        778	OnboardingChat.tsx:267 [OnboardingChat] Received issuesMatrix from backend: [{"id":"1","title":"Water-Treatment Plant Funding Gap","reason":"Safe water is non-negotiable; bite the bullet now.","stance":"A","summary":"Safe water is non-negotiable; bite the bullet now.","isPriority":false,"description":"Issue a 25-year municipal revenue bond and raise residential water rates 12% to close the $50M shortfall after FEMA's BRIC grant was cancelled."},{"id":"3","title":"Wildfire-Risk Utility Surcharge","reason":"","stance":null,"summary":"","isPriority":false,"description":"Endorse Pacific Power's plan to add a temporary $2/month surcharge to speed undergrounding and covered-conductor projects (500 mi planned, 100 mi in 2025)."},{"id":"4","title":"Transportation System Plan (TSP) Priority Package","reason":"","stance":null,"summary":"","isPriority":false,"description":"Adopt the TSP's \"Active Streets\" scenario, reallocating $5M from road-widening to bike & sidewalk links near two I-5 interchanges."}]
        779	OnboardingChat.tsx:280 [OnboardingChat] Updated issue matrix: [{"id":"1","title":"Water-Treatment Plant Funding Gap","stance":"A","reason":"Safe water is non-negotiable; bite the bullet now.","description":"Issue a 25-year municipal revenue bond and raise residential water rates 12% to close the $50M shortfall after FEMA's BRIC grant was cancelled.","isPriority":false},{"id":"3","title":"Wildfire-Risk Utility Surcharge","stance":null,"reason":"","description":"Endorse Pacific Power's plan to add a temporary $2/month surcharge to speed undergrounding and covered-conductor projects (500 mi planned, 100 mi in 2025).","isPriority":false},{"id":"4","title":"Transportation System Plan (TSP) Priority Package","stance":null,"reason":"","description":"Adopt the TSP's \"Active Streets\" scenario, reallocating $5M from road-widening to bike & sidewalk links near two I-5 interchanges.","isPriority":false}]
        780	OnboardingChat.tsx:334 [OnboardingChat] Checking onboarding completion flags: {dataCompletedFlag: false, step: 3, nextStep: 3, messageMetadata: {…}}
        781	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (9) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        782	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (8) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'temp-1745533443062']
        783	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6'] Updated messages: (9) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6']
        784	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (8) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'temp-1745533443062']
        785	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6'] Updated messages: (9) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6']
        786	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        787	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (9) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6']
        788	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533447197'] Updated messages: (10) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', 'temp-1745533447197']
        789	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (9) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6']
        790	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533447197'] Updated messages: (10) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', 'temp-1745533447197']
        791	OnboardingChat.tsx:267 [OnboardingChat] Received issuesMatrix from backend: [{"id":"1","title":"Water-Treatment Plant Funding Gap","reason":"Safe water is non-negotiable; bite the bullet now.","stance":"A","summary":"Safe water is non-negotiable; bite the bullet now.","isPriority":false,"description":"Issue a 25-year municipal revenue bond and raise residential water rates 12% to close the $50M shortfall after FEMA's BRIC grant was cancelled."},{"id":"3","title":"Wildfire-Risk Utility Surcharge","reason":"Favor, emphasize tourism reliability.","stance":"C","summary":"Favor, emphasize tourism reliability.","isPriority":false,"description":"Endorse Pacific Power's plan to add a temporary $2/month surcharge to speed undergrounding and covered-conductor projects (500 mi planned, 100 mi in 2025)."},{"id":"4","title":"Transportation System Plan (TSP) Priority Package","reason":"","stance":null,"summary":"","isPriority":false,"description":"Adopt the TSP's \"Active Streets\" scenario, reallocating $5M from road-widening to bike & sidewalk links near two I-5 interchanges."}]
        792	OnboardingChat.tsx:280 [OnboardingChat] Updated issue matrix: [{"id":"1","title":"Water-Treatment Plant Funding Gap","stance":"A","reason":"Safe water is non-negotiable; bite the bullet now.","description":"Issue a 25-year municipal revenue bond and raise residential water rates 12% to close the $50M shortfall after FEMA's BRIC grant was cancelled.","isPriority":false},{"id":"3","title":"Wildfire-Risk Utility Surcharge","stance":"C","reason":"Favor, emphasize tourism reliability.","description":"Endorse Pacific Power's plan to add a temporary $2/month surcharge to speed undergrounding and covered-conductor projects (500 mi planned, 100 mi in 2025).","isPriority":false},{"id":"4","title":"Transportation System Plan (TSP) Priority Package","stance":null,"reason":"","description":"Adopt the TSP's \"Active Streets\" scenario, reallocating $5M from road-widening to bike & sidewalk links near two I-5 interchanges.","isPriority":false}]
        793	OnboardingChat.tsx:334 [OnboardingChat] Checking onboarding completion flags: {dataCompletedFlag: false, step: 3, nextStep: 3, messageMetadata: {…}}
        794	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (11) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        795	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (10) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', 'temp-1745533447197']
        796	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c'] Updated messages: (11) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c']
        797	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (10) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', 'temp-1745533447197']
        798	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c'] Updated messages: (11) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c']
        799	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (12) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        800	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (11) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c']
        801	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533482361'] Updated messages: (12) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'temp-1745533482361']
        802	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (11) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c']
        803	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533482361'] Updated messages: (12) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'temp-1745533482361']
        804	OnboardingChat.tsx:267 [OnboardingChat] Received issuesMatrix from backend: [{"id":"1","title":"Water-Treatment Plant Funding Gap","reason":"Safe water is non-negotiable; bite the bullet now.","stance":"A","summary":"Safe water is non-negotiable; bite the bullet now.","isPriority":false,"description":"Issue a 25-year municipal revenue bond and raise residential water rates 12% to close the $50M shortfall after FEMA's BRIC grant was cancelled."},{"id":"3","title":"Wildfire-Risk Utility Surcharge","reason":"Favor, emphasize tourism reliability.","stance":"C","summary":"Favor, emphasize tourism reliability.","isPriority":false,"description":"Endorse Pacific Power's plan to add a temporary $2/month surcharge to speed undergrounding and covered-conductor projects (500 mi planned, 100 mi in 2025)."},{"id":"4","title":"Transportation System Plan (TSP) Priority Package","reason":"+ C","stance":"B","summary":"Oppose—predict worse congestion.","isPriority":false,"description":"Adopt the TSP's \"Active Streets\" scenario, reallocating $5M from road-widening to bike & sidewalk links near two I-5 interchanges."}]
        805	OnboardingChat.tsx:280 [OnboardingChat] Updated issue matrix: [{"id":"1","title":"Water-Treatment Plant Funding Gap","stance":"A","reason":"Safe water is non-negotiable; bite the bullet now.","description":"Issue a 25-year municipal revenue bond and raise residential water rates 12% to close the $50M shortfall after FEMA's BRIC grant was cancelled.","isPriority":false},{"id":"3","title":"Wildfire-Risk Utility Surcharge","stance":"C","reason":"Favor, emphasize tourism reliability.","description":"Endorse Pacific Power's plan to add a temporary $2/month surcharge to speed undergrounding and covered-conductor projects (500 mi planned, 100 mi in 2025).","isPriority":false},{"id":"4","title":"Transportation System Plan (TSP) Priority Package","stance":"B","reason":"+ C","description":"Adopt the TSP's \"Active Streets\" scenario, reallocating $5M from road-widening to bike & sidewalk links near two I-5 interchanges.","isPriority":false}]
        806	OnboardingChat.tsx:334 [OnboardingChat] Checking onboarding completion flags: {dataCompletedFlag: false, step: 3, nextStep: 4, messageMetadata: {…}}
        807	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (13) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        808	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (12) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'temp-1745533482361']
        809	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['d5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3'] Updated messages: (13) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3']
        810	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (12) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'temp-1745533482361']
        811	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['d5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3'] Updated messages: (13) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3']
        812	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (14) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        813	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (13) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3']
        814	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533486528'] Updated messages: (14) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'temp-1745533486528']
        815	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (13) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3']
        816	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533486528'] Updated messages: (14) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'temp-1745533486528']
        817	OnboardingChat.tsx:334 [OnboardingChat] Checking onboarding completion flags: {dataCompletedFlag: false, step: 4, nextStep: 5, messageMetadata: {…}}
        818	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (15) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        819	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (14) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'temp-1745533486528']
        820	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198'] Updated messages: (15) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198']
        821	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (14) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'temp-1745533486528']
        822	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198'] Updated messages: (15) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198']
        823	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (16) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        824	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (15) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198']
        825	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533490790'] Updated messages: (16) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', 'temp-1745533490790']
        826	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (15) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198']
        827	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533490790'] Updated messages: (16) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', 'temp-1745533490790']
        828	OnboardingChat.tsx:334 [OnboardingChat] Checking onboarding completion flags: {dataCompletedFlag: false, step: 5, nextStep: 6, messageMetadata: {…}}
        829	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (17) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        830	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (16) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', 'temp-1745533490790']
        831	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5'] Updated messages: (17) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', '90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5']
        832	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (16) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', 'temp-1745533490790']
        833	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5'] Updated messages: (17) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', '90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5']
        834	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (18) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        835	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (17) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', '90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5']
        836	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533494750'] Updated messages: (18) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', '90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5', 'temp-1745533494750']
        837	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (17) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', '90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5']
        838	ChatInterface.tsx:105 [ChatInterface] Appending new messages: ['temp-1745533494750'] Updated messages: (18) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', '90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5', 'temp-1745533494750']
        839	OnboardingChat.tsx:334 [OnboardingChat] Checking onboarding completion flags: {dataCompletedFlag: false, step: 6, nextStep: 7, messageMetadata: {…}}
        840	ChatInterface.tsx:91 [ChatInterface] useEffect [newMessages] triggered. newMessages: (19) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}] agentName: Prax
        841	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (18) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', '90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5', 'temp-1745533494750']
        842	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['71d91d83-9ff5-459c-b92f-2917bbf588f4', '50cc9b8b-c849-47ba-813e-a927246e0be2'] Updated messages: (19) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', '90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5', '71d91d83-9ff5-459c-b92f-2917bbf588f4', '50cc9b8b-c849-47ba-813e-a927246e0be2']
        843	ChatInterface.tsx:94 [ChatInterface] Before appending newMessages: (18) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', '90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5', 'temp-1745533494750']
        844	ChatInterface.tsx:105 [ChatInterface] Appending new messages: (2) ['71d91d83-9ff5-459c-b92f-2917bbf588f4', '50cc9b8b-c849-47ba-813e-a927246e0be2'] Updated messages: (19) ['d400537f-8bb0-4949-8a19-aa41e63ab1c3', '140ca17a-1020-4a6e-b258-9a2a40e5f8dc', '739cd5e5-019a-4760-a5e1-92da59023508', 'c2f18741-26e0-40c3-a8ab-4580a839ea80', 'b7e092b9-3942-41fe-9791-d7066a73689e', 'd3da3efa-aefa-4b2e-8ed1-1cc5f0b10e55', 'f7d86b49-490c-4eef-adf2-8a0165fc4545', 'bb5d59d9-314b-443c-93d4-648473708a39', 'a04ca1d6-bea7-4839-8f15-720c0ed97dd6', '5123b855-65ac-4882-a7b1-ea5f4dc7db33', 'a73c4428-2aed-4fdf-b043-f579d051779c', 'd5354eb8-3327-41a1-80ab-a96100f9fcd9', 'c2c8d72b-f7fa-494f-ba57-ff80dc99e5a3', 'bfaa802a-cb9f-4425-b930-81c90efbf4af', '331aa36f-d34f-4355-9bdd-536da2015198', '90b08857-623c-4137-bab3-bd721e3aa5a9', '80f97f1e-afd8-4b90-9ac6-50ca98ca68a5', '71d91d83-9ff5-459c-b92f-2917bbf588f4', '50cc9b8b-c849-47ba-813e-a927246e0be2']

==============================================
FILE: ./openrouterdocs.md
==============================================

          1	# Quickstart
          2	
          3	> Get started with OpenRouter's unified API for hundreds of AI models. Learn how to integrate using OpenAI SDK, direct API calls, or third-party frameworks.
          4	
          5	OpenRouter provides a unified API that gives you access to hundreds of AI models through a single endpoint, while automatically handling fallbacks and selecting the most cost-effective options. Get started with just a few lines of code using your preferred SDK or framework.
          6	
          7	<Tip>
          8	  Want to chat with our docs? Download an LLM-friendly text file of our [full
          9	  documentation](/docs/llms-full.txt) and include it in your system prompt.
         10	</Tip>
         11	
         12	In the examples below, the OpenRouter-specific headers are optional. Setting them allows your app to appear on the OpenRouter leaderboards.
         13	
         14	## Using the OpenAI SDK
         15	
         16	<CodeGroup>
         17	  ```python title="Python"
         18	  from openai import OpenAI
         19	
         20	  client = OpenAI(
         21	    base_url="https://openrouter.ai/api/v1",
         22	    api_key="<OPENROUTER_API_KEY>",
         23	  )
         24	
         25	  completion = client.chat.completions.create(
         26	    extra_headers={
         27	      "HTTP-Referer": "<YOUR_SITE_URL>", # Optional. Site URL for rankings on openrouter.ai.
         28	      "X-Title": "<YOUR_SITE_NAME>", # Optional. Site title for rankings on openrouter.ai.
         29	    },
         30	    model="openai/gpt-4o",
         31	    messages=[
         32	      {
         33	        "role": "user",
         34	        "content": "What is the meaning of life?"
         35	      }
         36	    ]
         37	  )
         38	
         39	  print(completion.choices[0].message.content)
         40	  ```
         41	
         42	  ```typescript title="TypeScript"
         43	  import OpenAI from 'openai';
         44	
         45	  const openai = new OpenAI({
         46	    baseURL: 'https://openrouter.ai/api/v1',
         47	    apiKey: '<OPENROUTER_API_KEY>',
         48	    defaultHeaders: {
         49	      'HTTP-Referer': '<YOUR_SITE_URL>', // Optional. Site URL for rankings on openrouter.ai.
         50	      'X-Title': '<YOUR_SITE_NAME>', // Optional. Site title for rankings on openrouter.ai.
         51	    },
         52	  });
         53	
         54	  async function main() {
         55	    const completion = await openai.chat.completions.create({
         56	      model: 'openai/gpt-4o',
         57	      messages: [
         58	        {
         59	          role: 'user',
         60	          content: 'What is the meaning of life?',
         61	        },
         62	      ],
         63	    });
         64	
         65	    console.log(completion.choices[0].message);
         66	  }
         67	
         68	  main();
         69	  ```
         70	</CodeGroup>
         71	
         72	## Using the OpenRouter API directly
         73	
         74	<CodeGroup>
         75	  ```python title="Python"
         76	  import requests
         77	  import json
         78	
         79	  response = requests.post(
         80	    url="https://openrouter.ai/api/v1/chat/completions",
         81	    headers={
         82	      "Authorization": "Bearer <OPENROUTER_API_KEY>",
         83	      "HTTP-Referer": "<YOUR_SITE_URL>", # Optional. Site URL for rankings on openrouter.ai.
         84	      "X-Title": "<YOUR_SITE_NAME>", # Optional. Site title for rankings on openrouter.ai.
         85	    },
         86	    data=json.dumps({
         87	      "model": "openai/gpt-4o", # Optional
         88	      "messages": [
         89	        {
         90	          "role": "user",
         91	          "content": "What is the meaning of life?"
         92	        }
         93	      ]
         94	    })
         95	  )
         96	  ```
         97	
         98	  ```typescript title="TypeScript"
         99	  fetch('https://openrouter.ai/api/v1/chat/completions', {
        100	    method: 'POST',
        101	    headers: {
        102	      Authorization: 'Bearer <OPENROUTER_API_KEY>',
        103	      'HTTP-Referer': '<YOUR_SITE_URL>', // Optional. Site URL for rankings on openrouter.ai.
        104	      'X-Title': '<YOUR_SITE_NAME>', // Optional. Site title for rankings on openrouter.ai.
        105	      'Content-Type': 'application/json',
        106	    },
        107	    body: JSON.stringify({
        108	      model: 'openai/gpt-4o',
        109	      messages: [
        110	        {
        111	          role: 'user',
        112	          content: 'What is the meaning of life?',
        113	        },
        114	      ],
        115	    }),
        116	  });
        117	  ```
        118	
        119	  ```shell title="Shell"
        120	  curl https://openrouter.ai/api/v1/chat/completions \
        121	    -H "Content-Type: application/json" \
        122	    -H "Authorization: Bearer $OPENROUTER_API_KEY" \
        123	    -d '{
        124	    "model": "openai/gpt-4o",
        125	    "messages": [
        126	      {
        127	        "role": "user",
        128	        "content": "What is the meaning of life?"
        129	      }
        130	    ]
        131	  }'
        132	  ```
        133	</CodeGroup>
        134	
        135	The API also supports [streaming](/docs/api-reference/streaming).
        136	
        137	## Using third-party SDKs
        138	
        139	For information about using third-party SDKs and frameworks with OpenRouter, please [see our frameworks documentation.](/docs/community/frameworks)
        140	
        141	
        142	# Frequently Asked Questions
        143	
        144	> Find answers to commonly asked questions about OpenRouter's unified API, model access, pricing, and integration.
        145	
        146	## Getting started
        147	
        148	<AccordionGroup>
        149	  <Accordion title="Why should I use OpenRouter?">
        150	    OpenRouter provides a unified API to access all the major LLM models on the
        151	    market. It also allows users to aggregate their billing in one place and
        152	    keep track of all of their usage using our analytics.
        153	
        154	    OpenRouter passes through the pricing of the underlying providers, while pooling their uptime,
        155	    so you get the same pricing you'd get from the provider directly, with a
        156	    unified API and fallbacks so that you get much better uptime.
        157	  </Accordion>
        158	
        159	  <Accordion title="How do I get started with OpenRouter?">
        160	    To get started, create an account and add credits on the
        161	    [Credits](https://openrouter.ai/settings/credits) page. Credits are simply
        162	    deposits on OpenRouter that you use for LLM inference.
        163	    When you use the API or chat interface, we deduct the request cost from your
        164	    credits. Each model and provider has a different price per million tokens.
        165	
        166	    Once you have credits you can either use the chat room, or create API keys
        167	    and start using the API. You can read our [quickstart](/docs/quickstart)
        168	    guide for code samples and more.
        169	  </Accordion>
        170	
        171	  <Accordion title="How do I get support?">
        172	    The best way to get support is to join our
        173	    [Discord](https://discord.gg/fVyRaUDgxW) and ping us in the #help forum.
        174	  </Accordion>
        175	
        176	  <Accordion title="How do I get billed for my usage on OpenRouter?">
        177	    For each model we have the pricing displayed per million tokens. There is
        178	    usually a different price for prompt and completion tokens. There are also
        179	    models that charge per request, for images and for reasoning tokens. All of
        180	    these details will be visible on the models page.
        181	
        182	    When you make a request to OpenRouter, we receive the total number of tokens processed
        183	    by the provider. We then calculate the corresponding cost and deduct it from your credits.
        184	    You can review your complete usage history in the [Activity tab](https://openrouter.ai/activity).
        185	
        186	    You can also add the `usage: {include: true}` parameter to your chat request
        187	    to get the usage information in the response.
        188	
        189	    We pass through the pricing of the underlying providers; there is no markup
        190	    on inference pricing (however we do charge a [fee](https://openrouter.ai/terms#_4_-payment) when purchasing credits).
        191	  </Accordion>
        192	</AccordionGroup>
        193	
        194	## Models and Providers
        195	
        196	<AccordionGroup>
        197	  <Accordion title="What LLM models does OpenRouter support?">
        198	    OpenRouter provides access to a wide variety of LLM models, including frontier models from major AI labs.
        199	    For a complete list of models you can visit the [models browser](https://openrouter.ai/models) or fetch the list through the [models api](https://openrouter.ai/api/v1/models).
        200	  </Accordion>
        201	
        202	  <Accordion title="How frequently are new models added?">
        203	    We work on adding models as quickly as we can. We often have partnerships with
        204	    the labs releasing models and can release models as soon as they are
        205	    available. If there is a model missing that you'd like OpenRouter to support, feel free to message us on
        206	    [Discord](https://discord.gg/fVyRaUDgxW).
        207	  </Accordion>
        208	
        209	  <Accordion title="What are model variants?">
        210	    Variants are suffixes that can be added to the model slug to change its behavior.
        211	
        212	    Static variants can only be used with specific models and these are listed in our [models api](https://openrouter.ai/api/v1/models).
        213	
        214	    1. `:free` - The model is always provided for free and has low rate limits.
        215	    2. `:beta` - The model is not moderated by OpenRouter.
        216	    3. `:extended` - The model has longer than usual context length.
        217	    4. `:thinking` - The model supports reasoning by default.
        218	
        219	    Dynamic variants can be used on all models and they change the behavior of how the request is routed or used.
        220	
        221	    1. `:online` - All requests will run a query to extract web results that are attached to the prompt.
        222	    2. `:nitro` - Providers will be sorted by throughput rather than the default sort, optimizing for faster response times.
        223	    3. `:floor` - Providers will be sorted by price rather than the default sort, prioritizing the most cost-effective options.
        224	  </Accordion>
        225	
        226	  <Accordion title="I am an inference provider, how can I get listed on OpenRouter?">
        227	    You can read our requirements at the [Providers
        228	    page](/docs/use-cases/for-providers). If you would like to contact us, the best
        229	    place to reach us is over email.
        230	  </Accordion>
        231	
        232	  <Accordion title="What is the expected latency/response time for different models?">
        233	    For each model on OpenRouter we show the latency (time to first token) and the token
        234	    throughput for all providers. You can use this to estimate how long requests
        235	    will take. If you would like to optimize for throughput you can use the
        236	    `:nitro` variant to route to the fastest provider.
        237	  </Accordion>
        238	
        239	  <Accordion title="How does model fallback work if a provider is unavailable?">
        240	    If a provider returns an error OpenRouter will automatically fall back to the
        241	    next provider. This happens transparently to the user and allows production
        242	    apps to be much more resilient. OpenRouter has a lot of options to configure
        243	    the provider routing behavior. The full documentation can be found [here](/docs/features/provider-routing).
        244	  </Accordion>
        245	</AccordionGroup>
        246	
        247	## API Technical Specifications
        248	
        249	<AccordionGroup>
        250	  <Accordion title="What authentication methods are supported?">
        251	    OpenRouter uses three authentication methods:
        252	
        253	    1. Cookie-based authentication for the web interface and chatroom
        254	    2. API keys (passed as Bearer tokens) for accessing the completions API and other core endpoints
        255	    3. [Provisioning API keys](/docs/features/provisioning-api-keys) for programmatically managing API keys through the key management endpoints
        256	  </Accordion>
        257	
        258	  <Accordion title="How are rate limits calculated?">
        259	    For free models, rate limits are determined by the credits that you have purchased. If you have
        260	    total credits purchased lower than {FREE_MODEL_CREDITS_THRESHOLD} credits, you will be rate limited to {FREE_MODEL_NO_CREDITS_RPD} requests per day.
        261	    If you have purchased at least {FREE_MODEL_CREDITS_THRESHOLD} credits, you will be rate limited to {FREE_MODEL_HAS_CREDITS_RPD} requests per day.
        262	
        263	    For all other models, rate limits are determined by the credits in your account. You can read more
        264	    details in our [rate limits documentation](/docs/api-reference/limits).
        265	  </Accordion>
        266	
        267	  <Accordion title="What API endpoints are available?">
        268	    OpenRouter implements the OpenAI API specification for /completions and
        269	    /chat/completions endpoints, allowing you to use any model with the same
        270	    request/response format. Additional endpoints like /api/v1/models are also
        271	    available. See our [API documentation](/docs/api-reference/overview) for
        272	    detailed specifications.
        273	  </Accordion>
        274	
        275	  <Accordion title="What are the supported formats?">
        276	    The API supports text and images.
        277	    [Images](/docs/api-reference/overview#images--multimodal) can be passed as
        278	    URLs or base64 encoded images. PDF and other file types are coming soon.
        279	  </Accordion>
        280	
        281	  <Accordion title="How does streaming work?">
        282	    Streaming uses server-sent events (SSE) for real-time token delivery. Set
        283	    `stream: true` in your request to enable streaming responses.
        284	  </Accordion>
        285	
        286	  <Accordion title="What SDK support is available?">
        287	    OpenRouter is a drop-in replacement for OpenAI. Therefore, any SDKs that
        288	    support OpenAI by default also support OpenRouter. Check out our
        289	    [docs](/docs/frameworks) for more details.
        290	  </Accordion>
        291	</AccordionGroup>
        292	
        293	## Privacy and Data Logging
        294	
        295	Please see our [Terms of Service](https://openrouter.ai/terms) and [Privacy Policy](https://openrouter.ai/privacy).
        296	
        297	<AccordionGroup>
        298	  <Accordion title="What data is logged during API use?">
        299	    We log basic request metadata (timestamps, model used, token counts). Prompt
        300	    and completion are not logged by default. We do zero logging of your prompts/completions,
        301	    even if an error occurs, unless you opt-in to logging them.
        302	
        303	    We have an opt-in [setting](https://openrouter.ai/settings/privacy) that
        304	    lets users opt-in to log their prompts and completions in exchange for a 1%
        305	    discount on usage costs.
        306	  </Accordion>
        307	
        308	  <Accordion title="What data is logged during Chatroom use?">
        309	    The same data privacy applies to the chatroom as the API. All conversations
        310	    in the chatroom are stored locally on your device. Conversations will not sync across devices.
        311	    It is possible to export and import conversations using the settings menu in the chatroom.
        312	  </Accordion>
        313	
        314	  <Accordion title="What third-party sharing occurs?">
        315	    OpenRouter is a proxy that sends your requests to the model provider for it to be completed.
        316	    We work with all providers to, when possible, ensure that prompts and completions are not logged or used for training.
        317	    Providers that do log, or where we have been unable to confirm their policy, will not be routed to unless the model training
        318	    toggle is switched on in the [privacy settings](https://openrouter.ai/settings/privacy) tab.
        319	
        320	    If you specify [provider routing](/docs/features/provider-routing) in your request, but none of the providers
        321	    match the level of privacy specified in your account settings, you will get an error and your request will not complete.
        322	  </Accordion>
        323	</AccordionGroup>
        324	
        325	## Credit and Billing Systems
        326	
        327	<AccordionGroup>
        328	  <Accordion title="What purchase options exist?">
        329	    OpenRouter uses a credit system where the base currency is US dollars. All
        330	    of the pricing on our site and API is denoted in dollars. Users can top up
        331	    their balance manually or set up auto top up so that the balance is
        332	    replenished when it gets below the set threshold.
        333	  </Accordion>
        334	
        335	  <Accordion title="Do credits expire?">
        336	    Per our [terms](https://openrouter.ai/terms), we reserve the right to expire
        337	    unused credits after one year of purchase.
        338	  </Accordion>
        339	
        340	  <Accordion title="My credits haven't showed up in my account">
        341	    If you paid using Stripe, sometimes there is an issue with the Stripe
        342	    integration and credits can get delayed in showing up on your account. Please allow up to one hour.
        343	    If your credits still have not appeared after an hour, contact us on [Discord](https://discord.gg/fVyRaUDgxW) and we will
        344	    look into it.
        345	
        346	    If you paid using crypto, please reach out to us on [Discord](https://discord.gg/fVyRaUDgxW)
        347	    and we will look into it.
        348	  </Accordion>
        349	
        350	  <Accordion title="What's the refund policy?">
        351	    Refunds for unused Credits may be requested within twenty-four (24) hours from the time the transaction was processed. If no refund request is received within twenty-four (24) hours following the purchase, any unused Credits become non-refundable. To request a refund within the eligible period, you must email OpenRouter at [support@openrouter.ai](mailto:support@openrouter.ai). The unused credit amount will be refunded to your payment method; the platform fees are non-refundable. Note that cryptocurrency payments are never refundable.
        352	  </Accordion>
        353	
        354	  <Accordion title="How to monitor credit usage?">
        355	    The [Activity](https://openrouter.ai/activity) page allows users to view
        356	    their historic usage and filter the usage by model, provider and api key.
        357	
        358	    We also provide a [credits api](/docs/api-reference/get-credits) that has
        359	    live information about the balance and remaining credits for the account.
        360	  </Accordion>
        361	
        362	  <Accordion title="What free tier options exist?">
        363	    All new users receive a very small free allowance to be able to test out OpenRouter.
        364	    There are many [free models](https://openrouter.ai/models?max_price=0) available
        365	    on OpenRouter, it is important to note that these models have low rate limits ({FREE_MODEL_NO_CREDITS_RPD} requests per day total)
        366	    and are usually not suitable for production use. If you have purchased at least {FREE_MODEL_CREDITS_THRESHOLD} credits,
        367	    the free models will be limited to {FREE_MODEL_HAS_CREDITS_RPD} requests per day.
        368	  </Accordion>
        369	
        370	  <Accordion title="How do volume discounts work?">
        371	    OpenRouter does not currently offer volume discounts, but you can reach out to us
        372	    over email if you think you have an exceptional use case.
        373	  </Accordion>
        374	
        375	  <Accordion title="What payment methods are accepted?">
        376	    We accept all major credit cards, AliPay and cryptocurrency payments in
        377	    USDC. We are working on integrating PayPal soon, if there are any payment
        378	    methods that you would like us to support please reach out on [Discord](https://discord.gg/fVyRaUDgxW).
        379	  </Accordion>
        380	
        381	  <Accordion title="How does OpenRouter make money?">
        382	    We charge a small [fee](https://openrouter.ai/terms#_4_-payment) when purchasing credits. We never mark-up the pricing
        383	    of the underlying providers, and you'll always pay the same as the provider's
        384	    listed price.
        385	  </Accordion>
        386	</AccordionGroup>
        387	
        388	## Account Management
        389	
        390	<AccordionGroup>
        391	  <Accordion title="How can I delete my account?">
        392	    Go to the [Settings](https://openrouter.ai/settings/preferences) page and click Manage Account.
        393	    In the modal that opens, select the Security tab. You'll find an option there to delete your account.
        394	
        395	    Note that unused credits will be lost and cannot be reclaimed if you delete and later recreate your account.
        396	  </Accordion>
        397	
        398	  <Accordion title="How does team access work?">
        399	    Team management is coming very soon! For now you can use [provisioning API
        400	    keys](/docs/features/provisioning-api-keys) to allow sharing credits with
        401	    people on your team.
        402	  </Accordion>
        403	
        404	  <Accordion title="What analytics are available?">
        405	    Our [activity dashboard](https://openrouter.ai/activity) provides real-time
        406	    usage metrics. If you would like any specific reports or metrics please
        407	    contact us.
        408	  </Accordion>
        409	
        410	  <Accordion title="How can I contact support?">
        411	    The best way to reach us is to join our
        412	    [Discord](https://discord.gg/fVyRaUDgxW) and ping us in the #help forum.
        413	  </Accordion>
        414	</AccordionGroup>
        415	
        416	
        417	# Principles
        418	
        419	> Learn about OpenRouter's guiding principles and mission. Understand our commitment to price optimization, standardized APIs, and high availability in AI model deployment.
        420	
        421	OpenRouter helps developers source and optimize AI usage. We believe the future is multi-model and multi-provider.
        422	
        423	## Why OpenRouter?
        424	
        425	**Price and Performance**. OpenRouter scouts for the best prices, the lowest latencies, and the highest throughput across dozens of providers, and lets you choose how to [prioritize](/docs/features/provider-routing) them.
        426	
        427	**Standardized API**. No need to change code when switching between models or providers. You can even let your users [choose and pay for their own](/docs/use-cases/oauth-pkce).
        428	
        429	**Real-World Insights**. Be the first to take advantage of new models. See real-world data of [how often models are used](https://openrouter.ai/rankings) for different purposes. Keep up to date in our [Discord channel](https://discord.com/channels/1091220969173028894/1094454198688546826).
        430	
        431	**Consolidated Billing**. Simple and transparent billing, regardless of how many providers you use.
        432	
        433	**Higher Availability**. Fallback providers, and automatic, smart routing means your requests still work even when providers go down.
        434	
        435	**Higher Rate Limits**. OpenRouter works directly with providers to provide better rate limits and more throughput.
        436	
        437	
        438	# Models
        439	
        440	> Access over 300 AI models through OpenRouter's unified API. Browse available models, compare capabilities, and integrate with your preferred provider.
        441	
        442	OpenRouter strives to provide access to every potentially useful text-based AI model. We currently support over 300 models endpoints.
        443	
        444	If there are models or providers you are interested in that OpenRouter doesn't have, please tell us about them in our [Discord channel](https://discord.gg/fVyRaUDgxW).
        445	
        446	<Note title="Different models tokenize text in different ways">
        447	  Some models break up text into chunks of multiple characters (GPT, Claude,
        448	  Llama, etc), while others tokenize by character (PaLM). This means that token
        449	  counts (and therefore costs) will vary between models, even when inputs and
        450	  outputs are the same. Costs are displayed and billed according to the
        451	  tokenizer for the model in use. You can use the `usage` field in the response
        452	  to get the token counts for the input and output.
        453	</Note>
        454	
        455	Explore and browse 300+ models and providers [on our website](https://openrouter.ai/models), or [with our API](/docs/api-reference/list-available-models).
        456	
        457	## For Providers
        458	
        459	If you're interested in working with OpenRouter, you can learn more on our [providers page](/docs/use-cases/for-providers).
        460	
        461	
        462	# Model Routing
        463	
        464	> Route requests dynamically between AI models. Learn how to use OpenRouter's Auto Router and model fallback features for optimal performance and reliability.
        465	
        466	OpenRouter provides two options for model routing.
        467	
        468	## Auto Router
        469	
        470	The [Auto Router](https://openrouter.ai/openrouter/auto), a special model ID that you can use to choose between selected high-quality models based on your prompt, powered by [NotDiamond](https://www.notdiamond.ai/).
        471	
        472	```json
        473	{
        474	  "model": "openrouter/auto",
        475	  ... // Other params
        476	}
        477	```
        478	
        479	The resulting generation will have `model` set to the model that was used.
        480	
        481	## The `models` parameter
        482	
        483	The `models` parameter lets you automatically try other models if the primary model's providers are down, rate-limited, or refuse to reply due to content moderation.
        484	
        485	```json
        486	{
        487	  "models": ["anthropic/claude-3.5-sonnet", "gryphe/mythomax-l2-13b"],
        488	  ... // Other params
        489	}
        490	```
        491	
        492	If the model you selected returns an error, OpenRouter will try to use the fallback model instead. If the fallback model is down or returns an error, OpenRouter will return that error.
        493	
        494	By default, any error can trigger the use of a fallback model, including context length validation errors, moderation flags for filtered models, rate-limiting, and downtime.
        495	
        496	Requests are priced using the model that was ultimately used, which will be returned in the `model` attribute of the response body.
        497	
        498	## Using with OpenAI SDK
        499	
        500	To use the `models` array with the OpenAI SDK, include it in the `extra_body` parameter. In the example below, gpt-4o will be tried first, and the `models` array will be tried in order as fallbacks.
        501	
        502	<Template
        503	  data={{
        504	  API_KEY_REF,
        505	}}
        506	>
        507	  <CodeGroup>
        508	    ```typescript
        509	    import OpenAI from 'openai';
        510	
        511	    const openrouterClient = new OpenAI({
        512	      baseURL: 'https://openrouter.ai/api/v1',
        513	      // API key and headers
        514	    });
        515	
        516	    async function main() {
        517	      // @ts-expect-error
        518	      const completion = await openrouterClient.chat.completions.create({
        519	        model: 'openai/gpt-4o',
        520	        models: ['anthropic/claude-3.5-sonnet', 'gryphe/mythomax-l2-13b'],
        521	        messages: [
        522	          {
        523	            role: 'user',
        524	            content: 'What is the meaning of life?',
        525	          },
        526	        ],
        527	      });
        528	      console.log(completion.choices[0].message);
        529	    }
        530	
        531	    main();
        532	    ```
        533	
        534	    ```python
        535	    from openai import OpenAI
        536	
        537	    openai_client = OpenAI(
        538	      base_url="https://openrouter.ai/api/v1",
        539	      api_key={{API_KEY_REF}},
        540	    )
        541	
        542	    completion = openai_client.chat.completions.create(
        543	        model="openai/gpt-4o",
        544	        extra_body={
        545	            "models": ["anthropic/claude-3.5-sonnet", "gryphe/mythomax-l2-13b"],
        546	        },
        547	        messages=[
        548	            {
        549	                "role": "user",
        550	                "content": "What is the meaning of life?"
        551	            }
        552	        ]
        553	    )
        554	
        555	    print(completion.choices[0].message.content)
        556	    ```
        557	  </CodeGroup>
        558	</Template>
        559	
        560	
        561	# Provider Routing
        562	
        563	> Route AI model requests across multiple providers intelligently. Learn how to optimize for cost, performance, and reliability with OpenRouter's provider routing.
        564	
        565	OpenRouter routes requests to the best available providers for your model. By default, [requests are load balanced](#load-balancing-default-strategy) across the top providers to maximize uptime.
        566	
        567	You can customize how your requests are routed using the `provider` object in the request body for [Chat Completions](/docs/api-reference/chat-completion) and [Completions](/docs/api-reference/completion).
        568	
        569	<Tip>
        570	  For a complete list of valid provider names to use in the API, see the [full
        571	  provider schema](#json-schema-for-provider-preferences).
        572	</Tip>
        573	
        574	The `provider` object can contain the following fields:
        575	
        576	| Field                | Type              | Default | Description                                                                                                                       |
        577	| -------------------- | ----------------- | ------- | --------------------------------------------------------------------------------------------------------------------------------- |
        578	| `order`              | string\[]         | -       | List of provider names to try in order (e.g. `["Anthropic", "OpenAI"]`). [Learn more](#ordering-specific-providers)               |
        579	| `allow_fallbacks`    | boolean           | `true`  | Whether to allow backup providers when the primary is unavailable. [Learn more](#disabling-fallbacks)                             |
        580	| `require_parameters` | boolean           | `false` | Only use providers that support all parameters in your request. [Learn more](#requiring-providers-to-support-all-parameters-beta) |
        581	| `data_collection`    | "allow" \| "deny" | "allow" | Control whether to use providers that may store data. [Learn more](#requiring-providers-to-comply-with-data-policies)             |
        582	| `ignore`             | string\[]         | -       | List of provider names to skip for this request. [Learn more](#ignoring-providers)                                                |
        583	| `quantizations`      | string\[]         | -       | List of quantization levels to filter by (e.g. `["int4", "int8"]`). [Learn more](#quantization)                                   |
        584	| `sort`               | string            | -       | Sort providers by price or throughput. (e.g. `"price"` or `"throughput"`). [Learn more](#provider-sorting)                        |
        585	
        586	## Price-Based Load Balancing (Default Strategy)
        587	
        588	For each model in your request, OpenRouter's default behavior is to load balance requests across providers, prioritizing price.
        589	
        590	If you are more sensitive to throughput than price, you can use the `sort` field to explicitly prioritize throughput.
        591	
        592	<Tip>
        593	  When you send a request with `tools` or `tool_choice`, OpenRouter will only
        594	  route to providers that support tool use. Similarly, if you set a
        595	  `max_tokens`, then OpenRouter will only route to providers that support a
        596	  response of that length.
        597	</Tip>
        598	
        599	Here is OpenRouter's default load balancing strategy:
        600	
        601	1. Prioritize providers that have not seen significant outages in the last 30 seconds.
        602	2. For the stable providers, look at the lowest-cost candidates and select one weighted by inverse square of the price (example below).
        603	3. Use the remaining providers as fallbacks.
        604	
        605	<Note title="A Load Balancing Example">
        606	  If Provider A costs \$1 per million tokens, Provider B costs \$2, and Provider C costs \$3, and Provider B recently saw a few outages.
        607	
        608	  * Your request is routed to Provider A. Provider A is 9x more likely to be first routed to Provider A than Provider C because $(1 / 3^2 = 1/9)$ (inverse square of the price).
        609	  * If Provider A fails, then Provider C will be tried next.
        610	  * If Provider C also fails, Provider B will be tried last.
        611	</Note>
        612	
        613	If you have `sort` or `order` set in your provider preferences, load balancing will be disabled.
        614	
        615	## Provider Sorting
        616	
        617	As described above, OpenRouter load balances based on price, while taking uptime into account.
        618	
        619	If you instead want to *explicitly* prioritize a particular provider attribute, you can include the `sort` field in the `provider` preferences. Load balancing will be disabled, and the router will try providers in order.
        620	
        621	The three sort options are:
        622	
        623	* `"price"`: prioritize lowest price
        624	* `"throughput"`: prioritize highest throughput
        625	* `"latency"`: prioritize lowest latency
        626	
        627	<TSFetchCodeBlock
        628	  title="Example with Fallbacks Enabled"
        629	  uriPath="/api/v1/chat/completions"
        630	  body={{
        631	    model: 'meta-llama/llama-3.1-70b-instruct',
        632	    messages: [{ role: 'user', content: 'Hello' }],
        633	    provider: {
        634	      sort: 'throughput',
        635	    },
        636	  }}
        637	/>
        638	
        639	To *always* prioritize low prices, and not apply any load balancing, set `sort` to `"price"`.
        640	
        641	To *always* prioritize low latency, and not apply any load balancing, set `sort` to `"latency"`.
        642	
        643	## Nitro Shortcut
        644	
        645	You can append `:nitro` to any model slug as a shortcut to sort by throughput. This is exactly equivalent to setting `provider.sort` to `"throughput"`.
        646	
        647	<TSFetchCodeBlock
        648	  title="Example using Nitro shortcut"
        649	  uriPath="/api/v1/chat/completions"
        650	  body={{
        651	    model: 'meta-llama/llama-3.1-70b-instruct:nitro',
        652	    messages: [{ role: 'user', content: 'Hello' }],
        653	  }}
        654	/>
        655	
        656	## Floor Price Shortcut
        657	
        658	You can append `:floor` to any model slug as a shortcut to sort by price. This is exactly equivalent to setting `provider.sort` to `"price"`.
        659	
        660	<TSFetchCodeBlock
        661	  title="Example using Floor shortcut"
        662	  uriPath="/api/v1/chat/completions"
        663	  body={{
        664	    model: 'meta-llama/llama-3.1-70b-instruct:floor',
        665	    messages: [{ role: 'user', content: 'Hello' }],
        666	  }}
        667	/>
        668	
        669	## Ordering Specific Providers
        670	
        671	You can set the providers that OpenRouter will prioritize for your request using the `order` field.
        672	
        673	| Field   | Type      | Default | Description                                                              |
        674	| ------- | --------- | ------- | ------------------------------------------------------------------------ |
        675	| `order` | string\[] | -       | List of provider names to try in order (e.g. `["Anthropic", "OpenAI"]`). |
        676	
        677	The router will prioritize providers in this list, and in this order, for the model you're using. If you don't set this field, the router will [load balance](#load-balancing-default-strategy) across the top providers to maximize uptime.
        678	
        679	OpenRouter will try them one at a time and proceed to other providers if none are operational. If you don't want to allow any other providers, you should [disable fallbacks](#disabling-fallbacks) as well.
        680	
        681	### Example: Specifying providers with fallbacks
        682	
        683	This example skips over OpenAI (which doesn't host Mixtral), tries Together, and then falls back to the normal list of providers on OpenRouter:
        684	
        685	<TSFetchCodeBlock
        686	  title="Example with Fallbacks Enabled"
        687	  uriPath="/api/v1/chat/completions"
        688	  body={{
        689	    model: 'mistralai/mixtral-8x7b-instruct',
        690	    messages: [{ role: 'user', content: 'Hello' }],
        691	    provider: {
        692	      order: ['OpenAI', 'Together'],
        693	    },
        694	  }}
        695	/>
        696	
        697	### Example: Specifying providers with fallbacks disabled
        698	
        699	Here's an example with `allow_fallbacks` set to `false` that skips over OpenAI (which doesn't host Mixtral), tries Together, and then fails if Together fails:
        700	
        701	<TSFetchCodeBlock
        702	  title="Example with Fallbacks Disabled"
        703	  uriPath="/api/v1/chat/completions"
        704	  body={{
        705	    model: 'mistralai/mixtral-8x7b-instruct',
        706	    messages: [{ role: 'user', content: 'Hello' }],
        707	    provider: {
        708	      order: ['OpenAI', 'Together'],
        709	      allow_fallbacks: false,
        710	    },
        711	  }}
        712	/>
        713	
        714	## Requiring Providers to Support All Parameters (beta)
        715	
        716	You can restrict requests only to providers that support all parameters in your request using the `require_parameters` field.
        717	
        718	| Field                | Type    | Default | Description                                                     |
        719	| -------------------- | ------- | ------- | --------------------------------------------------------------- |
        720	| `require_parameters` | boolean | `false` | Only use providers that support all parameters in your request. |
        721	
        722	With the default routing strategy, providers that don't support all the [LLM parameters](/docs/api-reference/parameters) specified in your request can still receive the request, but will ignore unknown parameters. When you set `require_parameters` to `true`, the request won't even be routed to that provider.
        723	
        724	### Example: Excluding providers that don't support JSON formatting
        725	
        726	For example, to only use providers that support JSON formatting:
        727	
        728	<TSFetchCodeBlock
        729	  uriPath="/api/v1/chat/completions"
        730	  body={{
        731	    messages: [{ role: 'user', content: 'Hello' }],
        732	    provider: {
        733	      require_parameters: true,
        734	    },
        735	    response_format: { type: 'json_object' },
        736	  }}
        737	/>
        738	
        739	## Requiring Providers to Comply with Data Policies
        740	
        741	You can restrict requests only to providers that comply with your data policies using the `data_collection` field.
        742	
        743	| Field             | Type              | Default | Description                                           |
        744	| ----------------- | ----------------- | ------- | ----------------------------------------------------- |
        745	| `data_collection` | "allow" \| "deny" | "allow" | Control whether to use providers that may store data. |
        746	
        747	* `allow`: (default) allow providers which store user data non-transiently and may train on it
        748	* `deny`: use only providers which do not collect user data
        749	
        750	Some model providers may log prompts, so we display them with a **Data Policy** tag on model pages. This is not a definitive source of third party data policies, but represents our best knowledge.
        751	
        752	<Tip title="Account-Wide Data Policy Filtering">
        753	  This is also available as an account-wide setting in [your privacy
        754	  settings](https://openrouter.ai/settings/privacy). You can disable third party
        755	  model providers that store inputs for training.
        756	</Tip>
        757	
        758	### Example: Excluding providers that don't comply with data policies
        759	
        760	To exclude providers that don't comply with your data policies, set `data_collection` to `deny`:
        761	
        762	<TSFetchCodeBlock
        763	  uriPath="/api/v1/chat/completions"
        764	  body={{
        765	    messages: [{ role: 'user', content: 'Hello' }],
        766	    provider: {
        767	      data_collection: 'deny', // or "allow"
        768	    },
        769	  }}
        770	/>
        771	
        772	## Disabling Fallbacks
        773	
        774	To guarantee that your request is only served by the top (lowest-cost) provider, you can disable fallbacks.
        775	
        776	This is combined with the `order` field from [Ordering Specific Providers](#ordering-specific-providers) to restrict the providers that OpenRouter will prioritize to just your chosen list.
        777	
        778	<TSFetchCodeBlock
        779	  uriPath="/api/v1/chat/completions"
        780	  body={{
        781	    messages: [{ role: 'user', content: 'Hello' }],
        782	    provider: {
        783	      allow_fallbacks: false,
        784	    },
        785	  }}
        786	/>
        787	
        788	## Ignoring Providers
        789	
        790	You can ignore providers for a request by setting the `ignore` field in the `provider` object.
        791	
        792	| Field    | Type      | Default | Description                                      |
        793	| -------- | --------- | ------- | ------------------------------------------------ |
        794	| `ignore` | string\[] | -       | List of provider names to skip for this request. |
        795	
        796	<Warning>
        797	  Ignoring multiple providers may significantly reduce fallback options and
        798	  limit request recovery.
        799	</Warning>
        800	
        801	<Tip title="Account-Wide Ignored Providers">
        802	  You can ignore providers for all account requests by configuring your [preferences](/settings/preferences). This configuration applies to all API requests and chatroom messages.
        803	
        804	  Note that when you ignore providers for a specific request, the list of ignored providers is merged with your account-wide ignored providers.
        805	</Tip>
        806	
        807	### Example: Ignoring Azure for a request calling GPT-4 Omni
        808	
        809	Here's an example that will ignore Azure for a request calling GPT-4 Omni:
        810	
        811	<TSFetchCodeBlock
        812	  uriPath="/api/v1/chat/completions"
        813	  body={{
        814	    model: 'openai/gpt-4o',
        815	    messages: [{ role: 'user', content: 'Hello' }],
        816	    provider: {
        817	      ignore: ['Azure'],
        818	    },
        819	  }}
        820	/>
        821	
        822	## Quantization
        823	
        824	Quantization reduces model size and computational requirements while aiming to preserve performance. Most LLMs today use FP16 or BF16 for training and inference, cutting memory requirements in half compared to FP32. Some optimizations use FP8 or quantization to reduce size further (e.g., INT8, INT4).
        825	
        826	| Field           | Type      | Default | Description                                                                                     |
        827	| --------------- | --------- | ------- | ----------------------------------------------------------------------------------------------- |
        828	| `quantizations` | string\[] | -       | List of quantization levels to filter by (e.g. `["int4", "int8"]`). [Learn more](#quantization) |
        829	
        830	<Warning>
        831	  Quantized models may exhibit degraded performance for certain prompts,
        832	  depending on the method used.
        833	</Warning>
        834	
        835	Providers can support various quantization levels for open-weight models.
        836	
        837	### Quantization Levels
        838	
        839	By default, requests are load-balanced across all available providers, ordered by price. To filter providers by quantization level, specify the `quantizations` field in the `provider` parameter with the following values:
        840	
        841	* `int4`: Integer (4 bit)
        842	* `int8`: Integer (8 bit)
        843	* `fp4`: Floating point (4 bit)
        844	* `fp6`: Floating point (6 bit)
        845	* `fp8`: Floating point (8 bit)
        846	* `fp16`: Floating point (16 bit)
        847	* `bf16`: Brain floating point (16 bit)
        848	* `fp32`: Floating point (32 bit)
        849	* `unknown`: Unknown
        850	
        851	### Example: Requesting FP8 Quantization
        852	
        853	Here's an example that will only use providers that support FP8 quantization:
        854	
        855	<TSFetchCodeBlock
        856	  uriPath="/api/v1/chat/completions"
        857	  body={{
        858	    model: 'meta-llama/llama-3.1-8b-instruct',
        859	    messages: [{ role: 'user', content: 'Hello' }],
        860	    provider: {
        861	      quantizations: ['fp8'],
        862	    },
        863	  }}
        864	/>
        865	
        866	## Terms of Service
        867	
        868	You can view the terms of service for each provider below. You may not violate the terms of service or policies of third-party providers that power the models on OpenRouter.
        869	
        870	* `OpenAI`: [https://openai.com/policies/row-terms-of-use/](https://openai.com/policies/row-terms-of-use/)
        871	* `Anthropic`: [https://www.anthropic.com/legal/commercial-terms](https://www.anthropic.com/legal/commercial-terms)
        872	* `Google Vertex`: [https://cloud.google.com/terms/](https://cloud.google.com/terms/)
        873	* `Google AI Studio`: [https://cloud.google.com/terms/](https://cloud.google.com/terms/)
        874	* `Amazon Bedrock`: [https://aws.amazon.com/service-terms/](https://aws.amazon.com/service-terms/)
        875	* `Groq`: [https://groq.com/terms-of-use/](https://groq.com/terms-of-use/)
        876	* `SambaNova`: [https://sambanova.ai/terms-and-conditions](https://sambanova.ai/terms-and-conditions)
        877	* `Cohere`: [https://cohere.com/terms-of-use](https://cohere.com/terms-of-use)
        878	* `Mistral`: [https://mistral.ai/terms/#terms-of-use](https://mistral.ai/terms/#terms-of-use)
        879	* `Together`: [https://www.together.ai/terms-of-service](https://www.together.ai/terms-of-service)
        880	* `Together (lite)`: [https://www.together.ai/terms-of-service](https://www.together.ai/terms-of-service)
        881	* `Fireworks`: [https://fireworks.ai/terms-of-service](https://fireworks.ai/terms-of-service)
        882	* `DeepInfra`: [https://deepinfra.com/docs/data](https://deepinfra.com/docs/data)
        883	* `Lepton`: [https://www.lepton.ai/policies/tos](https://www.lepton.ai/policies/tos)
        884	* `NovitaAI`: [https://novita.ai/legal/terms-of-service](https://novita.ai/legal/terms-of-service)
        885	* `Avian.io`: [https://avian.io/privacy](https://avian.io/privacy)
        886	* `Lambda`: [https://lambdalabs.com/legal/privacy-policy](https://lambdalabs.com/legal/privacy-policy)
        887	* `Azure`: [https://www.microsoft.com/en-us/legal/terms-of-use?oneroute=true](https://www.microsoft.com/en-us/legal/terms-of-use?oneroute=true)
        888	* `Modal`: [https://modal.com/legal/terms](https://modal.com/legal/terms)
        889	* `AnyScale`: [https://www.anyscale.com/terms](https://www.anyscale.com/terms)
        890	* `Replicate`: [https://replicate.com/terms](https://replicate.com/terms)
        891	* `Perplexity`: [https://www.perplexity.ai/hub/legal/perplexity-api-terms-of-service](https://www.perplexity.ai/hub/legal/perplexity-api-terms-of-service)
        892	* `Recursal`: [https://featherless.ai/terms](https://featherless.ai/terms)
        893	* `OctoAI`: [https://octo.ai/docs/faqs/privacy-and-security](https://octo.ai/docs/faqs/privacy-and-security)
        894	* `DeepSeek`: [https://chat.deepseek.com/downloads/DeepSeek%20Terms%20of%20Use.html](https://chat.deepseek.com/downloads/DeepSeek%20Terms%20of%20Use.html)
        895	* `Infermatic`: [https://infermatic.ai/privacy-policy/](https://infermatic.ai/privacy-policy/)
        896	* `AI21`: [https://studio.ai21.com/privacy-policy](https://studio.ai21.com/privacy-policy)
        897	* `Featherless`: [https://featherless.ai/terms](https://featherless.ai/terms)
        898	* `Inflection`: [https://developers.inflection.ai/tos](https://developers.inflection.ai/tos)
        899	* `xAI`: [https://x.ai/legal/terms-of-service](https://x.ai/legal/terms-of-service)
        900	* `Cloudflare`: [https://www.cloudflare.com/service-specific-terms-developer-platform/#developer-platform-terms](https://www.cloudflare.com/service-specific-terms-developer-platform/#developer-platform-terms)
        901	* `SF Compute`: [https://inference.sfcompute.com/privacy](https://inference.sfcompute.com/privacy)
        902	* `Minimax`: [https://intl.minimaxi.com/protocol/terms-of-service](https://intl.minimaxi.com/protocol/terms-of-service)
        903	* `Nineteen`: [https://nineteen.ai/tos](https://nineteen.ai/tos)
        904	* `Liquid`: [https://www.liquid.ai/terms-conditions](https://www.liquid.ai/terms-conditions)
        905	* `nCompass`: [https://ncompass.tech/terms](https://ncompass.tech/terms)
        906	* `inference.net`: [https://inference.net/terms](https://inference.net/terms)
        907	* `Friendli`: [https://friendli.ai/terms-of-service](https://friendli.ai/terms-of-service)
        908	* `AionLabs`: [https://www.aionlabs.ai/terms/](https://www.aionlabs.ai/terms/)
        909	* `Alibaba`: [https://www.alibabacloud.com/help/en/legal/latest/alibaba-cloud-international-website-product-terms-of-service-v-3-8-0](https://www.alibabacloud.com/help/en/legal/latest/alibaba-cloud-international-website-product-terms-of-service-v-3-8-0)
        910	* `Nebius AI Studio`: [https://docs.nebius.com/legal/studio/terms-of-use/](https://docs.nebius.com/legal/studio/terms-of-use/)
        911	* `Chutes`: [https://chutes.ai/tos](https://chutes.ai/tos)
        912	* `kluster.ai`: [https://www.kluster.ai/terms-of-use](https://www.kluster.ai/terms-of-use)
        913	* `Crusoe`: [https://legal.crusoe.ai/open-router#managed-inference-tos-open-router](https://legal.crusoe.ai/open-router#managed-inference-tos-open-router)
        914	* `Targon`: [https://targon.com/terms](https://targon.com/terms)
        915	* `Ubicloud`: [https://www.ubicloud.com/docs/about/terms-of-service](https://www.ubicloud.com/docs/about/terms-of-service)
        916	* `Parasail`: [https://www.parasail.io/legal/terms](https://www.parasail.io/legal/terms)
        917	* `Phala`: [https://red-pill.ai/terms](https://red-pill.ai/terms)
        918	* `Cent-ML`: [https://centml.ai/terms-of-service/](https://centml.ai/terms-of-service/)
        919	* `Venice`: [https://venice.ai/terms](https://venice.ai/terms)
        920	* `OpenInference`: [https://www.openinference.xyz/terms](https://www.openinference.xyz/terms)
        921	* `Atoma`: [https://atoma.network/terms\_of\_service](https://atoma.network/terms_of_service)
        922	* `Enfer`: [https://enfer.ai/privacy-policy](https://enfer.ai/privacy-policy)
        923	* `01.AI`: [https://platform.01.ai/privacypolicy](https://platform.01.ai/privacypolicy)
        924	* `HuggingFace`: [https://huggingface.co/terms-of-service](https://huggingface.co/terms-of-service)
        925	* `Mancer`: [https://mancer.tech/terms](https://mancer.tech/terms)
        926	* `Mancer (private)`: [https://mancer.tech/terms](https://mancer.tech/terms)
        927	* `Hyperbolic`: [https://hyperbolic.xyz/privacy](https://hyperbolic.xyz/privacy)
        928	* `Hyperbolic (quantized)`: [https://hyperbolic.xyz/privacy](https://hyperbolic.xyz/privacy)
        929	* `Lynn`: [https://api.lynn.app/policy](https://api.lynn.app/policy)
        930	
        931	## JSON Schema for Provider Preferences
        932	
        933	For a complete list of options, see this JSON schema:
        934	
        935	<ZodToJSONSchemaBlock title="Provider Preferences Schema" schema={ProviderPreferencesSchema} />
        936	
        937	
        938	# Prompt Caching
        939	
        940	> Reduce your AI model costs with OpenRouter's prompt caching feature. Learn how to cache and reuse responses across OpenAI, Anthropic Claude, and DeepSeek models.
        941	
        942	To save on inference costs, you can enable prompt caching on supported providers and models.
        943	
        944	Most providers automatically enable prompt caching, but note that some (see Anthropic below) require you to enable it on a per-message basis.
        945	
        946	When using caching (whether automatically in supported models, or via the `cache_control` header), OpenRouter will make a best-effort to continue routing to the same provider to make use of the warm cache. In the event that the provider with your cached prompt is not available, OpenRouter will try the next-best provider.
        947	
        948	## Inspecting cache usage
        949	
        950	To see how much caching saved on each generation, you can:
        951	
        952	1. Click the detail button on the [Activity](/activity) page
        953	2. Use the `/api/v1/generation` API, [documented here](/api-reference/overview#querying-cost-and-stats)
        954	3. Use `usage: {include: true}` in your request to get the cache tokens at the end of the response (see [Usage Accounting](/use-cases/usage-accounting) for details)
        955	
        956	The `cache_discount` field in the response body will tell you how much the response saved on cache usage. Some providers, like Anthropic, will have a negative discount on cache writes, but a positive discount (which reduces total cost) on cache reads.
        957	
        958	## OpenAI
        959	
        960	Caching price changes:
        961	
        962	* **Cache writes**: no cost
        963	* **Cache reads**: charged at {OPENAI_CACHE_READ_MULTIPLIER}x the price of the original input pricing
        964	
        965	Prompt caching with OpenAI is automated and does not require any additional configuration. There is a minimum prompt size of 1024 tokens.
        966	
        967	[Click here to read more about OpenAI prompt caching and its limitation.](https://openai.com/index/api-prompt-caching/)
        968	
        969	## Anthropic Claude
        970	
        971	Caching price changes:
        972	
        973	* **Cache writes**: charged at {ANTHROPIC_CACHE_WRITE_MULTIPLIER}x the price of the original input pricing
        974	* **Cache reads**: charged at {ANTHROPIC_CACHE_READ_MULTIPLIER}x the price of the original input pricing
        975	
        976	Prompt caching with Anthropic requires the use of `cache_control` breakpoints. There is a limit of four breakpoints, and the cache will expire within five minutes. Therefore, it is recommended to reserve the cache breakpoints for large bodies of text, such as character cards, CSV data, RAG data, book chapters, etc.
        977	
        978	[Click here to read more about Anthropic prompt caching and its limitation.](https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching)
        979	
        980	The `cache_control` breakpoint can only be inserted into the text part of a multipart message.
        981	
        982	System message caching example:
        983	
        984	```json
        985	{
        986	  "messages": [
        987	    {
        988	      "role": "system",
        989	      "content": [
        990	        {
        991	          "type": "text",
        992	          "text": "You are a historian studying the fall of the Roman Empire. You know the following book very well:"
        993	        },
        994	        {
        995	          "type": "text",
        996	          "text": "HUGE TEXT BODY",
        997	          "cache_control": {
        998	            "type": "ephemeral"
        999	          }
       1000	        }
       1001	      ]
       1002	    },
       1003	    {
       1004	      "role": "user",
       1005	      "content": [
       1006	        {
       1007	          "type": "text",
       1008	          "text": "What triggered the collapse?"
       1009	        }
       1010	      ]
       1011	    }
       1012	  ]
       1013	}
       1014	```
       1015	
       1016	User message caching example:
       1017	
       1018	```json
       1019	{
       1020	  "messages": [
       1021	    {
       1022	      "role": "user",
       1023	      "content": [
       1024	        {
       1025	          "type": "text",
       1026	          "text": "Given the book below:"
       1027	        },
       1028	        {
       1029	          "type": "text",
       1030	          "text": "HUGE TEXT BODY",
       1031	          "cache_control": {
       1032	            "type": "ephemeral"
       1033	          }
       1034	        },
       1035	        {
       1036	          "type": "text",
       1037	          "text": "Name all the characters in the above book"
       1038	        }
       1039	      ]
       1040	    }
       1041	  ]
       1042	}
       1043	```
       1044	
       1045	## DeepSeek
       1046	
       1047	Caching price changes:
       1048	
       1049	* **Cache writes**: charged at the same price as the original input pricing
       1050	* **Cache reads**: charged at {DEEPSEEK_CACHE_READ_MULTIPLIER}x the price of the original input pricing
       1051	
       1052	Prompt caching with DeepSeek is automated and does not require any additional configuration.
       1053	
       1054	## Google Gemini
       1055	
       1056	### Pricing Changes for Cached Requests:
       1057	
       1058	* **Cache Writes:** Charged at the input token cost plus 5 minutes of cache storage, calculated as follows:
       1059	
       1060	```
       1061	Cache write cost = Input token price + (Cache storage price × (5 minutes / 60 minutes))
       1062	```
       1063	
       1064	* **Cache Reads:** Charged at {GOOGLE_CACHE_READ_MULTIPLIER}× the original input token cost.
       1065	
       1066	### Supported Models and Limitations:
       1067	
       1068	Only certain Gemini models support caching. Please consult Google's [Gemini API Pricing Documentation](https://ai.google.dev/gemini-api/docs/pricing) for the most current details.
       1069	
       1070	Cache Writes have a 5 minute Time-to-Live (TTL) that does not update. After 5 minutes, the cache expires and a new cache must be written.
       1071	
       1072	Gemini models have a 4,096 token minimum for cache write to occur. Cached tokens count towards the model's maximum token usage.
       1073	
       1074	### How Gemini Prompt Caching works on OpenRouter:
       1075	
       1076	OpenRouter simplifies Gemini cache management, abstracting away complexities:
       1077	
       1078	* You **do not** need to manually create, update, or delete caches.
       1079	* You **do not** need to manage cache names or TTL explicitly.
       1080	
       1081	### How to Enable Gemini Prompt Caching:
       1082	
       1083	Gemini caching in OpenRouter requires you to insert `cache_control` breakpoints explicitly within message content, similar to Anthropic. We recommend using caching primarily for large content pieces (such as CSV files, lengthy character cards, retrieval augmented generation (RAG) data, or extensive textual sources).
       1084	
       1085	<Tip>
       1086	  There is not a limit on the number of `cache_control` breakpoints you can
       1087	  include in your request. OpenRouter will use only the last breakpoint for
       1088	  Gemini caching. Including multiple breakpoints is safe and can help maintain
       1089	  compatibility with Anthropic, but only the final one will be used for Gemini.
       1090	</Tip>
       1091	
       1092	### Examples:
       1093	
       1094	#### System Message Caching Example
       1095	
       1096	```json
       1097	{
       1098	  "messages": [
       1099	    {
       1100	      "role": "system",
       1101	      "content": [
       1102	        {
       1103	          "type": "text",
       1104	          "text": "You are a historian studying the fall of the Roman Empire. Below is an extensive reference book:"
       1105	        },
       1106	        {
       1107	          "type": "text",
       1108	          "text": "HUGE TEXT BODY HERE",
       1109	          "cache_control": {
       1110	            "type": "ephemeral"
       1111	          }
       1112	        }
       1113	      ]
       1114	    },
       1115	    {
       1116	      "role": "user",
       1117	      "content": [
       1118	        {
       1119	          "type": "text",
       1120	          "text": "What triggered the collapse?"
       1121	        }
       1122	      ]
       1123	    }
       1124	  ]
       1125	}
       1126	```
       1127	
       1128	#### User Message Caching Example
       1129	
       1130	```json
       1131	{
       1132	  "messages": [
       1133	    {
       1134	      "role": "user",
       1135	      "content": [
       1136	        {
       1137	          "type": "text",
       1138	          "text": "Based on the book text below:"
       1139	        },
       1140	        {
       1141	          "type": "text",
       1142	          "text": "HUGE TEXT BODY HERE",
       1143	          "cache_control": {
       1144	            "type": "ephemeral"
       1145	          }
       1146	        },
       1147	        {
       1148	          "type": "text",
       1149	          "text": "List all main characters mentioned in the text above."
       1150	        }
       1151	      ]
       1152	    }
       1153	  ]
       1154	}
       1155	```
       1156	
       1157	
       1158	# Structured Outputs
       1159	
       1160	> Enforce JSON Schema validation on AI model responses. Get consistent, type-safe outputs and avoid parsing errors with OpenRouter's structured output feature.
       1161	
       1162	OpenRouter supports structured outputs for compatible models, ensuring responses follow a specific JSON Schema format. This feature is particularly useful when you need consistent, well-formatted responses that can be reliably parsed by your application.
       1163	
       1164	## Overview
       1165	
       1166	Structured outputs allow you to:
       1167	
       1168	* Enforce specific JSON Schema validation on model responses
       1169	* Get consistent, type-safe outputs
       1170	* Avoid parsing errors and hallucinated fields
       1171	* Simplify response handling in your application
       1172	
       1173	## Using Structured Outputs
       1174	
       1175	To use structured outputs, include a `response_format` parameter in your request, with `type` set to `json_schema` and the `json_schema` object containing your schema:
       1176	
       1177	```typescript
       1178	{
       1179	  "messages": [
       1180	    { "role": "user", "content": "What's the weather like in London?" }
       1181	  ],
       1182	  "response_format": {
       1183	    "type": "json_schema",
       1184	    "json_schema": {
       1185	      "name": "weather",
       1186	      "strict": true,
       1187	      "schema": {
       1188	        "type": "object",
       1189	        "properties": {
       1190	          "location": {
       1191	            "type": "string",
       1192	            "description": "City or location name"
       1193	          },
       1194	          "temperature": {
       1195	            "type": "number",
       1196	            "description": "Temperature in Celsius"
       1197	          },
       1198	          "conditions": {
       1199	            "type": "string",
       1200	            "description": "Weather conditions description"
       1201	          }
       1202	        },
       1203	        "required": ["location", "temperature", "conditions"],
       1204	        "additionalProperties": false
       1205	      }
       1206	    }
       1207	  }
       1208	}
       1209	```
       1210	
       1211	The model will respond with a JSON object that strictly follows your schema:
       1212	
       1213	```json
       1214	{
       1215	  "location": "London",
       1216	  "temperature": 18,
       1217	  "conditions": "Partly cloudy with light drizzle"
       1218	}
       1219	```
       1220	
       1221	## Model Support
       1222	
       1223	Structured outputs are supported by select models.
       1224	
       1225	You can find a list of models that support structured outputs on the [models page](https://openrouter.ai/models?order=newest\&supported_parameters=structured_outputs).
       1226	
       1227	* OpenAI models (GPT-4o and later versions) [Docs](https://platform.openai.com/docs/guides/structured-outputs)
       1228	* All Fireworks provided models [Docs](https://docs.fireworks.ai/structured-responses/structured-response-formatting#structured-response-modes)
       1229	
       1230	To ensure your chosen model supports structured outputs:
       1231	
       1232	1. Check the model's supported parameters on the [models page](https://openrouter.ai/models)
       1233	2. Set `require_parameters: true` in your provider preferences (see [Provider Routing](/docs/features/provider-routing))
       1234	3. Include `response_format` and set `type: json_schema` in the required parameters
       1235	
       1236	## Best Practices
       1237	
       1238	1. **Include descriptions**: Add clear descriptions to your schema properties to guide the model
       1239	
       1240	2. **Use strict mode**: Always set `strict: true` to ensure the model follows your schema exactly
       1241	
       1242	## Example Implementation
       1243	
       1244	Here's a complete example using the Fetch API:
       1245	
       1246	<Template
       1247	  data={{
       1248	  API_KEY_REF,
       1249	  MODEL: 'openai/gpt-4'
       1250	}}
       1251	>
       1252	  <CodeGroup>
       1253	    ```typescript title="With TypeScript"
       1254	    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
       1255	      method: 'POST',
       1256	      headers: {
       1257	        Authorization: 'Bearer {{API_KEY_REF}}',
       1258	        'Content-Type': 'application/json',
       1259	      },
       1260	      body: JSON.stringify({
       1261	        model: '{{MODEL}}',
       1262	        messages: [
       1263	          { role: 'user', content: 'What is the weather like in London?' },
       1264	        ],
       1265	        response_format: {
       1266	          type: 'json_schema',
       1267	          json_schema: {
       1268	            name: 'weather',
       1269	            strict: true,
       1270	            schema: {
       1271	              type: 'object',
       1272	              properties: {
       1273	                location: {
       1274	                  type: 'string',
       1275	                  description: 'City or location name',
       1276	                },
       1277	                temperature: {
       1278	                  type: 'number',
       1279	                  description: 'Temperature in Celsius',
       1280	                },
       1281	                conditions: {
       1282	                  type: 'string',
       1283	                  description: 'Weather conditions description',
       1284	                },
       1285	              },
       1286	              required: ['location', 'temperature', 'conditions'],
       1287	              additionalProperties: false,
       1288	            },
       1289	          },
       1290	        },
       1291	      }),
       1292	    });
       1293	
       1294	    const data = await response.json();
       1295	    const weatherInfo = data.choices[0].message.content;
       1296	    ```
       1297	
       1298	    ```python title="With Python"
       1299	    import requests
       1300	    import json
       1301	
       1302	    response = requests.post(
       1303	      "https://openrouter.ai/api/v1/chat/completions",
       1304	      headers={
       1305	        "Authorization": f"Bearer {{API_KEY_REF}}",
       1306	        "Content-Type": "application/json",
       1307	      },
       1308	
       1309	      json={
       1310	        "model": "{{MODEL}}",
       1311	        "messages": [
       1312	          {"role": "user", "content": "What is the weather like in London?"},
       1313	        ],
       1314	        "response_format": {
       1315	          "type": "json_schema",
       1316	          "json_schema": {
       1317	            "name": "weather",
       1318	            "strict": True,
       1319	            "schema": {
       1320	              "type": "object",
       1321	              "properties": {
       1322	                "location": {
       1323	                  "type": "string",
       1324	                  "description": "City or location name",
       1325	                },
       1326	                "temperature": {
       1327	                  "type": "number",
       1328	                  "description": "Temperature in Celsius",
       1329	                },
       1330	                "conditions": {
       1331	                  "type": "string",
       1332	                  "description": "Weather conditions description",
       1333	                },
       1334	              },
       1335	              "required": ["location", "temperature", "conditions"],
       1336	              "additionalProperties": False,
       1337	            },
       1338	          },
       1339	        },
       1340	      },
       1341	    )
       1342	
       1343	    data = response.json()
       1344	    weather_info = data["choices"][0]["message"]["content"]
       1345	    ```
       1346	  </CodeGroup>
       1347	</Template>
       1348	
       1349	## Streaming with Structured Outputs
       1350	
       1351	Structured outputs are also supported with streaming responses. The model will stream valid partial JSON that, when complete, forms a valid response matching your schema.
       1352	
       1353	To enable streaming with structured outputs, simply add `stream: true` to your request:
       1354	
       1355	```typescript
       1356	{
       1357	  "stream": true,
       1358	  "response_format": {
       1359	    "type": "json_schema",
       1360	    // ... rest of your schema
       1361	  }
       1362	}
       1363	```
       1364	
       1365	## Error Handling
       1366	
       1367	When using structured outputs, you may encounter these scenarios:
       1368	
       1369	1. **Model doesn't support structured outputs**: The request will fail with an error indicating lack of support
       1370	2. **Invalid schema**: The model will return an error if your JSON Schema is invalid
       1371	
       1372	
       1373	# Tool & Function Calling
       1374	
       1375	> Use tools (or functions) in your prompts with OpenRouter. Learn how to use tools with OpenAI, Anthropic, and other models that support tool calling.
       1376	
       1377	Tool calls (also known as function calls) give an LLM access to external tools. The LLM does not call the tools directly. Instead, it suggests the tool to call. The user then calls the tool separately and provides the results back to the LLM. Finally, the LLM formats the response into an answer to the user's original question.
       1378	
       1379	OpenRouter standardizes the tool calling interface across models and providers.
       1380	
       1381	For a primer on how tool calling works in the OpenAI SDK, please see [this article](https://platform.openai.com/docs/guides/function-calling?api-mode=chat), or if you prefer to learn from a full end-to-end example, keep reading.
       1382	
       1383	### Tool Calling Example
       1384	
       1385	Here is Python code that gives LLMs the ability to call an external API -- in this case Project Gutenberg, to search for books.
       1386	
       1387	First, let's do some basic setup:
       1388	
       1389	<Template
       1390	  data={{
       1391	  API_KEY_REF,
       1392	  MODEL: 'google/gemini-2.0-flash-001'
       1393	}}
       1394	>
       1395	  <CodeGroup>
       1396	    ```python
       1397	    import json, requests
       1398	    from openai import OpenAI
       1399	
       1400	    OPENROUTER_API_KEY = f"{{API_KEY_REF}}"
       1401	
       1402	    # You can use any model that supports tool calling
       1403	    MODEL = "{{MODEL}}"
       1404	
       1405	    openai_client = OpenAI(
       1406	      base_url="https://openrouter.ai/api/v1",
       1407	      api_key=OPENROUTER_API_KEY,
       1408	    )
       1409	
       1410	    task = "What are the titles of some James Joyce books?"
       1411	
       1412	    messages = [
       1413	      {
       1414	        "role": "system",
       1415	        "content": "You are a helpful assistant."
       1416	      },
       1417	      {
       1418	        "role": "user",
       1419	        "content": task,
       1420	      }
       1421	    ]
       1422	
       1423	    ```
       1424	
       1425	    ```typescript
       1426	    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
       1427	      method: 'POST',
       1428	      headers: {
       1429	        Authorization: `Bearer {{API_KEY_REF}}`,
       1430	        'Content-Type': 'application/json',
       1431	      },
       1432	      body: JSON.stringify({
       1433	        model: '{{MODEL}}',
       1434	        messages: [
       1435	          { role: 'system', content: 'You are a helpful assistant.' },
       1436	          {
       1437	            role: 'user',
       1438	            content: 'What are the titles of some James Joyce books?',
       1439	          },
       1440	        ],
       1441	      }),
       1442	    });
       1443	    ```
       1444	  </CodeGroup>
       1445	</Template>
       1446	
       1447	### Define the Tool
       1448	
       1449	Next, we define the tool that we want to call. Remember, the tool is going to get *requested* by the LLM, but the code we are writing here is ultimately responsible for executing the call and returning the results to the LLM.
       1450	
       1451	<Template
       1452	  data={{
       1453	  API_KEY_REF,
       1454	  MODEL: 'google/gemini-2.0-flash-001'
       1455	}}
       1456	>
       1457	  <CodeGroup>
       1458	    ```python
       1459	    def search_gutenberg_books(search_terms):
       1460	        search_query = " ".join(search_terms)
       1461	        url = "https://gutendex.com/books"
       1462	        response = requests.get(url, params={"search": search_query})
       1463	
       1464	        simplified_results = []
       1465	        for book in response.json().get("results", []):
       1466	            simplified_results.append({
       1467	                "id": book.get("id"),
       1468	                "title": book.get("title"),
       1469	                "authors": book.get("authors")
       1470	            })
       1471	
       1472	        return simplified_results
       1473	
       1474	    tools = [
       1475	      {
       1476	        "type": "function",
       1477	        "function": {
       1478	          "name": "search_gutenberg_books",
       1479	          "description": "Search for books in the Project Gutenberg library based on specified search terms",
       1480	          "parameters": {
       1481	            "type": "object",
       1482	            "properties": {
       1483	              "search_terms": {
       1484	                "type": "array",
       1485	                "items": {
       1486	                  "type": "string"
       1487	                },
       1488	                "description": "List of search terms to find books in the Gutenberg library (e.g. ['dickens', 'great'] to search for books by Dickens with 'great' in the title)"
       1489	              }
       1490	            },
       1491	            "required": ["search_terms"]
       1492	          }
       1493	        }
       1494	      }
       1495	    ]
       1496	
       1497	    TOOL_MAPPING = {
       1498	        "search_gutenberg_books": search_gutenberg_books
       1499	    }
       1500	
       1501	    ```
       1502	
       1503	    ```typescript
       1504	    async function searchGutenbergBooks(searchTerms: string[]): Promise<Book[]> {
       1505	      const searchQuery = searchTerms.join(' ');
       1506	      const url = 'https://gutendex.com/books';
       1507	      const response = await fetch(`${url}?search=${searchQuery}`);
       1508	      const data = await response.json();
       1509	
       1510	      return data.results.map((book: any) => ({
       1511	        id: book.id,
       1512	        title: book.title,
       1513	        authors: book.authors,
       1514	      }));
       1515	    }
       1516	
       1517	    const tools = [
       1518	      {
       1519	        type: 'function',
       1520	        function: {
       1521	          name: 'search_gutenberg_books',
       1522	          description:
       1523	            'Search for books in the Project Gutenberg library based on specified search terms',
       1524	          parameters: {
       1525	            type: 'object',
       1526	            properties: {
       1527	              search_terms: {
       1528	                type: 'array',
       1529	                items: {
       1530	                  type: 'string',
       1531	                },
       1532	                description:
       1533	                  "List of search terms to find books in the Gutenberg library (e.g. ['dickens', 'great'] to search for books by Dickens with 'great' in the title)",
       1534	              },
       1535	            },
       1536	            required: ['search_terms'],
       1537	          },
       1538	        },
       1539	      },
       1540	    ];
       1541	
       1542	    const TOOL_MAPPING = {
       1543	      searchGutenbergBooks,
       1544	    };
       1545	    ```
       1546	  </CodeGroup>
       1547	</Template>
       1548	
       1549	Note that the "tool" is just a normal function. We then write a JSON "spec" compatible with the OpenAI function calling parameter. We'll pass that spec to the LLM so that it knows this tool is available and how to use it. It will request the tool when needed, along with any arguments. We'll then marshal the tool call locally, make the function call, and return the results to the LLM.
       1550	
       1551	### Tool use and tool results
       1552	
       1553	Let's make the first OpenRouter API call to the model:
       1554	
       1555	<Template
       1556	  data={{
       1557	  API_KEY_REF,
       1558	  MODEL: 'google/gemini-2.0-flash-001'
       1559	}}
       1560	>
       1561	  <CodeGroup>
       1562	    ```python
       1563	    request_1 = {
       1564	        "model": {{MODEL}},
       1565	        "tools": tools,
       1566	        "messages": messages
       1567	    }
       1568	
       1569	    response_1 = openai_client.chat.completions.create(**request_1).message
       1570	    ```
       1571	
       1572	    ```typescript
       1573	    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
       1574	      method: 'POST',
       1575	      headers: {
       1576	        Authorization: `Bearer {{API_KEY_REF}}`,
       1577	        'Content-Type': 'application/json',
       1578	      },
       1579	      body: JSON.stringify({
       1580	        model: '{{MODEL}}',
       1581	        tools,
       1582	        messages,
       1583	      }),
       1584	    });
       1585	    ```
       1586	  </CodeGroup>
       1587	</Template>
       1588	
       1589	The LLM responds with a finish reason of tool\_calls, and a tool\_calls array. In a generic LLM response-handler, you would want to check the finish reason before processing tool calls, but here we will assume it's the case. Let's keep going, by processing the tool call:
       1590	
       1591	<Template
       1592	  data={{
       1593	  API_KEY_REF,
       1594	  MODEL: 'google/gemini-2.0-flash-001'
       1595	}}
       1596	>
       1597	  <CodeGroup>
       1598	    ```python
       1599	    # Append the response to the messages array so the LLM has the full context
       1600	    # It's easy to forget this step!
       1601	    messages.append(response_1)
       1602	
       1603	    # Now we process the requested tool calls, and use our book lookup tool
       1604	    for tool_call in response_1.tool_calls:
       1605	        '''
       1606	        In this case we only provided one tool, so we know what function to call.
       1607	        When providing multiple tools, you can inspect `tool_call.function.name`
       1608	        to figure out what function you need to call locally.
       1609	        '''
       1610	        tool_name = tool_call.function.name
       1611	        tool_args = json.loads(tool_call.function.arguments)
       1612	        tool_response = TOOL_MAPPING[tool_name](**tool_args)
       1613	        messages.append({
       1614	          "role": "tool",
       1615	          "tool_call_id": tool_call.id,
       1616	          "name": tool_name,
       1617	          "content": json.dumps(tool_response),
       1618	        })
       1619	    ```
       1620	
       1621	    ```typescript
       1622	    // Append the response to the messages array so the LLM has the full context
       1623	    // It's easy to forget this step!
       1624	    messages.push(response);
       1625	
       1626	    // Now we process the requested tool calls, and use our book lookup tool
       1627	    for (const toolCall of response.toolCalls) {
       1628	      const toolName = toolCall.function.name;
       1629	      const toolArgs = JSON.parse(toolCall.function.arguments);
       1630	      const toolResponse = await TOOL_MAPPING[toolName](toolArgs);
       1631	      messages.push({
       1632	        role: 'tool',
       1633	        toolCallId: toolCall.id,
       1634	        name: toolName,
       1635	        content: JSON.stringify(toolResponse),
       1636	      });
       1637	    }
       1638	    ```
       1639	  </CodeGroup>
       1640	</Template>
       1641	
       1642	The messages array now has:
       1643	
       1644	1. Our original request
       1645	2. The LLM's response (containing a tool call request)
       1646	3. The result of the tool call (a json object returned from the Project Gutenberg API)
       1647	
       1648	Now, we can make a second OpenRouter API call, and hopefully get our result!
       1649	
       1650	<Template
       1651	  data={{
       1652	  API_KEY_REF,
       1653	  MODEL: 'google/gemini-2.0-flash-001'
       1654	}}
       1655	>
       1656	  <CodeGroup>
       1657	    ```python
       1658	    request_2 = {
       1659	      "model": MODEL,
       1660	      "messages": messages,
       1661	      "tools": tools
       1662	    }
       1663	
       1664	    response_2 = openai_client.chat.completions.create(**request_2)
       1665	
       1666	    print(response_2.choices[0].message.content)
       1667	    ```
       1668	
       1669	    ```typescript
       1670	    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
       1671	      method: 'POST',
       1672	      headers: {
       1673	        Authorization: `Bearer {{API_KEY_REF}}`,
       1674	        'Content-Type': 'application/json',
       1675	      },
       1676	      body: JSON.stringify({
       1677	        model: '{{MODEL}}',
       1678	        messages,
       1679	        tools,
       1680	      }),
       1681	    });
       1682	
       1683	    const data = await response.json();
       1684	    console.log(data.choices[0].message.content);
       1685	    ```
       1686	  </CodeGroup>
       1687	</Template>
       1688	
       1689	The output will be something like:
       1690	
       1691	```text
       1692	Here are some books by James Joyce:
       1693	
       1694	*   *Ulysses*
       1695	*   *Dubliners*
       1696	*   *A Portrait of the Artist as a Young Man*
       1697	*   *Chamber Music*
       1698	*   *Exiles: A Play in Three Acts*
       1699	```
       1700	
       1701	We did it! We've successfully used a tool in a prompt.
       1702	
       1703	## A Simple Agentic Loop
       1704	
       1705	In the example above, the calls are made explicitly and sequentially. To handle a wide variety of user inputs and tool calls, you can use an agentic loop.
       1706	
       1707	Here's an example of a simple agentic loop (using the same `tools` and initial `messages` as above):
       1708	
       1709	<Template
       1710	  data={{
       1711	  API_KEY_REF,
       1712	  MODEL: 'google/gemini-2.0-flash-001'
       1713	}}
       1714	>
       1715	  <CodeGroup>
       1716	    ```python
       1717	
       1718	    def call_llm(msgs):
       1719	        resp = openai_client.chat.completions.create(
       1720	            model={{MODEL}},
       1721	            tools=tools,
       1722	            messages=msgs
       1723	        )
       1724	        msgs.append(resp.choices[0].message.dict())
       1725	        return resp
       1726	
       1727	    def get_tool_response(response):
       1728	        tool_call = response.choices[0].message.tool_calls[0]
       1729	        tool_name = tool_call.function.name
       1730	        tool_args = json.loads(tool_call.function.arguments)
       1731	
       1732	        # Look up the correct tool locally, and call it with the provided arguments
       1733	        # Other tools can be added without changing the agentic loop
       1734	        tool_result = TOOL_MAPPING[tool_name](**tool_args)
       1735	
       1736	        return {
       1737	            "role": "tool",
       1738	            "tool_call_id": tool_call.id,
       1739	            "name": tool_name,
       1740	            "content": tool_result,
       1741	        }
       1742	
       1743	    while True:
       1744	        resp = call_llm(_messages)
       1745	
       1746	        if resp.choices[0].message.tool_calls is not None:
       1747	            messages.append(get_tool_response(resp))
       1748	        else:
       1749	            break
       1750	
       1751	    print(messages[-1]['content'])
       1752	
       1753	    ```
       1754	
       1755	    ```typescript
       1756	    async function callLLM(messages: Message[]): Promise<Message> {
       1757	      const response = await fetch(
       1758	        'https://openrouter.ai/api/v1/chat/completions',
       1759	        {
       1760	          method: 'POST',
       1761	          headers: {
       1762	            Authorization: `Bearer {{API_KEY_REF}}`,
       1763	            'Content-Type': 'application/json',
       1764	          },
       1765	          body: JSON.stringify({
       1766	            model: '{{MODEL}}',
       1767	            tools,
       1768	            messages,
       1769	          }),
       1770	        },
       1771	      );
       1772	
       1773	      const data = await response.json();
       1774	      messages.push(data.choices[0].message);
       1775	      return data;
       1776	    }
       1777	
       1778	    async function getToolResponse(response: Message): Promise<Message> {
       1779	      const toolCall = response.toolCalls[0];
       1780	      const toolName = toolCall.function.name;
       1781	      const toolArgs = JSON.parse(toolCall.function.arguments);
       1782	
       1783	      // Look up the correct tool locally, and call it with the provided arguments
       1784	      // Other tools can be added without changing the agentic loop
       1785	      const toolResult = await TOOL_MAPPING[toolName](toolArgs);
       1786	
       1787	      return {
       1788	        role: 'tool',
       1789	        toolCallId: toolCall.id,
       1790	        name: toolName,
       1791	        content: toolResult,
       1792	      };
       1793	    }
       1794	
       1795	    while (true) {
       1796	      const response = await callLLM(messages);
       1797	
       1798	      if (response.toolCalls) {
       1799	        messages.push(await getToolResponse(response));
       1800	      } else {
       1801	        break;
       1802	      }
       1803	    }
       1804	
       1805	    console.log(messages[messages.length - 1].content);
       1806	    ```
       1807	  </CodeGroup>
       1808	</Template>
       1809	
       1810	
       1811	# Message Transforms
       1812	
       1813	> Transform and optimize messages before sending them to AI models. Learn about middle-out compression and context window optimization with OpenRouter.
       1814	
       1815	To help with prompts that exceed the maximum context size of a model, OpenRouter supports a custom parameter called `transforms`:
       1816	
       1817	```typescript
       1818	{
       1819	  transforms: ["middle-out"], // Compress prompts that are > context size.
       1820	  messages: [...],
       1821	  model // Works with any model
       1822	}
       1823	```
       1824	
       1825	This can be useful for situations where perfect recall is not required. The transform works by removing or truncating messages from the middle of the prompt, until the prompt fits within the model's context window.
       1826	
       1827	In some cases, the issue is not the token context length, but the actual number of messages. The transform addresses this as well: For instance, Anthropic's Claude models enforce a maximum of {anthropicMaxMessagesCount} messages. When this limit is exceeded with middle-out enabled, the transform will keep half of the messages from the start and half from the end of the conversation.
       1828	
       1829	When middle-out compression is enabled, OpenRouter will first try to find models whose context length is at least half of your total required tokens (input + completion). For example, if your prompt requires 10,000 tokens total, models with at least 5,000 context length will be considered. If no models meet this criteria, OpenRouter will fall back to using the model with the highest available context length.
       1830	
       1831	The compression will then attempt to fit your content within the chosen model's context window by removing or truncating content from the middle of the prompt. If middle-out compression is disabled and your total tokens exceed the model's context length, the request will fail with an error message suggesting you either reduce the length or enable middle-out compression.
       1832	
       1833	<Note>
       1834	  [All OpenRouter endpoints](/models) with 8k (8,192 tokens) or less context
       1835	  length will default to using `middle-out`. To disable this, set `transforms:   []` in the request body.
       1836	</Note>
       1837	
       1838	The middle of the prompt is compressed because [LLMs pay less attention](https://arxiv.org/abs/2307.03172) to the middle of sequences.
       1839	
       1840	
       1841	# Uptime Optimization
       1842	
       1843	> Learn how OpenRouter maximizes AI model uptime through real-time monitoring, intelligent routing, and automatic fallbacks across multiple providers.
       1844	
       1845	OpenRouter continuously monitors the health and availability of AI providers to ensure maximum uptime for your applications. We track response times, error rates, and availability across all providers in real-time, and route based on this feedback.
       1846	
       1847	## How It Works
       1848	
       1849	OpenRouter tracks response times, error rates, and availability across all providers in real-time. This data helps us make intelligent routing decisions and provides transparency about service reliability.
       1850	
       1851	## Uptime Example: Claude 3.5 Sonnet
       1852	
       1853	<UptimeChart permaslug="anthropic/claude-3.5-sonnet" />
       1854	
       1855	## Uptime Example: Llama 3.3 70B Instruct
       1856	
       1857	<UptimeChart permaslug="meta-llama/llama-3.3-70b-instruct" />
       1858	
       1859	## Customizing Provider Selection
       1860	
       1861	While our smart routing helps maintain high availability, you can also customize provider selection using request parameters. This gives you control over which providers handle your requests while still benefiting from automatic fallback when needed.
       1862	
       1863	Learn more about customizing provider selection in our [Provider Routing documentation](/docs/features/provider-routing).
       1864	
       1865	
       1866	# Web Search
       1867	
       1868	> Enable real-time web search capabilities in your AI model responses. Add factual, up-to-date information to any model's output with OpenRouter's web search feature.
       1869	
       1870	You can incorporate relevant web search results for *any* model on OpenRouter by activating and customizing the `web` plugin, or by appending `:online` to the model slug:
       1871	
       1872	```json
       1873	{
       1874	  "model": "openai/gpt-4o:online"
       1875	}
       1876	```
       1877	
       1878	This is a shortcut for using the `web` plugin, and is exactly equivalent to:
       1879	
       1880	```json
       1881	{
       1882	  "model": "openrouter/auto",
       1883	  "plugins": [{ "id": "web" }]
       1884	}
       1885	```
       1886	
       1887	The web search plugin is powered by [Exa](https://exa.ai) and uses their ["auto"](https://docs.exa.ai/reference/how-exa-search-works#combining-neural-and-keyword-the-best-of-both-worlds-through-exa-auto-search) method (a combination of keyword search and embeddings-based web search) to find the most relevant results and augment/ground your prompt.
       1888	
       1889	## Parsing web search results
       1890	
       1891	Web search results for all models (including native-only models like Perplexity and OpenAI Online) are available in the API and standardized by OpenRouterto follow the same annotation schema in the [OpenAI Chat Completion Message type](https://platform.openai.com/docs/api-reference/chat/object):
       1892	
       1893	```json
       1894	{
       1895	  "message": {
       1896	    "role": "assistant",
       1897	    "content": "Here's the latest news I found: ...",
       1898	    "annotations": [
       1899	      {
       1900	        "type": "url_citation",
       1901	        "url_citation": {
       1902	          "url": "https://www.example.com/web-search-result",
       1903	          "title": "Title of the web search result",
       1904	          "content": "Content of the web search result", // Added by OpenRouter if available
       1905	          "start_index": 100, // The index of the first character of the URL citation in the message.
       1906	          "end_index": 200 // The index of the last character of the URL citation in the message.
       1907	        }
       1908	      }
       1909	    ]
       1910	  }
       1911	}
       1912	```
       1913	
       1914	## Customizing the Web Plugin
       1915	
       1916	The maximum results allowed by the web plugin and the prompt used to attach them to your message stream can be customized:
       1917	
       1918	```json
       1919	{
       1920	  "model": "openai/gpt-4o:online",
       1921	  "plugins": [
       1922	    {
       1923	      "id": "web",
       1924	      "max_results": 1, // Defaults to 5
       1925	      "search_prompt": "Some relevant web results:" // See default below
       1926	    }
       1927	  ]
       1928	}
       1929	```
       1930	
       1931	By default, the web plugin uses the following search prompt, using the current date:
       1932	
       1933	```
       1934	A web search was conducted on `date`. Incorporate the following web search results into your response.
       1935	
       1936	IMPORTANT: Cite them using markdown links named using the domain of the source.
       1937	Example: [nytimes.com](https://nytimes.com/some-page).
       1938	```
       1939	
       1940	## Pricing
       1941	
       1942	The web plugin uses your OpenRouter credits and charges *\$4 per 1000 results*. By default, `max_results` set to 5, this comes out to a maximum of \$0.02 per request, in addition to the LLM usage for the search result prompt tokens.
       1943	
       1944	
       1945	# Zero Completion Insurance
       1946	
       1947	> Learn how OpenRouter protects users from being charged for failed or empty AI responses with zero completion insurance.
       1948	
       1949	OpenRouter provides zero completion insurance to protect users from being charged for failed or empty responses. When a response contains no output tokens and either has a blank finish reason or an error, you will not be charged for the request, even if the underlying provider charges for prompt processing.
       1950	
       1951	<Note>
       1952	  Zero completion insurance is automatically enabled for all accounts and requires no configuration.
       1953	</Note>
       1954	
       1955	## How It Works
       1956	
       1957	Zero completion insurance automatically applies to all requests across all models and providers. When a response meets either of these conditions, no credits will be deducted from your account:
       1958	
       1959	* The response has zero completion tokens AND a blank/null finish reason
       1960	* The response has an error finish reason
       1961	
       1962	## Viewing Protected Requests
       1963	
       1964	On your activity page, requests that were protected by zero completion insurance will show zero credits deducted. This applies even in cases where OpenRouter may have been charged by the provider for prompt processing.
       1965	
       1966	
       1967	# Provisioning API Keys
       1968	
       1969	> Manage OpenRouter API keys programmatically through dedicated management endpoints. Create, read, update, and delete API keys for automated key distribution and control.
       1970	
       1971	OpenRouter provides endpoints to programmatically manage your API keys, enabling key creation and management for applications that need to distribute or rotate keys automatically.
       1972	
       1973	## Creating a Provisioning API Key
       1974	
       1975	To use the key management API, you first need to create a Provisioning API key:
       1976	
       1977	1. Go to the [Provisioning API Keys page](https://openrouter.ai/settings/provisioning-keys)
       1978	2. Click "Create New Key"
       1979	3. Complete the key creation process
       1980	
       1981	Provisioning keys cannot be used to make API calls to OpenRouter's completion endpoints - they are exclusively for key management operations.
       1982	
       1983	## Use Cases
       1984	
       1985	Common scenarios for programmatic key management include:
       1986	
       1987	* **SaaS Applications**: Automatically create unique API keys for each customer instance
       1988	* **Key Rotation**: Regularly rotate API keys for security compliance
       1989	* **Usage Monitoring**: Track key usage and automatically disable keys that exceed limits
       1990	
       1991	## Example Usage
       1992	
       1993	All key management endpoints are under `/api/v1/keys` and require a Provisioning API key in the Authorization header.
       1994	
       1995	<CodeGroup>
       1996	  ```python title="Python"
       1997	  import requests
       1998	
       1999	  PROVISIONING_API_KEY = "your-provisioning-key"
       2000	  BASE_URL = "https://openrouter.ai/api/v1/keys"
       2001	
       2002	  # List the most recent 100 API keys
       2003	  response = requests.get(
       2004	      BASE_URL,
       2005	      headers={
       2006	          "Authorization": f"Bearer {PROVISIONING_API_KEY}",
       2007	          "Content-Type": "application/json"
       2008	      }
       2009	  )
       2010	
       2011	  # You can paginate using the offset parameter
       2012	  response = requests.get(
       2013	      f"{BASE_URL}?offset=100",
       2014	      headers={
       2015	          "Authorization": f"Bearer {PROVISIONING_API_KEY}",
       2016	          "Content-Type": "application/json"
       2017	      }
       2018	  )
       2019	
       2020	  # Create a new API key
       2021	  response = requests.post(
       2022	      f"{BASE_URL}/",
       2023	      headers={
       2024	          "Authorization": f"Bearer {PROVISIONING_API_KEY}",
       2025	          "Content-Type": "application/json"
       2026	      },
       2027	      json={
       2028	          "name": "Customer Instance Key",
       2029	          "label": "customer-123",
       2030	          "limit": 1000  # Optional credit limit
       2031	      }
       2032	  )
       2033	
       2034	  # Get a specific key
       2035	  key_hash = "<YOUR_KEY_HASH>"
       2036	  response = requests.get(
       2037	      f"{BASE_URL}/{key_hash}",
       2038	      headers={
       2039	          "Authorization": f"Bearer {PROVISIONING_API_KEY}",
       2040	          "Content-Type": "application/json"
       2041	      }
       2042	  )
       2043	
       2044	  # Update a key
       2045	  response = requests.patch(
       2046	      f"{BASE_URL}/{key_hash}",
       2047	      headers={
       2048	          "Authorization": f"Bearer {PROVISIONING_API_KEY}",
       2049	          "Content-Type": "application/json"
       2050	      },
       2051	      json={
       2052	          "name": "Updated Key Name",
       2053	          "disabled": True  # Disable the key
       2054	      }
       2055	  )
       2056	
       2057	  # Delete a key
       2058	  response = requests.delete(
       2059	      f"{BASE_URL}/{key_hash}",
       2060	      headers={
       2061	          "Authorization": f"Bearer {PROVISIONING_API_KEY}",
       2062	          "Content-Type": "application/json"
       2063	      }
       2064	  )
       2065	  ```
       2066	
       2067	  ```typescript title="TypeScript"
       2068	  const PROVISIONING_API_KEY = 'your-provisioning-key';
       2069	  const BASE_URL = 'https://openrouter.ai/api/v1/keys';
       2070	
       2071	  // List the most recent 100 API keys
       2072	  const listKeys = await fetch(BASE_URL, {
       2073	    headers: {
       2074	      Authorization: `Bearer ${PROVISIONING_API_KEY}`,
       2075	      'Content-Type': 'application/json',
       2076	    },
       2077	  });
       2078	
       2079	  // You can paginate using the `offset` query parameter
       2080	  const listKeys = await fetch(`${BASE_URL}?offset=100`, {
       2081	    headers: {
       2082	      Authorization: `Bearer ${PROVISIONING_API_KEY}`,
       2083	      'Content-Type': 'application/json',
       2084	    },
       2085	  });
       2086	
       2087	  // Create a new API key
       2088	  const createKey = await fetch(`${BASE_URL}`, {
       2089	    method: 'POST',
       2090	    headers: {
       2091	      Authorization: `Bearer ${PROVISIONING_API_KEY}`,
       2092	      'Content-Type': 'application/json',
       2093	    },
       2094	    body: JSON.stringify({
       2095	      name: 'Customer Instance Key',
       2096	      label: 'customer-123',
       2097	      limit: 1000, // Optional credit limit
       2098	    }),
       2099	  });
       2100	
       2101	  // Get a specific key
       2102	  const keyHash = '<YOUR_KEY_HASH>';
       2103	  const getKey = await fetch(`${BASE_URL}/${keyHash}`, {
       2104	    headers: {
       2105	      Authorization: `Bearer ${PROVISIONING_API_KEY}`,
       2106	      'Content-Type': 'application/json',
       2107	    },
       2108	  });
       2109	
       2110	  // Update a key
       2111	  const updateKey = await fetch(`${BASE_URL}/${keyHash}`, {
       2112	    method: 'PATCH',
       2113	    headers: {
       2114	      Authorization: `Bearer ${PROVISIONING_API_KEY}`,
       2115	      'Content-Type': 'application/json',
       2116	    },
       2117	    body: JSON.stringify({
       2118	      name: 'Updated Key Name',
       2119	      disabled: true, // Disable the key
       2120	    }),
       2121	  });
       2122	
       2123	  // Delete a key
       2124	  const deleteKey = await fetch(`${BASE_URL}/${keyHash}`, {
       2125	    method: 'DELETE',
       2126	    headers: {
       2127	      Authorization: `Bearer ${PROVISIONING_API_KEY}`,
       2128	      'Content-Type': 'application/json',
       2129	    },
       2130	  });
       2131	  ```
       2132	</CodeGroup>
       2133	
       2134	## Response Format
       2135	
       2136	API responses return JSON objects containing key information:
       2137	
       2138	```json
       2139	{
       2140	  "data": [
       2141	    {
       2142	      "created_at": "2025-02-19T20:52:27.363244+00:00",
       2143	      "updated_at": "2025-02-19T21:24:11.708154+00:00",
       2144	      "hash": "<YOUR_KEY_HASH>",
       2145	      "label": "sk-or-v1-customkey",
       2146	      "name": "Customer Key",
       2147	      "disabled": false,
       2148	      "limit": 10,
       2149	      "usage": 0
       2150	    }
       2151	  ]
       2152	}
       2153	```
       2154	
       2155	When creating a new key, the response will include the key string itself.
       2156	
       2157	
       2158	# API Reference
       2159	
       2160	> Comprehensive guide to OpenRouter's API. Learn about request/response schemas, authentication, parameters, and integration with multiple AI model providers.
       2161	
       2162	OpenRouter's request and response schemas are very similar to the OpenAI Chat API, with a few small differences. At a high level, **OpenRouter normalizes the schema across models and providers** so you only need to learn one.
       2163	
       2164	## Requests
       2165	
       2166	### Completions Request Format
       2167	
       2168	Here is the request schema as a TypeScript type. This will be the body of your `POST` request to the `/api/v1/chat/completions` endpoint (see the [quick start](/docs/quick-start) above for an example).
       2169	
       2170	For a complete list of parameters, see the [Parameters](/docs/api-reference/parameters).
       2171	
       2172	<CodeGroup>
       2173	  ```typescript title="Request Schema"
       2174	  // Definitions of subtypes are below
       2175	  type Request = {
       2176	    // Either "messages" or "prompt" is required
       2177	    messages?: Message[];
       2178	    prompt?: string;
       2179	
       2180	    // If "model" is unspecified, uses the user's default
       2181	    model?: string; // See "Supported Models" section
       2182	
       2183	    // Allows to force the model to produce specific output format.
       2184	    // See models page and note on this docs page for which models support it.
       2185	    response_format?: { type: 'json_object' };
       2186	
       2187	    stop?: string | string[];
       2188	    stream?: boolean; // Enable streaming
       2189	
       2190	    // See LLM Parameters (openrouter.ai/docs/api-reference/parameters)
       2191	    max_tokens?: number; // Range: [1, context_length)
       2192	    temperature?: number; // Range: [0, 2]
       2193	
       2194	    // Tool calling
       2195	    // Will be passed down as-is for providers implementing OpenAI's interface.
       2196	    // For providers with custom interfaces, we transform and map the properties.
       2197	    // Otherwise, we transform the tools into a YAML template. The model responds with an assistant message.
       2198	    // See models supporting tool calling: openrouter.ai/models?supported_parameters=tools
       2199	    tools?: Tool[];
       2200	    tool_choice?: ToolChoice;
       2201	
       2202	    // Advanced optional parameters
       2203	    seed?: number; // Integer only
       2204	    top_p?: number; // Range: (0, 1]
       2205	    top_k?: number; // Range: [1, Infinity) Not available for OpenAI models
       2206	    frequency_penalty?: number; // Range: [-2, 2]
       2207	    presence_penalty?: number; // Range: [-2, 2]
       2208	    repetition_penalty?: number; // Range: (0, 2]
       2209	    logit_bias?: { [key: number]: number };
       2210	    top_logprobs: number; // Integer only
       2211	    min_p?: number; // Range: [0, 1]
       2212	    top_a?: number; // Range: [0, 1]
       2213	
       2214	    // Reduce latency by providing the model with a predicted output
       2215	    // https://platform.openai.com/docs/guides/latency-optimization#use-predicted-outputs
       2216	    prediction?: { type: 'content'; content: string };
       2217	
       2218	    // OpenRouter-only parameters
       2219	    // See "Prompt Transforms" section: openrouter.ai/docs/transforms
       2220	    transforms?: string[];
       2221	    // See "Model Routing" section: openrouter.ai/docs/model-routing
       2222	    models?: string[];
       2223	    route?: 'fallback';
       2224	    // See "Provider Routing" section: openrouter.ai/docs/provider-routing
       2225	    provider?: ProviderPreferences;
       2226	  };
       2227	
       2228	  // Subtypes:
       2229	
       2230	  type TextContent = {
       2231	    type: 'text';
       2232	    text: string;
       2233	  };
       2234	
       2235	  type ImageContentPart = {
       2236	    type: 'image_url';
       2237	    image_url: {
       2238	      url: string; // URL or base64 encoded image data
       2239	      detail?: string; // Optional, defaults to "auto"
       2240	    };
       2241	  };
       2242	
       2243	  type ContentPart = TextContent | ImageContentPart;
       2244	
       2245	  type Message =
       2246	    | {
       2247	        role: 'user' | 'assistant' | 'system';
       2248	        // ContentParts are only for the "user" role:
       2249	        content: string | ContentPart[];
       2250	        // If "name" is included, it will be prepended like this
       2251	        // for non-OpenAI models: `{name}: {content}`
       2252	        name?: string;
       2253	      }
       2254	    | {
       2255	        role: 'tool';
       2256	        content: string;
       2257	        tool_call_id: string;
       2258	        name?: string;
       2259	      };
       2260	
       2261	  type FunctionDescription = {
       2262	    description?: string;
       2263	    name: string;
       2264	    parameters: object; // JSON Schema object
       2265	  };
       2266	
       2267	  type Tool = {
       2268	    type: 'function';
       2269	    function: FunctionDescription;
       2270	  };
       2271	
       2272	  type ToolChoice =
       2273	    | 'none'
       2274	    | 'auto'
       2275	    | {
       2276	        type: 'function';
       2277	        function: {
       2278	          name: string;
       2279	        };
       2280	      };
       2281	  ```
       2282	</CodeGroup>
       2283	
       2284	The `response_format` parameter ensures you receive a structured response from the LLM. The parameter is only supported by OpenAI models, Nitro models, and some others - check the providers on the model page on openrouter.ai/models to see if it's supported, and set `require_parameters` to true in your Provider Preferences. See [Provider Routing](/docs/features/provider-routing)
       2285	
       2286	### Headers
       2287	
       2288	OpenRouter allows you to specify some optional headers to identify your app and make it discoverable to users on our site.
       2289	
       2290	* `HTTP-Referer`: Identifies your app on openrouter.ai
       2291	* `X-Title`: Sets/modifies your app's title
       2292	
       2293	<CodeGroup>
       2294	  ```typescript title="TypeScript"
       2295	  fetch('https://openrouter.ai/api/v1/chat/completions', {
       2296	    method: 'POST',
       2297	    headers: {
       2298	      Authorization: 'Bearer <OPENROUTER_API_KEY>',
       2299	      'HTTP-Referer': '<YOUR_SITE_URL>', // Optional. Site URL for rankings on openrouter.ai.
       2300	      'X-Title': '<YOUR_SITE_NAME>', // Optional. Site title for rankings on openrouter.ai.
       2301	      'Content-Type': 'application/json',
       2302	    },
       2303	    body: JSON.stringify({
       2304	      model: 'openai/gpt-4o',
       2305	      messages: [
       2306	        {
       2307	          role: 'user',
       2308	          content: 'What is the meaning of life?',
       2309	        },
       2310	      ],
       2311	    }),
       2312	  });
       2313	  ```
       2314	</CodeGroup>
       2315	
       2316	<Info title="Model routing">
       2317	  If the `model` parameter is omitted, the user or payer's default is used.
       2318	  Otherwise, remember to select a value for `model` from the [supported
       2319	  models](/models) or [API](/api/v1/models), and include the organization
       2320	  prefix. OpenRouter will select the least expensive and best GPUs available to
       2321	  serve the request, and fall back to other providers or GPUs if it receives a
       2322	  5xx response code or if you are rate-limited.
       2323	</Info>
       2324	
       2325	<Info title="Streaming">
       2326	  [Server-Sent Events
       2327	  (SSE)](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#event_stream_format)
       2328	  are supported as well, to enable streaming *for all models*. Simply send
       2329	  `stream: true` in your request body. The SSE stream will occasionally contain
       2330	  a "comment" payload, which you should ignore (noted below).
       2331	</Info>
       2332	
       2333	<Info title="Non-standard parameters">
       2334	  If the chosen model doesn't support a request parameter (such as `logit_bias`
       2335	  in non-OpenAI models, or `top_k` for OpenAI), then the parameter is ignored.
       2336	  The rest are forwarded to the underlying model API.
       2337	</Info>
       2338	
       2339	### Assistant Prefill
       2340	
       2341	OpenRouter supports asking models to complete a partial response. This can be useful for guiding models to respond in a certain way.
       2342	
       2343	To use this features, simply include a message with `role: "assistant"` at the end of your `messages` array.
       2344	
       2345	<CodeGroup>
       2346	  ```typescript title="TypeScript"
       2347	  fetch('https://openrouter.ai/api/v1/chat/completions', {
       2348	    method: 'POST',
       2349	    headers: {
       2350	      Authorization: 'Bearer <OPENROUTER_API_KEY>',
       2351	      'Content-Type': 'application/json',
       2352	    },
       2353	    body: JSON.stringify({
       2354	      model: 'openai/gpt-4o',
       2355	      messages: [
       2356	        { role: 'user', content: 'What is the meaning of life?' },
       2357	        { role: 'assistant', content: "I'm not sure, but my best guess is" },
       2358	      ],
       2359	    }),
       2360	  });
       2361	  ```
       2362	</CodeGroup>
       2363	
       2364	## Responses
       2365	
       2366	### CompletionsResponse Format
       2367	
       2368	OpenRouter normalizes the schema across models and providers to comply with the [OpenAI Chat API](https://platform.openai.com/docs/api-reference/chat).
       2369	
       2370	This means that `choices` is always an array, even if the model only returns one completion. Each choice will contain a `delta` property if a stream was requested and a `message` property otherwise. This makes it easier to use the same code for all models.
       2371	
       2372	Here's the response schema as a TypeScript type:
       2373	
       2374	```typescript TypeScript
       2375	// Definitions of subtypes are below
       2376	type Response = {
       2377	  id: string;
       2378	  // Depending on whether you set "stream" to "true" and
       2379	  // whether you passed in "messages" or a "prompt", you
       2380	  // will get a different output shape
       2381	  choices: (NonStreamingChoice | StreamingChoice | NonChatChoice)[];
       2382	  created: number; // Unix timestamp
       2383	  model: string;
       2384	  object: 'chat.completion' | 'chat.completion.chunk';
       2385	
       2386	  system_fingerprint?: string; // Only present if the provider supports it
       2387	
       2388	  // Usage data is always returned for non-streaming.
       2389	  // When streaming, you will get one usage object at
       2390	  // the end accompanied by an empty choices array.
       2391	  usage?: ResponseUsage;
       2392	};
       2393	```
       2394	
       2395	```typescript
       2396	// If the provider returns usage, we pass it down
       2397	// as-is. Otherwise, we count using the GPT-4 tokenizer.
       2398	
       2399	type ResponseUsage = {
       2400	  /** Including images and tools if any */
       2401	  prompt_tokens: number;
       2402	  /** The tokens generated */
       2403	  completion_tokens: number;
       2404	  /** Sum of the above two fields */
       2405	  total_tokens: number;
       2406	};
       2407	```
       2408	
       2409	```typescript
       2410	// Subtypes:
       2411	type NonChatChoice = {
       2412	  finish_reason: string | null;
       2413	  text: string;
       2414	  error?: ErrorResponse;
       2415	};
       2416	
       2417	type NonStreamingChoice = {
       2418	  finish_reason: string | null;
       2419	  native_finish_reason: string | null;
       2420	  message: {
       2421	    content: string | null;
       2422	    role: string;
       2423	    tool_calls?: ToolCall[];
       2424	  };
       2425	  error?: ErrorResponse;
       2426	};
       2427	
       2428	type StreamingChoice = {
       2429	  finish_reason: string | null;
       2430	  native_finish_reason: string | null;
       2431	  delta: {
       2432	    content: string | null;
       2433	    role?: string;
       2434	    tool_calls?: ToolCall[];
       2435	  };
       2436	  error?: ErrorResponse;
       2437	};
       2438	
       2439	type ErrorResponse = {
       2440	  code: number; // See "Error Handling" section
       2441	  message: string;
       2442	  metadata?: Record<string, unknown>; // Contains additional error information such as provider details, the raw error message, etc.
       2443	};
       2444	
       2445	type ToolCall = {
       2446	  id: string;
       2447	  type: 'function';
       2448	  function: FunctionCall;
       2449	};
       2450	```
       2451	
       2452	Here's an example:
       2453	
       2454	```json
       2455	{
       2456	  "id": "gen-xxxxxxxxxxxxxx",
       2457	  "choices": [
       2458	    {
       2459	      "finish_reason": "stop", // Normalized finish_reason
       2460	      "native_finish_reason": "stop", // The raw finish_reason from the provider
       2461	      "message": {
       2462	        // will be "delta" if streaming
       2463	        "role": "assistant",
       2464	        "content": "Hello there!"
       2465	      }
       2466	    }
       2467	  ],
       2468	  "usage": {
       2469	    "prompt_tokens": 0,
       2470	    "completion_tokens": 4,
       2471	    "total_tokens": 4
       2472	  },
       2473	  "model": "openai/gpt-3.5-turbo" // Could also be "anthropic/claude-2.1", etc, depending on the "model" that ends up being used
       2474	}
       2475	```
       2476	
       2477	### Finish Reason
       2478	
       2479	OpenRouter normalizes each model's `finish_reason` to one of the following values: `tool_calls`, `stop`, `length`, `content_filter`, `error`.
       2480	
       2481	Some models and providers may have additional finish reasons. The raw finish\_reason string returned by the model is available via the `native_finish_reason` property.
       2482	
       2483	### Querying Cost and Stats
       2484	
       2485	The token counts that are returned in the completions API response are **not** counted via the model's native tokenizer. Instead it uses a normalized, model-agnostic count (accomplished via the GPT4o tokenizer). This is because some providers do not reliably return native token counts. This behavior is becoming more rare, however, and we may add native token counts to the response object in the future.
       2486	
       2487	Credit usage and model pricing are based on the **native** token counts (not the 'normalized' token counts returned in the API response).
       2488	
       2489	For precise token accounting using the model's native tokenizer, you can retrieve the full generation information via the `/api/v1/generation` endpoint.
       2490	
       2491	You can use the returned `id` to query for the generation stats (including token counts and cost) after the request is complete. This is how you can get the cost and tokens for *all models and requests*, streaming and non-streaming.
       2492	
       2493	<CodeGroup>
       2494	  ```typescript title="Query Generation Stats"
       2495	  const generation = await fetch(
       2496	    'https://openrouter.ai/api/v1/generation?id=$GENERATION_ID',
       2497	    { headers },
       2498	  );
       2499	
       2500	  const stats = await generation.json();
       2501	  ```
       2502	</CodeGroup>
       2503	
       2504	Please see the [Generation](/docs/api-reference/get-a-generation) API reference for the full response shape.
       2505	
       2506	Note that token counts are also available in the `usage` field of the response body for non-streaming completions.
       2507	
       2508	
       2509	# Streaming
       2510	
       2511	> Learn how to implement streaming responses with OpenRouter's API. Complete guide to Server-Sent Events (SSE) and real-time model outputs.
       2512	
       2513	The OpenRouter API allows streaming responses from *any model*. This is useful for building chat interfaces or other applications where the UI should update as the model generates the response.
       2514	
       2515	To enable streaming, you can set the `stream` parameter to `true` in your request. The model will then stream the response to the client in chunks, rather than returning the entire response at once.
       2516	
       2517	Here is an example of how to stream a response, and process it:
       2518	
       2519	<Template
       2520	  data={{
       2521	  API_KEY_REF,
       2522	  MODEL: Model.GPT_4_Omni
       2523	}}
       2524	>
       2525	  <CodeGroup>
       2526	    ```python Python
       2527	    import requests
       2528	    import json
       2529	
       2530	    question = "How would you build the tallest building ever?"
       2531	
       2532	    url = "https://openrouter.ai/api/v1/chat/completions"
       2533	    headers = {
       2534	      "Authorization": f"Bearer {{API_KEY_REF}}",
       2535	      "Content-Type": "application/json"
       2536	    }
       2537	
       2538	    payload = {
       2539	      "model": "{{MODEL}}",
       2540	      "messages": [{"role": "user", "content": question}],
       2541	      "stream": True
       2542	    }
       2543	
       2544	    buffer = ""
       2545	    with requests.post(url, headers=headers, json=payload, stream=True) as r:
       2546	      for chunk in r.iter_content(chunk_size=1024, decode_unicode=True):
       2547	        buffer += chunk
       2548	        while True:
       2549	          try:
       2550	            # Find the next complete SSE line
       2551	            line_end = buffer.find('\n')
       2552	            if line_end == -1:
       2553	              break
       2554	
       2555	            line = buffer[:line_end].strip()
       2556	            buffer = buffer[line_end + 1:]
       2557	
       2558	            if line.startswith('data: '):
       2559	              data = line[6:]
       2560	              if data == '[DONE]':
       2561	                break
       2562	
       2563	              try:
       2564	                data_obj = json.loads(data)
       2565	                content = data_obj["choices"][0]["delta"].get("content")
       2566	                if content:
       2567	                  print(content, end="", flush=True)
       2568	              except json.JSONDecodeError:
       2569	                pass
       2570	          except Exception:
       2571	            break
       2572	    ```
       2573	
       2574	    ```typescript TypeScript
       2575	    const question = 'How would you build the tallest building ever?';
       2576	    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
       2577	      method: 'POST',
       2578	      headers: {
       2579	        Authorization: `Bearer ${API_KEY_REF}`,
       2580	        'Content-Type': 'application/json',
       2581	      },
       2582	      body: JSON.stringify({
       2583	        model: '{{MODEL}}',
       2584	        messages: [{ role: 'user', content: question }],
       2585	        stream: true,
       2586	      }),
       2587	    });
       2588	
       2589	    const reader = response.body?.getReader();
       2590	    if (!reader) {
       2591	      throw new Error('Response body is not readable');
       2592	    }
       2593	
       2594	    const decoder = new TextDecoder();
       2595	    let buffer = '';
       2596	
       2597	    try {
       2598	      while (true) {
       2599	        const { done, value } = await reader.read();
       2600	        if (done) break;
       2601	
       2602	        // Append new chunk to buffer
       2603	        buffer += decoder.decode(value, { stream: true });
       2604	
       2605	        // Process complete lines from buffer
       2606	        while (true) {
       2607	          const lineEnd = buffer.indexOf('\n');
       2608	          if (lineEnd === -1) break;
       2609	
       2610	          const line = buffer.slice(0, lineEnd).trim();
       2611	          buffer = buffer.slice(lineEnd + 1);
       2612	
       2613	          if (line.startsWith('data: ')) {
       2614	            const data = line.slice(6);
       2615	            if (data === '[DONE]') break;
       2616	
       2617	            try {
       2618	              const parsed = JSON.parse(data);
       2619	              const content = parsed.choices[0].delta.content;
       2620	              if (content) {
       2621	                console.log(content);
       2622	              }
       2623	            } catch (e) {
       2624	              // Ignore invalid JSON
       2625	            }
       2626	          }
       2627	        }
       2628	      }
       2629	    } finally {
       2630	      reader.cancel();
       2631	    }
       2632	    ```
       2633	  </CodeGroup>
       2634	</Template>
       2635	
       2636	### Additional Information
       2637	
       2638	For SSE (Server-Sent Events) streams, OpenRouter occasionally sends comments to prevent connection timeouts. These comments look like:
       2639	
       2640	```text
       2641	: OPENROUTER PROCESSING
       2642	```
       2643	
       2644	Comment payload can be safely ignored per the [SSE specs](https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation). However, you can leverage it to improve UX as needed, e.g. by showing a dynamic loading indicator.
       2645	
       2646	Some SSE client implementations might not parse the payload according to spec, which leads to an uncaught error when you `JSON.stringify` the non-JSON payloads. We recommend the following clients:
       2647	
       2648	* [eventsource-parser](https://github.com/rexxars/eventsource-parser)
       2649	* [OpenAI SDK](https://www.npmjs.com/package/openai)
       2650	* [Vercel AI SDK](https://www.npmjs.com/package/ai)
       2651	
       2652	### Stream Cancellation
       2653	
       2654	Streaming requests can be cancelled by aborting the connection. For supported providers, this immediately stops model processing and billing.
       2655	
       2656	<Accordion title="Provider Support">
       2657	  **Supported**
       2658	
       2659	  * OpenAI, Azure, Anthropic
       2660	  * Fireworks, Mancer, Recursal
       2661	  * AnyScale, Lepton, OctoAI
       2662	  * Novita, DeepInfra, Together
       2663	  * Cohere, Hyperbolic, Infermatic
       2664	  * Avian, XAI, Cloudflare
       2665	  * SFCompute, Nineteen, Liquid
       2666	  * Friendli, Chutes, DeepSeek
       2667	
       2668	  **Not Currently Supported**
       2669	
       2670	  * AWS Bedrock, Groq, Modal
       2671	  * Google, Google AI Studio, Minimax
       2672	  * HuggingFace, Replicate, Perplexity
       2673	  * Mistral, AI21, Featherless
       2674	  * Lynn, Lambda, Reflection
       2675	  * SambaNova, Inflection, ZeroOneAI
       2676	  * AionLabs, Alibaba, Nebius
       2677	  * Kluster, Targon, InferenceNet
       2678	</Accordion>
       2679	
       2680	To implement stream cancellation:
       2681	
       2682	<Template
       2683	  data={{
       2684	  API_KEY_REF,
       2685	  MODEL: Model.GPT_4_Omni
       2686	}}
       2687	>
       2688	  <CodeGroup>
       2689	    ```python Python
       2690	    import requests
       2691	    from threading import Event, Thread
       2692	
       2693	    def stream_with_cancellation(prompt: str, cancel_event: Event):
       2694	        with requests.Session() as session:
       2695	            response = session.post(
       2696	                "https://openrouter.ai/api/v1/chat/completions",
       2697	                headers={"Authorization": f"Bearer {{API_KEY_REF}}"},
       2698	                json={"model": "{{MODEL}}", "messages": [{"role": "user", "content": prompt}], "stream": True},
       2699	                stream=True
       2700	            )
       2701	
       2702	            try:
       2703	                for line in response.iter_lines():
       2704	                    if cancel_event.is_set():
       2705	                        response.close()
       2706	                        return
       2707	                    if line:
       2708	                        print(line.decode(), end="", flush=True)
       2709	            finally:
       2710	                response.close()
       2711	
       2712	    # Example usage:
       2713	    cancel_event = Event()
       2714	    stream_thread = Thread(target=lambda: stream_with_cancellation("Write a story", cancel_event))
       2715	    stream_thread.start()
       2716	
       2717	    # To cancel the stream:
       2718	    cancel_event.set()
       2719	    ```
       2720	
       2721	    ```typescript TypeScript
       2722	    const controller = new AbortController();
       2723	
       2724	    try {
       2725	      const response = await fetch(
       2726	        'https://openrouter.ai/api/v1/chat/completions',
       2727	        {
       2728	          method: 'POST',
       2729	          headers: {
       2730	            Authorization: `Bearer ${{{API_KEY_REF}}}`,
       2731	            'Content-Type': 'application/json',
       2732	          },
       2733	          body: JSON.stringify({
       2734	            model: '{{MODEL}}',
       2735	            messages: [{ role: 'user', content: 'Write a story' }],
       2736	            stream: true,
       2737	          }),
       2738	          signal: controller.signal,
       2739	        },
       2740	      );
       2741	
       2742	      // Process the stream...
       2743	    } catch (error) {
       2744	      if (error.name === 'AbortError') {
       2745	        console.log('Stream cancelled');
       2746	      } else {
       2747	        throw error;
       2748	      }
       2749	    }
       2750	
       2751	    // To cancel the stream:
       2752	    controller.abort();
       2753	    ```
       2754	  </CodeGroup>
       2755	</Template>
       2756	
       2757	<Warning>
       2758	  Cancellation only works for streaming requests with supported providers. For
       2759	  non-streaming requests or unsupported providers, the model will continue
       2760	  processing and you will be billed for the complete response.
       2761	</Warning>
       2762	
       2763	
       2764	# Images & PDFs
       2765	
       2766	> Sending images and PDFs to the OpenRouter API.
       2767	
       2768	OpenRouter supports sending images and PDFs via the API. This guide will show you how to work with both file types using our API.
       2769	
       2770	Both images and PDFs also work in the chat room.
       2771	
       2772	<Tip>
       2773	  You can send both PDF and images in the same request.
       2774	</Tip>
       2775	
       2776	## Image Inputs
       2777	
       2778	Requests with images, to multimodel models, are available via the `/api/v1/chat/completions` API with a multi-part `messages` parameter. The `image_url` can either be a URL or a base64-encoded image.
       2779	Note that multiple images can be sent in separate content array entries. The number of images you can send in a single request varies per provider and per model.
       2780	Due to how the content is parsed, we recommend sending the text prompt first, then the images. If the images must come first, we recommend putting it in the system prompt.
       2781	
       2782	### Using Image URLs
       2783	
       2784	Here's how to send an image using a URL:
       2785	
       2786	<Template
       2787	  data={{
       2788	  API_KEY_REF,
       2789	  MODEL: 'google/gemini-2.0-flash-001'
       2790	}}
       2791	>
       2792	  <CodeGroup>
       2793	    ```python
       2794	    import requests
       2795	    import json
       2796	
       2797	    url = "https://openrouter.ai/api/v1/chat/completions"
       2798	    headers = {
       2799	        "Authorization": f"Bearer {API_KEY_REF}",
       2800	        "Content-Type": "application/json"
       2801	    }
       2802	
       2803	    messages = [
       2804	        {
       2805	            "role": "user",
       2806	            "content": [
       2807	                {
       2808	                    "type": "text",
       2809	                    "text": "What's in this image?"
       2810	                },
       2811	                {
       2812	                    "type": "image_url",
       2813	                    "image_url": {
       2814	                        "url": "https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg"
       2815	                    }
       2816	                }
       2817	            ]
       2818	        }
       2819	    ]
       2820	
       2821	    payload = {
       2822	        "model": "{{MODEL}}",
       2823	        "messages": messages
       2824	    }
       2825	
       2826	    response = requests.post(url, headers=headers, json=payload)
       2827	    print(response.json())
       2828	    ```
       2829	
       2830	    ```typescript
       2831	    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
       2832	      method: 'POST',
       2833	      headers: {
       2834	        Authorization: `Bearer ${API_KEY_REF}`,
       2835	        'Content-Type': 'application/json',
       2836	      },
       2837	      body: JSON.stringify({
       2838	        model: '{{MODEL}}',
       2839	        messages: [
       2840	          {
       2841	            role: 'user',
       2842	            content: [
       2843	              {
       2844	                type: 'text',
       2845	                text: "What's in this image?",
       2846	              },
       2847	              {
       2848	                type: 'image_url',
       2849	                image_url: {
       2850	                  url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg',
       2851	                },
       2852	              },
       2853	            ],
       2854	          },
       2855	        ],
       2856	      }),
       2857	    });
       2858	
       2859	    const data = await response.json();
       2860	    console.log(data);
       2861	    ```
       2862	  </CodeGroup>
       2863	</Template>
       2864	
       2865	### Using Base64 Encoded Images
       2866	
       2867	For locally stored images, you can send them using base64 encoding. Here's how to do it:
       2868	
       2869	<Template
       2870	  data={{
       2871	  API_KEY_REF,
       2872	  MODEL: 'google/gemini-2.0-flash-001'
       2873	}}
       2874	>
       2875	  <CodeGroup>
       2876	    ```python
       2877	    import requests
       2878	    import json
       2879	    import base64
       2880	    from pathlib import Path
       2881	
       2882	    def encode_image_to_base64(image_path):
       2883	        with open(image_path, "rb") as image_file:
       2884	            return base64.b64encode(image_file.read()).decode('utf-8')
       2885	
       2886	    url = "https://openrouter.ai/api/v1/chat/completions"
       2887	    headers = {
       2888	        "Authorization": f"Bearer {API_KEY_REF}",
       2889	        "Content-Type": "application/json"
       2890	    }
       2891	
       2892	    # Read and encode the image
       2893	    image_path = "path/to/your/image.jpg"
       2894	    base64_image = encode_image_to_base64(image_path)
       2895	    data_url = f"data:image/jpeg;base64,{base64_image}"
       2896	
       2897	    messages = [
       2898	        {
       2899	            "role": "user",
       2900	            "content": [
       2901	                {
       2902	                    "type": "text",
       2903	                    "text": "What's in this image?"
       2904	                },
       2905	                {
       2906	                    "type": "image_url",
       2907	                    "image_url": {
       2908	                        "url": data_url
       2909	                    }
       2910	                }
       2911	            ]
       2912	        }
       2913	    ]
       2914	
       2915	    payload = {
       2916	        "model": "{{MODEL}}",
       2917	        "messages": messages
       2918	    }
       2919	
       2920	    response = requests.post(url, headers=headers, json=payload)
       2921	    print(response.json())
       2922	    ```
       2923	
       2924	    ```typescript
       2925	    async function encodeImageToBase64(imagePath: string): Promise<string> {
       2926	      const imageBuffer = await fs.promises.readFile(imagePath);
       2927	      const base64Image = imageBuffer.toString('base64');
       2928	      return `data:image/jpeg;base64,${base64Image}`;
       2929	    }
       2930	
       2931	    // Read and encode the image
       2932	    const imagePath = 'path/to/your/image.jpg';
       2933	    const base64Image = await encodeImageToBase64(imagePath);
       2934	
       2935	    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
       2936	      method: 'POST',
       2937	      headers: {
       2938	        Authorization: `Bearer ${API_KEY_REF}`,
       2939	        'Content-Type': 'application/json',
       2940	      },
       2941	      body: JSON.stringify({
       2942	        model: '{{MODEL}}',
       2943	        messages: [
       2944	          {
       2945	            role: 'user',
       2946	            content: [
       2947	              {
       2948	                type: 'text',
       2949	                text: "What's in this image?",
       2950	              },
       2951	              {
       2952	                type: 'image_url',
       2953	                image_url: {
       2954	                  url: base64Image,
       2955	                },
       2956	              },
       2957	            ],
       2958	          },
       2959	        ],
       2960	      }),
       2961	    });
       2962	
       2963	    const data = await response.json();
       2964	    console.log(data);
       2965	    ```
       2966	  </CodeGroup>
       2967	</Template>
       2968	
       2969	Supported image content types are:
       2970	
       2971	* `image/png`
       2972	* `image/jpeg`
       2973	* `image/webp`
       2974	
       2975	## PDF Support
       2976	
       2977	OpenRouter supports PDF processing through the `/api/v1/chat/completions` API. PDFs can be sent as base64-encoded files in the messages array.
       2978	
       2979	<Info>
       2980	  When a model supports file input natively, the PDF is passed directly to the model. When the model does not support file input natively, OpenRouter will parse the file and pass the parsed results to the requested model.
       2981	</Info>
       2982	
       2983	Note that multiple PDFs can be sent in separate content array entries. The number of PDFs you can send in a single request varies per provider and per model.
       2984	Due to how the content is parsed, we recommend sending the text prompt first, then the PDF. If the PDF must come first, we recommend putting it in the system prompt.
       2985	
       2986	### Processing PDFs
       2987	
       2988	Here's how to send and process a PDF:
       2989	
       2990	<Template
       2991	  data={{
       2992	  API_KEY_REF,
       2993	  MODEL: 'google/gemma-3-27b-it'
       2994	}}
       2995	>
       2996	  <CodeGroup>
       2997	    ```python
       2998	    import requests
       2999	    import json
       3000	    import base64
       3001	    from pathlib import Path
       3002	
       3003	    def encode_pdf_to_base64(pdf_path):
       3004	        with open(pdf_path, "rb") as pdf_file:
       3005	            return base64.b64encode(pdf_file.read()).decode('utf-8')
       3006	
       3007	    url = "https://openrouter.ai/api/v1/chat/completions"
       3008	    headers = {
       3009	        "Authorization": f"Bearer {API_KEY_REF}",
       3010	        "Content-Type": "application/json"
       3011	    }
       3012	
       3013	    # Read and encode the PDF
       3014	    pdf_path = "path/to/your/document.pdf"
       3015	    base64_pdf = encode_pdf_to_base64(pdf_path)
       3016	    data_url = f"data:application/pdf;base64,{base64_pdf}"
       3017	
       3018	    messages = [
       3019	        {
       3020	            "role": "user",
       3021	            "content": [
       3022	                {
       3023	                    "type": "text",
       3024	                    "text": "What are the main points in this document?"
       3025	                },
       3026	                {
       3027	                    "type": "file",
       3028	                    "file": {
       3029	                        "filename": "document.pdf",
       3030	                        "file_data": data_url
       3031	                    }
       3032	                },
       3033	            ]
       3034	        }
       3035	    ]
       3036	
       3037	    # Optional: Configure PDF processing engine
       3038	    # PDF parsing will still work even if the plugin is not explicitly set
       3039	    plugins = [
       3040	        {
       3041	            "id": "file-parser",
       3042	            "pdf": {
       3043	                "engine": "pdf-text"  # or "mistral-ocr" for scanned documents
       3044	            }
       3045	        }
       3046	    ]
       3047	
       3048	    payload = {
       3049	        "model": "{{MODEL}}",
       3050	        "messages": messages,
       3051	        "plugins": plugins
       3052	    }
       3053	
       3054	    response = requests.post(url, headers=headers, json=payload)
       3055	    print(response.json())
       3056	    ```
       3057	
       3058	    ```typescript
       3059	    async function encodePDFToBase64(pdfPath: string): Promise<string> {
       3060	      const pdfBuffer = await fs.promises.readFile(pdfPath);
       3061	      const base64PDF = pdfBuffer.toString('base64');
       3062	      return `data:application/pdf;base64,${base64PDF}`;
       3063	    }
       3064	
       3065	    // Read and encode the PDF
       3066	    const pdfPath = 'path/to/your/document.pdf';
       3067	    const base64PDF = await encodePDFToBase64(pdfPath);
       3068	
       3069	    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
       3070	      method: 'POST',
       3071	      headers: {
       3072	        Authorization: `Bearer ${API_KEY_REF}`,
       3073	        'Content-Type': 'application/json',
       3074	      },
       3075	      body: JSON.stringify({
       3076	        model: '{{MODEL}}',
       3077	        messages: [
       3078	          {
       3079	            role: 'user',
       3080	            content: [
       3081	              {
       3082	                type: 'file',
       3083	                file: {
       3084	                  filename: 'document.pdf',
       3085	                  file_data: base64PDF,
       3086	                },
       3087	              },
       3088	              {
       3089	                type: 'text',
       3090	                text: 'What are the main points in this document?',
       3091	              },
       3092	            ],
       3093	          },
       3094	        ],
       3095	        // Optional: Configure PDF processing engine
       3096	        // PDF parsing will still work even if the plugin is not explicitly set
       3097	        plugins: [
       3098	          {
       3099	            id: 'file-parser',
       3100	            pdf: {
       3101	              engine: 'pdf-text', // or "mistral-ocr" for scanned documents
       3102	            },
       3103	          },
       3104	        ],
       3105	      }),
       3106	    });
       3107	
       3108	    const data = await response.json();
       3109	    console.log(data);
       3110	    ```
       3111	  </CodeGroup>
       3112	</Template>
       3113	
       3114	### PDF Processing Engines
       3115	
       3116	OpenRouter provides two PDF processing engines:
       3117	
       3118	1. `pdf-text` (default): Best for well-structured PDFs with clear text content
       3119	2. `mistral-ocr`: Better for scanned documents or PDFs containing images of text
       3120	
       3121	Note: The `mistral-ocr` engine incurs additional costs (\$2/1k pages) but provides better results for complex PDFs.
       3122	
       3123	### Response Format
       3124	
       3125	The API will return a response in the following format:
       3126	
       3127	```json
       3128	{
       3129	  "id": "gen-1234567890",
       3130	  "provider": "DeepInfra",
       3131	  "model": "google/gemma-3-27b-it",
       3132	  "object": "chat.completion",
       3133	  "created": 1234567890,
       3134	  "choices": [
       3135	    {
       3136	      "message": {
       3137	        "role": "assistant",
       3138	        "content": "The document discusses..."
       3139	      }
       3140	    }
       3141	  ],
       3142	  "usage": {
       3143	    "prompt_tokens": 1000,
       3144	    "completion_tokens": 100,
       3145	    "total_tokens": 1100
       3146	  }
       3147	}
       3148	```
       3149	
       3150	
       3151	# Authentication
       3152	
       3153	> Learn how to authenticate with OpenRouter using API keys and Bearer tokens. Complete guide to secure authentication methods and best practices.
       3154	
       3155	You can cover model costs with OpenRouter API keys.
       3156	
       3157	Our API authenticates requests using Bearer tokens. This allows you to use `curl` or the [OpenAI SDK](https://platform.openai.com/docs/frameworks) directly with OpenRouter.
       3158	
       3159	<Warning>
       3160	  API keys on OpenRouter are more powerful than keys used directly for model APIs.
       3161	
       3162	  They allow users to set credit limits for apps, and they can be used in [OAuth](/docs/use-cases/oauth-pkce) flows.
       3163	</Warning>
       3164	
       3165	## Using an API key
       3166	
       3167	To use an API key, [first create your key](https://openrouter.ai/keys). Give it a name and you can optionally set a credit limit.
       3168	
       3169	If you're calling the OpenRouter API directly, set the `Authorization` header to a Bearer token with your API key.
       3170	
       3171	If you're using the OpenAI Typescript SDK, set the `api_base` to `https://openrouter.ai/api/v1` and the `apiKey` to your API key.
       3172	
       3173	<CodeGroup>
       3174	  ```typescript title="TypeScript (Bearer Token)"
       3175	  fetch('https://openrouter.ai/api/v1/chat/completions', {
       3176	    method: 'POST',
       3177	    headers: {
       3178	      Authorization: 'Bearer <OPENROUTER_API_KEY>',
       3179	      'HTTP-Referer': '<YOUR_SITE_URL>', // Optional. Site URL for rankings on openrouter.ai.
       3180	      'X-Title': '<YOUR_SITE_NAME>', // Optional. Site title for rankings on openrouter.ai.
       3181	      'Content-Type': 'application/json',
       3182	    },
       3183	    body: JSON.stringify({
       3184	      model: 'openai/gpt-4o',
       3185	      messages: [
       3186	        {
       3187	          role: 'user',
       3188	          content: 'What is the meaning of life?',
       3189	        },
       3190	      ],
       3191	    }),
       3192	  });
       3193	  ```
       3194	
       3195	  ```typescript title="TypeScript (OpenAI SDK)"
       3196	  import OpenAI from 'openai';
       3197	
       3198	  const openai = new OpenAI({
       3199	    baseURL: 'https://openrouter.ai/api/v1',
       3200	    apiKey: '<OPENROUTER_API_KEY>',
       3201	    defaultHeaders: {
       3202	      'HTTP-Referer': '<YOUR_SITE_URL>', // Optional. Site URL for rankings on openrouter.ai.
       3203	      'X-Title': '<YOUR_SITE_NAME>', // Optional. Site title for rankings on openrouter.ai.
       3204	    },
       3205	  });
       3206	
       3207	  async function main() {
       3208	    const completion = await openai.chat.completions.create({
       3209	      model: 'openai/gpt-4o',
       3210	      messages: [{ role: 'user', content: 'Say this is a test' }],
       3211	    });
       3212	
       3213	    console.log(completion.choices[0].message);
       3214	  }
       3215	
       3216	  main();
       3217	  ```
       3218	
       3219	  ```python title="Python"
       3220	  import openai
       3221	
       3222	  openai.api_base = "https://openrouter.ai/api/v1"
       3223	  openai.api_key = "<OPENROUTER_API_KEY>"
       3224	
       3225	  response = openai.ChatCompletion.create(
       3226	    model="openai/gpt-4o",
       3227	    messages=[...],
       3228	    headers={
       3229	      "HTTP-Referer": "<YOUR_SITE_URL>", # Optional. Site URL for rankings on openrouter.ai.
       3230	      "X-Title": "<YOUR_SITE_NAME>", # Optional. Site title for rankings on openrouter.ai.
       3231	    },
       3232	  )
       3233	
       3234	  reply = response.choices[0].message
       3235	  ```
       3236	
       3237	  ```shell title="Shell"
       3238	  curl https://openrouter.ai/api/v1/chat/completions \
       3239	    -H "Content-Type: application/json" \
       3240	    -H "Authorization: Bearer $OPENROUTER_API_KEY" \
       3241	    -d '{
       3242	    "model": "openai/gpt-4o",
       3243	    "messages": [
       3244	      {"role": "system", "content": "You are a helpful assistant."},
       3245	      {"role": "user", "content": "Hello!"}
       3246	    ]
       3247	  }'
       3248	  ```
       3249	</CodeGroup>
       3250	
       3251	To stream with Python, [see this example from OpenAI](https://github.com/openai/openai-cookbook/blob/main/examples/How_to_stream_completions.ipynb).
       3252	
       3253	## If your key has been exposed
       3254	
       3255	<Warning>
       3256	  You must protect your API keys and never commit them to public repositories.
       3257	</Warning>
       3258	
       3259	OpenRouter is a GitHub secret scanning partner, and has other methods to detect exposed keys. If we determine that your key has been compromised, you will receive an email notification.
       3260	
       3261	If you receive such a notification or suspect your key has been exposed, immediately visit [your key settings page](https://openrouter.ai/settings/keys) to delete the compromised key and create a new one.
       3262	
       3263	Using environment variables and keeping keys out of your codebase is strongly recommended.
       3264	
       3265	
       3266	# Parameters
       3267	
       3268	> Learn about all available parameters for OpenRouter API requests. Configure temperature, max tokens, top_p, and other model-specific settings.
       3269	
       3270	Sampling parameters shape the token generation process of the model. You may send any parameters from the following list, as well as others, to OpenRouter.
       3271	
       3272	OpenRouter will default to the values listed below if certain parameters are absent from your request (for example, `temperature` to 1.0). We will also transmit some provider-specific parameters, such as `safe_prompt` for Mistral or `raw_mode` for Hyperbolic directly to the respective providers if specified.
       3273	
       3274	Please refer to the model’s provider section to confirm which parameters are supported. For detailed guidance on managing provider-specific parameters, [click here](/docs/features/provider-routing#requiring-providers-to-support-all-parameters-beta).
       3275	
       3276	## Temperature
       3277	
       3278	* Key: `temperature`
       3279	
       3280	* Optional, **float**, 0.0 to 2.0
       3281	
       3282	* Default: 1.0
       3283	
       3284	* Explainer Video: [Watch](https://youtu.be/ezgqHnWvua8)
       3285	
       3286	This setting influences the variety in the model's responses. Lower values lead to more predictable and typical responses, while higher values encourage more diverse and less common responses. At 0, the model always gives the same response for a given input.
       3287	
       3288	## Top P
       3289	
       3290	* Key: `top_p`
       3291	
       3292	* Optional, **float**, 0.0 to 1.0
       3293	
       3294	* Default: 1.0
       3295	
       3296	* Explainer Video: [Watch](https://youtu.be/wQP-im_HInk)
       3297	
       3298	This setting limits the model's choices to a percentage of likely tokens: only the top tokens whose probabilities add up to P. A lower value makes the model's responses more predictable, while the default setting allows for a full range of token choices. Think of it like a dynamic Top-K.
       3299	
       3300	## Top K
       3301	
       3302	* Key: `top_k`
       3303	
       3304	* Optional, **integer**, 0 or above
       3305	
       3306	* Default: 0
       3307	
       3308	* Explainer Video: [Watch](https://youtu.be/EbZv6-N8Xlk)
       3309	
       3310	This limits the model's choice of tokens at each step, making it choose from a smaller set. A value of 1 means the model will always pick the most likely next token, leading to predictable results. By default this setting is disabled, making the model to consider all choices.
       3311	
       3312	## Frequency Penalty
       3313	
       3314	* Key: `frequency_penalty`
       3315	
       3316	* Optional, **float**, -2.0 to 2.0
       3317	
       3318	* Default: 0.0
       3319	
       3320	* Explainer Video: [Watch](https://youtu.be/p4gl6fqI0_w)
       3321	
       3322	This setting aims to control the repetition of tokens based on how often they appear in the input. It tries to use less frequently those tokens that appear more in the input, proportional to how frequently they occur. Token penalty scales with the number of occurrences. Negative values will encourage token reuse.
       3323	
       3324	## Presence Penalty
       3325	
       3326	* Key: `presence_penalty`
       3327	
       3328	* Optional, **float**, -2.0 to 2.0
       3329	
       3330	* Default: 0.0
       3331	
       3332	* Explainer Video: [Watch](https://youtu.be/MwHG5HL-P74)
       3333	
       3334	Adjusts how often the model repeats specific tokens already used in the input. Higher values make such repetition less likely, while negative values do the opposite. Token penalty does not scale with the number of occurrences. Negative values will encourage token reuse.
       3335	
       3336	## Repetition Penalty
       3337	
       3338	* Key: `repetition_penalty`
       3339	
       3340	* Optional, **float**, 0.0 to 2.0
       3341	
       3342	* Default: 1.0
       3343	
       3344	* Explainer Video: [Watch](https://youtu.be/LHjGAnLm3DM)
       3345	
       3346	Helps to reduce the repetition of tokens from the input. A higher value makes the model less likely to repeat tokens, but too high a value can make the output less coherent (often with run-on sentences that lack small words). Token penalty scales based on original token's probability.
       3347	
       3348	## Min P
       3349	
       3350	* Key: `min_p`
       3351	
       3352	* Optional, **float**, 0.0 to 1.0
       3353	
       3354	* Default: 0.0
       3355	
       3356	Represents the minimum probability for a token to be
       3357	considered, relative to the probability of the most likely token. (The value changes depending on the confidence level of the most probable token.) If your Min-P is set to 0.1, that means it will only allow for tokens that are at least 1/10th as probable as the best possible option.
       3358	
       3359	## Top A
       3360	
       3361	* Key: `top_a`
       3362	
       3363	* Optional, **float**, 0.0 to 1.0
       3364	
       3365	* Default: 0.0
       3366	
       3367	Consider only the top tokens with "sufficiently high" probabilities based on the probability of the most likely token. Think of it like a dynamic Top-P. A lower Top-A value focuses the choices based on the highest probability token but with a narrower scope. A higher Top-A value does not necessarily affect the creativity of the output, but rather refines the filtering process based on the maximum probability.
       3368	
       3369	## Seed
       3370	
       3371	* Key: `seed`
       3372	
       3373	* Optional, **integer**
       3374	
       3375	If specified, the inferencing will sample deterministically, such that repeated requests with the same seed and parameters should return the same result. Determinism is not guaranteed for some models.
       3376	
       3377	## Max Tokens
       3378	
       3379	* Key: `max_tokens`
       3380	
       3381	* Optional, **integer**, 1 or above
       3382	
       3383	This sets the upper limit for the number of tokens the model can generate in response. It won't produce more than this limit. The maximum value is the context length minus the prompt length.
       3384	
       3385	## Logit Bias
       3386	
       3387	* Key: `logit_bias`
       3388	
       3389	* Optional, **map**
       3390	
       3391	Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
       3392	
       3393	## Logprobs
       3394	
       3395	* Key: `logprobs`
       3396	
       3397	* Optional, **boolean**
       3398	
       3399	Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned.
       3400	
       3401	## Top Logprobs
       3402	
       3403	* Key: `top_logprobs`
       3404	
       3405	* Optional, **integer**
       3406	
       3407	An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
       3408	
       3409	## Response Format
       3410	
       3411	* Key: `response_format`
       3412	
       3413	* Optional, **map**
       3414	
       3415	Forces the model to produce specific output format. Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
       3416	
       3417	**Note**: when using JSON mode, you should also instruct the model to produce JSON yourself via a system or user message.
       3418	
       3419	## Structured Outputs
       3420	
       3421	* Key: `structured_outputs`
       3422	
       3423	* Optional, **boolean**
       3424	
       3425	If the model can return structured outputs using response\_format json\_schema.
       3426	
       3427	## Stop
       3428	
       3429	* Key: `stop`
       3430	
       3431	* Optional, **array**
       3432	
       3433	Stop generation immediately if the model encounter any token specified in the stop array.
       3434	
       3435	## Tools
       3436	
       3437	* Key: `tools`
       3438	
       3439	* Optional, **array**
       3440	
       3441	Tool calling parameter, following OpenAI's tool calling request shape. For non-OpenAI providers, it will be transformed accordingly. [Click here to learn more about tool calling](/docs/requests#tool-calls)
       3442	
       3443	## Tool Choice
       3444	
       3445	* Key: `tool_choice`
       3446	
       3447	* Optional, **array**
       3448	
       3449	Controls which (if any) tool is called by the model. 'none' means the model will not call any tool and instead generates a message. 'auto' means the model can pick between generating a message or calling one or more tools. 'required' means the model must call one or more tools. Specifying a particular tool via `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
       3450	
       3451	## Max Price
       3452	
       3453	* Key: `max_price`
       3454	
       3455	* Optional, **map**
       3456	
       3457	A JSON object specifying the highest provider pricing you will accept. For example, the value `{"prompt": 1, "completion": 2}` will route to any provider with a price of `<= $1/m` prompt tokens, and `<= $2/m` completion tokens or less. Some providers support per request pricing, in which case you can use the "request" attribute of max\_price. Lastly, "image" is also available, which specifies the max price per image you will accept. Practically, this field is often combined with a provider "sort" to e.g. state "Use the provider with the highest throughput, as long as it doesn't cost more than `$x/m` tokens."
       3458	
       3459	
       3460	# Limits
       3461	
       3462	> Learn about OpenRouter's API rate limits, credit-based quotas, and DDoS protection. Configure and monitor your model usage limits effectively.
       3463	
       3464	<Tip>
       3465	  If you need a lot of inference, making additional accounts or API keys *makes
       3466	  no difference*. We manage the rate limit globally. We do however have
       3467	  different rate limits for different models, so you can share the load that way
       3468	  if you do run into issues. If you start getting rate limited -- [tell
       3469	  us](https://discord.gg/fVyRaUDgxW)! We are here to help. If you are able,
       3470	  don't specify providers; that will let us load balance it better.
       3471	</Tip>
       3472	
       3473	## Rate Limits and Credits Remaining
       3474	
       3475	To check the rate limit or credits left on an API key, make a GET request to `https://openrouter.ai/api/v1/auth/key`.
       3476	
       3477	<Template data={{ API_KEY_REF }}>
       3478	  <CodeGroup>
       3479	    ```typescript title="TypeScript"
       3480	    const response = await fetch('https://openrouter.ai/api/v1/auth/key', {
       3481	      method: 'GET',
       3482	      headers: {
       3483	        Authorization: 'Bearer {{API_KEY_REF}}',
       3484	      },
       3485	    });
       3486	    ```
       3487	
       3488	    ```python title="Python"
       3489	    import requests
       3490	    import json
       3491	
       3492	    response = requests.get(
       3493	      url="https://openrouter.ai/api/v1/auth/key",
       3494	      headers={
       3495	        "Authorization": f"Bearer {{API_KEY_REF}}"
       3496	      }
       3497	    )
       3498	
       3499	    print(json.dumps(response.json(), indent=2))
       3500	    ```
       3501	  </CodeGroup>
       3502	</Template>
       3503	
       3504	If you submit a valid API key, you should get a response of the form:
       3505	
       3506	```typescript title="TypeScript"
       3507	type Key = {
       3508	  data: {
       3509	    label: string;
       3510	    usage: number; // Number of credits used
       3511	    limit: number | null; // Credit limit for the key, or null if unlimited
       3512	    is_free_tier: boolean; // Whether the user has paid for credits before
       3513	    rate_limit: {
       3514	      requests: number; // Number of requests allowed...
       3515	      interval: string; // in this interval, e.g. "10s"
       3516	    };
       3517	  };
       3518	};
       3519	```
       3520	
       3521	There are a few rate limits that apply to certain types of requests, regardless of account status:
       3522	
       3523	1. Free usage limits: If you're using a free model variant (with an ID ending in <code>{sep}{Variant.Free}</code>), you can make up to {FREE_MODEL_RATE_LIMIT_RPM} requests per minute. The following per-day limits apply:
       3524	
       3525	* If you have purchased less than {FREE_MODEL_CREDITS_THRESHOLD} credits, you're limited to {FREE_MODEL_NO_CREDITS_RPD} <code>{sep}{Variant.Free}</code> model requests per day.
       3526	
       3527	* If you purchase at least {FREE_MODEL_CREDITS_THRESHOLD} credits, your daily limit is increased to {FREE_MODEL_HAS_CREDITS_RPD} <code>{sep}{Variant.Free}</code> model requests per day.
       3528	
       3529	2. **DDoS protection**: Cloudflare's DDoS protection will block requests that dramatically exceed reasonable usage.
       3530	
       3531	For all other requests, rate limits are a function of the number of credits remaining on the key or account. Partial credits round up in your favor. For the credits available on your API key, you can make **1 request per credit per second** up to the surge limit (typically 500 requests per second, but you can go higher).
       3532	
       3533	For example:
       3534	
       3535	* 0.5 credits → 1 req/s (minimum)
       3536	* 5 credits → 5 req/s
       3537	* 10 credits → 10 req/s
       3538	* 500 credits → 500 req/s
       3539	* 1000 credits → Contact us if you see ratelimiting from OpenRouter
       3540	
       3541	If your account has a negative credit balance, you may see <code>{HTTPStatus.S402_Payment_Required}</code> errors, including for free models. Adding credits to put your balance above zero allows you to use those models again.
       3542	
       3543	
       3544	# Errors
       3545	
       3546	> Learn how to handle errors in OpenRouter API interactions. Comprehensive guide to error codes, messages, and best practices for error handling.
       3547	
       3548	For errors, OpenRouter returns a JSON response with the following shape:
       3549	
       3550	```typescript
       3551	type ErrorResponse = {
       3552	  error: {
       3553	    code: number;
       3554	    message: string;
       3555	    metadata?: Record<string, unknown>;
       3556	  };
       3557	};
       3558	```
       3559	
       3560	The HTTP Response will have the same status code as `error.code`, forming a request error if:
       3561	
       3562	* Your original request is invalid
       3563	* Your API key/account is out of credits
       3564	
       3565	Otherwise, the returned HTTP response status will be <code>{HTTPStatus.S200_OK}</code> and any error occurred while the LLM is producing the output will be emitted in the response body or as an SSE data event.
       3566	
       3567	Example code for printing errors in JavaScript:
       3568	
       3569	```typescript
       3570	const request = await fetch('https://openrouter.ai/...');
       3571	console.log(request.status); // Will be an error code unless the model started processing your request
       3572	const response = await request.json();
       3573	console.error(response.error?.status); // Will be an error code
       3574	console.error(response.error?.message);
       3575	```
       3576	
       3577	## Error Codes
       3578	
       3579	* **{HTTPStatus.S400_Bad_Request}**: Bad Request (invalid or missing params, CORS)
       3580	* **{HTTPStatus.S401_Unauthorized}**: Invalid credentials (OAuth session expired, disabled/invalid API key)
       3581	* **{HTTPStatus.S402_Payment_Required}**: Your account or API key has insufficient credits. Add more credits and retry the request.
       3582	* **{HTTPStatus.S403_Forbidden}**: Your chosen model requires moderation and your input was flagged
       3583	* **{HTTPStatus.S408_Request_Timeout}**: Your request timed out
       3584	* **{HTTPStatus.S429_Too_Many_Requests}**: You are being rate limited
       3585	* **{HTTPStatus.S502_Bad_Gateway}**: Your chosen model is down or we received an invalid response from it
       3586	* **{HTTPStatus.S503_Service_Unavailable}**: There is no available model provider that meets your routing requirements
       3587	
       3588	## Moderation Errors
       3589	
       3590	If your input was flagged, the `error.metadata` will contain information about the issue. The shape of the metadata is as follows:
       3591	
       3592	```typescript
       3593	type ModerationErrorMetadata = {
       3594	  reasons: string[]; // Why your input was flagged
       3595	  flagged_input: string; // The text segment that was flagged, limited to 100 characters. If the flagged input is longer than 100 characters, it will be truncated in the middle and replaced with ...
       3596	  provider_name: string; // The name of the provider that requested moderation
       3597	  model_slug: string;
       3598	};
       3599	```
       3600	
       3601	## Provider Errors
       3602	
       3603	If the model provider encounters an error, the `error.metadata` will contain information about the issue. The shape of the metadata is as follows:
       3604	
       3605	```typescript
       3606	type ProviderErrorMetadata = {
       3607	  provider_name: string; // The name of the provider that encountered the error
       3608	  raw: unknown; // The raw error from the provider
       3609	};
       3610	```
       3611	
       3612	## When No Content is Generated
       3613	
       3614	Occasionally, the model may not generate any content. This typically occurs when:
       3615	
       3616	* The model is warming up from a cold start
       3617	* The system is scaling up to handle more requests
       3618	
       3619	Warm-up times usually range from a few seconds to a few minutes, depending on the model and provider.
       3620	
       3621	If you encounter persistent no-content issues, consider implementing a simple retry mechanism or trying again with a different provider or model that has more recent activity.
       3622	
       3623	Additionally, be aware that in some cases, you may still be charged for the prompt processing cost by the upstream provider, even if no content is generated.
       3624	
       3625	
       3626	# Completion
       3627	
       3628	```http
       3629	POST https://openrouter.ai/api/v1/completions
       3630	Content-Type: application/json
       3631	```
       3632	
       3633	Send a completion request to a selected model (text-only format)
       3634	
       3635	
       3636	
       3637	## Response Body
       3638	
       3639	- 200: Successful completion
       3640	
       3641	## Examples
       3642	
       3643	```shell
       3644	curl -X POST https://openrouter.ai/api/v1/completions \
       3645	     -H "Authorization: Bearer <token>" \
       3646	     -H "Content-Type: application/json" \
       3647	     -d '{
       3648	  "model": "model",
       3649	  "prompt": "prompt"
       3650	}'
       3651	```
       3652	
       3653	```python
       3654	import requests
       3655	
       3656	url = "https://openrouter.ai/api/v1/completions"
       3657	
       3658	payload = {
       3659	    "model": "model",
       3660	    "prompt": "prompt"
       3661	}
       3662	headers = {
       3663	    "Authorization": "Bearer <token>",
       3664	    "Content-Type": "application/json"
       3665	}
       3666	
       3667	response = requests.post(url, json=payload, headers=headers)
       3668	
       3669	print(response.json())
       3670	```
       3671	
       3672	```javascript
       3673	const url = 'https://openrouter.ai/api/v1/completions';
       3674	const options = {
       3675	  method: 'POST',
       3676	  headers: {Authorization: 'Bearer <token>', 'Content-Type': 'application/json'},
       3677	  body: '{"model":"model","prompt":"prompt"}'
       3678	};
       3679	
       3680	try {
       3681	  const response = await fetch(url, options);
       3682	  const data = await response.json();
       3683	  console.log(data);
       3684	} catch (error) {
       3685	  console.error(error);
       3686	}
       3687	```
       3688	
       3689	```go
       3690	package main
       3691	
       3692	import (
       3693		"fmt"
       3694		"strings"
       3695		"net/http"
       3696		"io"
       3697	)
       3698	
       3699	func main() {
       3700	
       3701		url := "https://openrouter.ai/api/v1/completions"
       3702	
       3703		payload := strings.NewReader("{\n  \"model\": \"model\",\n  \"prompt\": \"prompt\"\n}")
       3704	
       3705		req, _ := http.NewRequest("POST", url, payload)
       3706	
       3707		req.Header.Add("Authorization", "Bearer <token>")
       3708		req.Header.Add("Content-Type", "application/json")
       3709	
       3710		res, _ := http.DefaultClient.Do(req)
       3711	
       3712		defer res.Body.Close()
       3713		body, _ := io.ReadAll(res.Body)
       3714	
       3715		fmt.Println(res)
       3716		fmt.Println(string(body))
       3717	
       3718	}
       3719	```
       3720	
       3721	```ruby
       3722	require 'uri'
       3723	require 'net/http'
       3724	
       3725	url = URI("https://openrouter.ai/api/v1/completions")
       3726	
       3727	http = Net::HTTP.new(url.host, url.port)
       3728	http.use_ssl = true
       3729	
       3730	request = Net::HTTP::Post.new(url)
       3731	request["Authorization"] = 'Bearer <token>'
       3732	request["Content-Type"] = 'application/json'
       3733	request.body = "{\n  \"model\": \"model\",\n  \"prompt\": \"prompt\"\n}"
       3734	
       3735	response = http.request(request)
       3736	puts response.read_body
       3737	```
       3738	
       3739	```java
       3740	HttpResponse<String> response = Unirest.post("https://openrouter.ai/api/v1/completions")
       3741	  .header("Authorization", "Bearer <token>")
       3742	  .header("Content-Type", "application/json")
       3743	  .body("{\n  \"model\": \"model\",\n  \"prompt\": \"prompt\"\n}")
       3744	  .asString();
       3745	```
       3746	
       3747	```php
       3748	<?php
       3749	
       3750	$client = new \GuzzleHttp\Client();
       3751	
       3752	$response = $client->request('POST', 'https://openrouter.ai/api/v1/completions', [
       3753	  'body' => '{
       3754	  "model": "model",
       3755	  "prompt": "prompt"
       3756	}',
       3757	  'headers' => [
       3758	    'Authorization' => 'Bearer <token>',
       3759	    'Content-Type' => 'application/json',
       3760	  ],
       3761	]);
       3762	
       3763	echo $response->getBody();
       3764	```
       3765	
       3766	```csharp
       3767	var client = new RestClient("https://openrouter.ai/api/v1/completions");
       3768	var request = new RestRequest(Method.POST);
       3769	request.AddHeader("Authorization", "Bearer <token>");
       3770	request.AddHeader("Content-Type", "application/json");
       3771	request.AddParameter("application/json", "{\n  \"model\": \"model\",\n  \"prompt\": \"prompt\"\n}", ParameterType.RequestBody);
       3772	IRestResponse response = client.Execute(request);
       3773	```
       3774	
       3775	```swift
       3776	import Foundation
       3777	
       3778	let headers = [
       3779	  "Authorization": "Bearer <token>",
       3780	  "Content-Type": "application/json"
       3781	]
       3782	let parameters = [
       3783	  "model": "model",
       3784	  "prompt": "prompt"
       3785	] as [String : Any]
       3786	
       3787	let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
       3788	
       3789	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/completions")! as URL,
       3790	                                        cachePolicy: .useProtocolCachePolicy,
       3791	                                    timeoutInterval: 10.0)
       3792	request.httpMethod = "POST"
       3793	request.allHTTPHeaderFields = headers
       3794	request.httpBody = postData as Data
       3795	
       3796	let session = URLSession.shared
       3797	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       3798	  if (error != nil) {
       3799	    print(error as Any)
       3800	  } else {
       3801	    let httpResponse = response as? HTTPURLResponse
       3802	    print(httpResponse)
       3803	  }
       3804	})
       3805	
       3806	dataTask.resume()
       3807	```
       3808	
       3809	# Chat completion
       3810	
       3811	```http
       3812	POST https://openrouter.ai/api/v1/chat/completions
       3813	Content-Type: application/json
       3814	```
       3815	
       3816	Send a chat completion request to a selected model. The request must contain a "messages" array. All advanced options from the base request are also supported.
       3817	
       3818	
       3819	
       3820	## Response Body
       3821	
       3822	- 200: Successful completion
       3823	
       3824	## Examples
       3825	
       3826	```shell
       3827	curl -X POST https://openrouter.ai/api/v1/chat/completions \
       3828	     -H "Authorization: Bearer <token>" \
       3829	     -H "Content-Type: application/json" \
       3830	     -d '{
       3831	  "model": "openai/gpt-3.5-turbo",
       3832	  "messages": [
       3833	    {
       3834	      "role": "user",
       3835	      "content": "What is the meaning of life?"
       3836	    }
       3837	  ]
       3838	}'
       3839	```
       3840	
       3841	```python
       3842	import requests
       3843	
       3844	url = "https://openrouter.ai/api/v1/chat/completions"
       3845	
       3846	payload = { "model": "openai/gpt-3.5-turbo" }
       3847	headers = {
       3848	    "Authorization": "Bearer <token>",
       3849	    "Content-Type": "application/json"
       3850	}
       3851	
       3852	response = requests.post(url, json=payload, headers=headers)
       3853	
       3854	print(response.json())
       3855	```
       3856	
       3857	```javascript
       3858	const url = 'https://openrouter.ai/api/v1/chat/completions';
       3859	const options = {
       3860	  method: 'POST',
       3861	  headers: {Authorization: 'Bearer <token>', 'Content-Type': 'application/json'},
       3862	  body: '{"model":"openai/gpt-3.5-turbo"}'
       3863	};
       3864	
       3865	try {
       3866	  const response = await fetch(url, options);
       3867	  const data = await response.json();
       3868	  console.log(data);
       3869	} catch (error) {
       3870	  console.error(error);
       3871	}
       3872	```
       3873	
       3874	```go
       3875	package main
       3876	
       3877	import (
       3878		"fmt"
       3879		"strings"
       3880		"net/http"
       3881		"io"
       3882	)
       3883	
       3884	func main() {
       3885	
       3886		url := "https://openrouter.ai/api/v1/chat/completions"
       3887	
       3888		payload := strings.NewReader("{\n  \"model\": \"openai/gpt-3.5-turbo\"\n}")
       3889	
       3890		req, _ := http.NewRequest("POST", url, payload)
       3891	
       3892		req.Header.Add("Authorization", "Bearer <token>")
       3893		req.Header.Add("Content-Type", "application/json")
       3894	
       3895		res, _ := http.DefaultClient.Do(req)
       3896	
       3897		defer res.Body.Close()
       3898		body, _ := io.ReadAll(res.Body)
       3899	
       3900		fmt.Println(res)
       3901		fmt.Println(string(body))
       3902	
       3903	}
       3904	```
       3905	
       3906	```ruby
       3907	require 'uri'
       3908	require 'net/http'
       3909	
       3910	url = URI("https://openrouter.ai/api/v1/chat/completions")
       3911	
       3912	http = Net::HTTP.new(url.host, url.port)
       3913	http.use_ssl = true
       3914	
       3915	request = Net::HTTP::Post.new(url)
       3916	request["Authorization"] = 'Bearer <token>'
       3917	request["Content-Type"] = 'application/json'
       3918	request.body = "{\n  \"model\": \"openai/gpt-3.5-turbo\"\n}"
       3919	
       3920	response = http.request(request)
       3921	puts response.read_body
       3922	```
       3923	
       3924	```java
       3925	HttpResponse<String> response = Unirest.post("https://openrouter.ai/api/v1/chat/completions")
       3926	  .header("Authorization", "Bearer <token>")
       3927	  .header("Content-Type", "application/json")
       3928	  .body("{\n  \"model\": \"openai/gpt-3.5-turbo\"\n}")
       3929	  .asString();
       3930	```
       3931	
       3932	```php
       3933	<?php
       3934	
       3935	$client = new \GuzzleHttp\Client();
       3936	
       3937	$response = $client->request('POST', 'https://openrouter.ai/api/v1/chat/completions', [
       3938	  'body' => '{
       3939	  "model": "openai/gpt-3.5-turbo"
       3940	}',
       3941	  'headers' => [
       3942	    'Authorization' => 'Bearer <token>',
       3943	    'Content-Type' => 'application/json',
       3944	  ],
       3945	]);
       3946	
       3947	echo $response->getBody();
       3948	```
       3949	
       3950	```csharp
       3951	var client = new RestClient("https://openrouter.ai/api/v1/chat/completions");
       3952	var request = new RestRequest(Method.POST);
       3953	request.AddHeader("Authorization", "Bearer <token>");
       3954	request.AddHeader("Content-Type", "application/json");
       3955	request.AddParameter("application/json", "{\n  \"model\": \"openai/gpt-3.5-turbo\"\n}", ParameterType.RequestBody);
       3956	IRestResponse response = client.Execute(request);
       3957	```
       3958	
       3959	```swift
       3960	import Foundation
       3961	
       3962	let headers = [
       3963	  "Authorization": "Bearer <token>",
       3964	  "Content-Type": "application/json"
       3965	]
       3966	let parameters = ["model": "openai/gpt-3.5-turbo"] as [String : Any]
       3967	
       3968	let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
       3969	
       3970	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/chat/completions")! as URL,
       3971	                                        cachePolicy: .useProtocolCachePolicy,
       3972	                                    timeoutInterval: 10.0)
       3973	request.httpMethod = "POST"
       3974	request.allHTTPHeaderFields = headers
       3975	request.httpBody = postData as Data
       3976	
       3977	let session = URLSession.shared
       3978	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       3979	  if (error != nil) {
       3980	    print(error as Any)
       3981	  } else {
       3982	    let httpResponse = response as? HTTPURLResponse
       3983	    print(httpResponse)
       3984	  }
       3985	})
       3986	
       3987	dataTask.resume()
       3988	```
       3989	
       3990	# Get a generation
       3991	
       3992	```http
       3993	GET https://openrouter.ai/api/v1/generation
       3994	```
       3995	
       3996	Returns metadata about a specific generation request
       3997	
       3998	
       3999	
       4000	## Query Parameters
       4001	
       4002	- Id (required)
       4003	
       4004	## Response Body
       4005	
       4006	- 200: Returns the request metadata for this generation
       4007	
       4008	## Examples
       4009	
       4010	```shell
       4011	curl -G https://openrouter.ai/api/v1/generation \
       4012	     -H "Authorization: Bearer <token>" \
       4013	     -d id=id
       4014	```
       4015	
       4016	```python
       4017	import requests
       4018	
       4019	url = "https://openrouter.ai/api/v1/generation"
       4020	
       4021	querystring = {"id":"id"}
       4022	
       4023	headers = {"Authorization": "Bearer <token>"}
       4024	
       4025	response = requests.get(url, headers=headers, params=querystring)
       4026	
       4027	print(response.json())
       4028	```
       4029	
       4030	```javascript
       4031	const url = 'https://openrouter.ai/api/v1/generation?id=id';
       4032	const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};
       4033	
       4034	try {
       4035	  const response = await fetch(url, options);
       4036	  const data = await response.json();
       4037	  console.log(data);
       4038	} catch (error) {
       4039	  console.error(error);
       4040	}
       4041	```
       4042	
       4043	```go
       4044	package main
       4045	
       4046	import (
       4047		"fmt"
       4048		"net/http"
       4049		"io"
       4050	)
       4051	
       4052	func main() {
       4053	
       4054		url := "https://openrouter.ai/api/v1/generation?id=id"
       4055	
       4056		req, _ := http.NewRequest("GET", url, nil)
       4057	
       4058		req.Header.Add("Authorization", "Bearer <token>")
       4059	
       4060		res, _ := http.DefaultClient.Do(req)
       4061	
       4062		defer res.Body.Close()
       4063		body, _ := io.ReadAll(res.Body)
       4064	
       4065		fmt.Println(res)
       4066		fmt.Println(string(body))
       4067	
       4068	}
       4069	```
       4070	
       4071	```ruby
       4072	require 'uri'
       4073	require 'net/http'
       4074	
       4075	url = URI("https://openrouter.ai/api/v1/generation?id=id")
       4076	
       4077	http = Net::HTTP.new(url.host, url.port)
       4078	http.use_ssl = true
       4079	
       4080	request = Net::HTTP::Get.new(url)
       4081	request["Authorization"] = 'Bearer <token>'
       4082	
       4083	response = http.request(request)
       4084	puts response.read_body
       4085	```
       4086	
       4087	```java
       4088	HttpResponse<String> response = Unirest.get("https://openrouter.ai/api/v1/generation?id=id")
       4089	  .header("Authorization", "Bearer <token>")
       4090	  .asString();
       4091	```
       4092	
       4093	```php
       4094	<?php
       4095	
       4096	$client = new \GuzzleHttp\Client();
       4097	
       4098	$response = $client->request('GET', 'https://openrouter.ai/api/v1/generation?id=id', [
       4099	  'headers' => [
       4100	    'Authorization' => 'Bearer <token>',
       4101	  ],
       4102	]);
       4103	
       4104	echo $response->getBody();
       4105	```
       4106	
       4107	```csharp
       4108	var client = new RestClient("https://openrouter.ai/api/v1/generation?id=id");
       4109	var request = new RestRequest(Method.GET);
       4110	request.AddHeader("Authorization", "Bearer <token>");
       4111	IRestResponse response = client.Execute(request);
       4112	```
       4113	
       4114	```swift
       4115	import Foundation
       4116	
       4117	let headers = ["Authorization": "Bearer <token>"]
       4118	
       4119	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/generation?id=id")! as URL,
       4120	                                        cachePolicy: .useProtocolCachePolicy,
       4121	                                    timeoutInterval: 10.0)
       4122	request.httpMethod = "GET"
       4123	request.allHTTPHeaderFields = headers
       4124	
       4125	let session = URLSession.shared
       4126	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       4127	  if (error != nil) {
       4128	    print(error as Any)
       4129	  } else {
       4130	    let httpResponse = response as? HTTPURLResponse
       4131	    print(httpResponse)
       4132	  }
       4133	})
       4134	
       4135	dataTask.resume()
       4136	```
       4137	
       4138	# List available models
       4139	
       4140	```http
       4141	GET https://openrouter.ai/api/v1/models
       4142	```
       4143	
       4144	Returns a list of models available through the API
       4145	
       4146	
       4147	
       4148	## Response Body
       4149	
       4150	- 200: List of available models
       4151	
       4152	## Examples
       4153	
       4154	```shell
       4155	curl https://openrouter.ai/api/v1/models
       4156	```
       4157	
       4158	```python
       4159	import requests
       4160	
       4161	url = "https://openrouter.ai/api/v1/models"
       4162	
       4163	response = requests.get(url)
       4164	
       4165	print(response.json())
       4166	```
       4167	
       4168	```javascript
       4169	const url = 'https://openrouter.ai/api/v1/models';
       4170	const options = {method: 'GET'};
       4171	
       4172	try {
       4173	  const response = await fetch(url, options);
       4174	  const data = await response.json();
       4175	  console.log(data);
       4176	} catch (error) {
       4177	  console.error(error);
       4178	}
       4179	```
       4180	
       4181	```go
       4182	package main
       4183	
       4184	import (
       4185		"fmt"
       4186		"net/http"
       4187		"io"
       4188	)
       4189	
       4190	func main() {
       4191	
       4192		url := "https://openrouter.ai/api/v1/models"
       4193	
       4194		req, _ := http.NewRequest("GET", url, nil)
       4195	
       4196		res, _ := http.DefaultClient.Do(req)
       4197	
       4198		defer res.Body.Close()
       4199		body, _ := io.ReadAll(res.Body)
       4200	
       4201		fmt.Println(res)
       4202		fmt.Println(string(body))
       4203	
       4204	}
       4205	```
       4206	
       4207	```ruby
       4208	require 'uri'
       4209	require 'net/http'
       4210	
       4211	url = URI("https://openrouter.ai/api/v1/models")
       4212	
       4213	http = Net::HTTP.new(url.host, url.port)
       4214	http.use_ssl = true
       4215	
       4216	request = Net::HTTP::Get.new(url)
       4217	
       4218	response = http.request(request)
       4219	puts response.read_body
       4220	```
       4221	
       4222	```java
       4223	HttpResponse<String> response = Unirest.get("https://openrouter.ai/api/v1/models")
       4224	  .asString();
       4225	```
       4226	
       4227	```php
       4228	<?php
       4229	
       4230	$client = new \GuzzleHttp\Client();
       4231	
       4232	$response = $client->request('GET', 'https://openrouter.ai/api/v1/models');
       4233	
       4234	echo $response->getBody();
       4235	```
       4236	
       4237	```csharp
       4238	var client = new RestClient("https://openrouter.ai/api/v1/models");
       4239	var request = new RestRequest(Method.GET);
       4240	IRestResponse response = client.Execute(request);
       4241	```
       4242	
       4243	```swift
       4244	import Foundation
       4245	
       4246	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/models")! as URL,
       4247	                                        cachePolicy: .useProtocolCachePolicy,
       4248	                                    timeoutInterval: 10.0)
       4249	request.httpMethod = "GET"
       4250	
       4251	let session = URLSession.shared
       4252	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       4253	  if (error != nil) {
       4254	    print(error as Any)
       4255	  } else {
       4256	    let httpResponse = response as? HTTPURLResponse
       4257	    print(httpResponse)
       4258	  }
       4259	})
       4260	
       4261	dataTask.resume()
       4262	```
       4263	
       4264	# List endpoints for a model
       4265	
       4266	```http
       4267	GET https://openrouter.ai/api/v1/models/{author}/{slug}/endpoints
       4268	```
       4269	
       4270	
       4271	
       4272	## Path Parameters
       4273	
       4274	- Author (required)
       4275	- Slug (required)
       4276	
       4277	## Response Body
       4278	
       4279	- 200: List of endpoints for the model
       4280	
       4281	## Examples
       4282	
       4283	```shell
       4284	curl https://openrouter.ai/api/v1/models/author/slug/endpoints
       4285	```
       4286	
       4287	```python
       4288	import requests
       4289	
       4290	url = "https://openrouter.ai/api/v1/models/author/slug/endpoints"
       4291	
       4292	response = requests.get(url)
       4293	
       4294	print(response.json())
       4295	```
       4296	
       4297	```javascript
       4298	const url = 'https://openrouter.ai/api/v1/models/author/slug/endpoints';
       4299	const options = {method: 'GET'};
       4300	
       4301	try {
       4302	  const response = await fetch(url, options);
       4303	  const data = await response.json();
       4304	  console.log(data);
       4305	} catch (error) {
       4306	  console.error(error);
       4307	}
       4308	```
       4309	
       4310	```go
       4311	package main
       4312	
       4313	import (
       4314		"fmt"
       4315		"net/http"
       4316		"io"
       4317	)
       4318	
       4319	func main() {
       4320	
       4321		url := "https://openrouter.ai/api/v1/models/author/slug/endpoints"
       4322	
       4323		req, _ := http.NewRequest("GET", url, nil)
       4324	
       4325		res, _ := http.DefaultClient.Do(req)
       4326	
       4327		defer res.Body.Close()
       4328		body, _ := io.ReadAll(res.Body)
       4329	
       4330		fmt.Println(res)
       4331		fmt.Println(string(body))
       4332	
       4333	}
       4334	```
       4335	
       4336	```ruby
       4337	require 'uri'
       4338	require 'net/http'
       4339	
       4340	url = URI("https://openrouter.ai/api/v1/models/author/slug/endpoints")
       4341	
       4342	http = Net::HTTP.new(url.host, url.port)
       4343	http.use_ssl = true
       4344	
       4345	request = Net::HTTP::Get.new(url)
       4346	
       4347	response = http.request(request)
       4348	puts response.read_body
       4349	```
       4350	
       4351	```java
       4352	HttpResponse<String> response = Unirest.get("https://openrouter.ai/api/v1/models/author/slug/endpoints")
       4353	  .asString();
       4354	```
       4355	
       4356	```php
       4357	<?php
       4358	
       4359	$client = new \GuzzleHttp\Client();
       4360	
       4361	$response = $client->request('GET', 'https://openrouter.ai/api/v1/models/author/slug/endpoints');
       4362	
       4363	echo $response->getBody();
       4364	```
       4365	
       4366	```csharp
       4367	var client = new RestClient("https://openrouter.ai/api/v1/models/author/slug/endpoints");
       4368	var request = new RestRequest(Method.GET);
       4369	IRestResponse response = client.Execute(request);
       4370	```
       4371	
       4372	```swift
       4373	import Foundation
       4374	
       4375	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/models/author/slug/endpoints")! as URL,
       4376	                                        cachePolicy: .useProtocolCachePolicy,
       4377	                                    timeoutInterval: 10.0)
       4378	request.httpMethod = "GET"
       4379	
       4380	let session = URLSession.shared
       4381	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       4382	  if (error != nil) {
       4383	    print(error as Any)
       4384	  } else {
       4385	    let httpResponse = response as? HTTPURLResponse
       4386	    print(httpResponse)
       4387	  }
       4388	})
       4389	
       4390	dataTask.resume()
       4391	```
       4392	
       4393	# Get credits
       4394	
       4395	```http
       4396	GET https://openrouter.ai/api/v1/credits
       4397	```
       4398	
       4399	Returns the total credits purchased and used for the authenticated user
       4400	
       4401	
       4402	
       4403	## Response Body
       4404	
       4405	- 200: Returns the total credits purchased and used
       4406	
       4407	## Examples
       4408	
       4409	```shell
       4410	curl https://openrouter.ai/api/v1/credits \
       4411	     -H "Authorization: Bearer <token>"
       4412	```
       4413	
       4414	```python
       4415	import requests
       4416	
       4417	url = "https://openrouter.ai/api/v1/credits"
       4418	
       4419	headers = {"Authorization": "Bearer <token>"}
       4420	
       4421	response = requests.get(url, headers=headers)
       4422	
       4423	print(response.json())
       4424	```
       4425	
       4426	```javascript
       4427	const url = 'https://openrouter.ai/api/v1/credits';
       4428	const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};
       4429	
       4430	try {
       4431	  const response = await fetch(url, options);
       4432	  const data = await response.json();
       4433	  console.log(data);
       4434	} catch (error) {
       4435	  console.error(error);
       4436	}
       4437	```
       4438	
       4439	```go
       4440	package main
       4441	
       4442	import (
       4443		"fmt"
       4444		"net/http"
       4445		"io"
       4446	)
       4447	
       4448	func main() {
       4449	
       4450		url := "https://openrouter.ai/api/v1/credits"
       4451	
       4452		req, _ := http.NewRequest("GET", url, nil)
       4453	
       4454		req.Header.Add("Authorization", "Bearer <token>")
       4455	
       4456		res, _ := http.DefaultClient.Do(req)
       4457	
       4458		defer res.Body.Close()
       4459		body, _ := io.ReadAll(res.Body)
       4460	
       4461		fmt.Println(res)
       4462		fmt.Println(string(body))
       4463	
       4464	}
       4465	```
       4466	
       4467	```ruby
       4468	require 'uri'
       4469	require 'net/http'
       4470	
       4471	url = URI("https://openrouter.ai/api/v1/credits")
       4472	
       4473	http = Net::HTTP.new(url.host, url.port)
       4474	http.use_ssl = true
       4475	
       4476	request = Net::HTTP::Get.new(url)
       4477	request["Authorization"] = 'Bearer <token>'
       4478	
       4479	response = http.request(request)
       4480	puts response.read_body
       4481	```
       4482	
       4483	```java
       4484	HttpResponse<String> response = Unirest.get("https://openrouter.ai/api/v1/credits")
       4485	  .header("Authorization", "Bearer <token>")
       4486	  .asString();
       4487	```
       4488	
       4489	```php
       4490	<?php
       4491	
       4492	$client = new \GuzzleHttp\Client();
       4493	
       4494	$response = $client->request('GET', 'https://openrouter.ai/api/v1/credits', [
       4495	  'headers' => [
       4496	    'Authorization' => 'Bearer <token>',
       4497	  ],
       4498	]);
       4499	
       4500	echo $response->getBody();
       4501	```
       4502	
       4503	```csharp
       4504	var client = new RestClient("https://openrouter.ai/api/v1/credits");
       4505	var request = new RestRequest(Method.GET);
       4506	request.AddHeader("Authorization", "Bearer <token>");
       4507	IRestResponse response = client.Execute(request);
       4508	```
       4509	
       4510	```swift
       4511	import Foundation
       4512	
       4513	let headers = ["Authorization": "Bearer <token>"]
       4514	
       4515	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/credits")! as URL,
       4516	                                        cachePolicy: .useProtocolCachePolicy,
       4517	                                    timeoutInterval: 10.0)
       4518	request.httpMethod = "GET"
       4519	request.allHTTPHeaderFields = headers
       4520	
       4521	let session = URLSession.shared
       4522	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       4523	  if (error != nil) {
       4524	    print(error as Any)
       4525	  } else {
       4526	    let httpResponse = response as? HTTPURLResponse
       4527	    print(httpResponse)
       4528	  }
       4529	})
       4530	
       4531	dataTask.resume()
       4532	```
       4533	
       4534	# Create a Coinbase charge
       4535	
       4536	```http
       4537	POST https://openrouter.ai/api/v1/credits/coinbase
       4538	Content-Type: application/json
       4539	```
       4540	
       4541	Creates and hydrates a Coinbase Commerce charge for cryptocurrency payments
       4542	
       4543	
       4544	
       4545	## Response Body
       4546	
       4547	- 200: Returns the calldata to fulfill the transaction
       4548	
       4549	## Examples
       4550	
       4551	```shell
       4552	curl -X POST https://openrouter.ai/api/v1/credits/coinbase \
       4553	     -H "Authorization: Bearer <token>" \
       4554	     -H "Content-Type: application/json" \
       4555	     -d '{
       4556	  "amount": 1.1,
       4557	  "sender": "sender",
       4558	  "chain_id": 1
       4559	}'
       4560	```
       4561	
       4562	```python
       4563	import requests
       4564	
       4565	url = "https://openrouter.ai/api/v1/credits/coinbase"
       4566	
       4567	payload = {
       4568	    "amount": 1.1,
       4569	    "sender": "sender",
       4570	    "chain_id": 1
       4571	}
       4572	headers = {
       4573	    "Authorization": "Bearer <token>",
       4574	    "Content-Type": "application/json"
       4575	}
       4576	
       4577	response = requests.post(url, json=payload, headers=headers)
       4578	
       4579	print(response.json())
       4580	```
       4581	
       4582	```javascript
       4583	const url = 'https://openrouter.ai/api/v1/credits/coinbase';
       4584	const options = {
       4585	  method: 'POST',
       4586	  headers: {Authorization: 'Bearer <token>', 'Content-Type': 'application/json'},
       4587	  body: '{"amount":1.1,"sender":"sender","chain_id":1}'
       4588	};
       4589	
       4590	try {
       4591	  const response = await fetch(url, options);
       4592	  const data = await response.json();
       4593	  console.log(data);
       4594	} catch (error) {
       4595	  console.error(error);
       4596	}
       4597	```
       4598	
       4599	```go
       4600	package main
       4601	
       4602	import (
       4603		"fmt"
       4604		"strings"
       4605		"net/http"
       4606		"io"
       4607	)
       4608	
       4609	func main() {
       4610	
       4611		url := "https://openrouter.ai/api/v1/credits/coinbase"
       4612	
       4613		payload := strings.NewReader("{\n  \"amount\": 1.1,\n  \"sender\": \"sender\",\n  \"chain_id\": 1\n}")
       4614	
       4615		req, _ := http.NewRequest("POST", url, payload)
       4616	
       4617		req.Header.Add("Authorization", "Bearer <token>")
       4618		req.Header.Add("Content-Type", "application/json")
       4619	
       4620		res, _ := http.DefaultClient.Do(req)
       4621	
       4622		defer res.Body.Close()
       4623		body, _ := io.ReadAll(res.Body)
       4624	
       4625		fmt.Println(res)
       4626		fmt.Println(string(body))
       4627	
       4628	}
       4629	```
       4630	
       4631	```ruby
       4632	require 'uri'
       4633	require 'net/http'
       4634	
       4635	url = URI("https://openrouter.ai/api/v1/credits/coinbase")
       4636	
       4637	http = Net::HTTP.new(url.host, url.port)
       4638	http.use_ssl = true
       4639	
       4640	request = Net::HTTP::Post.new(url)
       4641	request["Authorization"] = 'Bearer <token>'
       4642	request["Content-Type"] = 'application/json'
       4643	request.body = "{\n  \"amount\": 1.1,\n  \"sender\": \"sender\",\n  \"chain_id\": 1\n}"
       4644	
       4645	response = http.request(request)
       4646	puts response.read_body
       4647	```
       4648	
       4649	```java
       4650	HttpResponse<String> response = Unirest.post("https://openrouter.ai/api/v1/credits/coinbase")
       4651	  .header("Authorization", "Bearer <token>")
       4652	  .header("Content-Type", "application/json")
       4653	  .body("{\n  \"amount\": 1.1,\n  \"sender\": \"sender\",\n  \"chain_id\": 1\n}")
       4654	  .asString();
       4655	```
       4656	
       4657	```php
       4658	<?php
       4659	
       4660	$client = new \GuzzleHttp\Client();
       4661	
       4662	$response = $client->request('POST', 'https://openrouter.ai/api/v1/credits/coinbase', [
       4663	  'body' => '{
       4664	  "amount": 1.1,
       4665	  "sender": "sender",
       4666	  "chain_id": 1
       4667	}',
       4668	  'headers' => [
       4669	    'Authorization' => 'Bearer <token>',
       4670	    'Content-Type' => 'application/json',
       4671	  ],
       4672	]);
       4673	
       4674	echo $response->getBody();
       4675	```
       4676	
       4677	```csharp
       4678	var client = new RestClient("https://openrouter.ai/api/v1/credits/coinbase");
       4679	var request = new RestRequest(Method.POST);
       4680	request.AddHeader("Authorization", "Bearer <token>");
       4681	request.AddHeader("Content-Type", "application/json");
       4682	request.AddParameter("application/json", "{\n  \"amount\": 1.1,\n  \"sender\": \"sender\",\n  \"chain_id\": 1\n}", ParameterType.RequestBody);
       4683	IRestResponse response = client.Execute(request);
       4684	```
       4685	
       4686	```swift
       4687	import Foundation
       4688	
       4689	let headers = [
       4690	  "Authorization": "Bearer <token>",
       4691	  "Content-Type": "application/json"
       4692	]
       4693	let parameters = [
       4694	  "amount": 1.1,
       4695	  "sender": "sender",
       4696	  "chain_id": 1
       4697	] as [String : Any]
       4698	
       4699	let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
       4700	
       4701	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/credits/coinbase")! as URL,
       4702	                                        cachePolicy: .useProtocolCachePolicy,
       4703	                                    timeoutInterval: 10.0)
       4704	request.httpMethod = "POST"
       4705	request.allHTTPHeaderFields = headers
       4706	request.httpBody = postData as Data
       4707	
       4708	let session = URLSession.shared
       4709	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       4710	  if (error != nil) {
       4711	    print(error as Any)
       4712	  } else {
       4713	    let httpResponse = response as? HTTPURLResponse
       4714	    print(httpResponse)
       4715	  }
       4716	})
       4717	
       4718	dataTask.resume()
       4719	```
       4720	
       4721	# Exchange authorization code for API key
       4722	
       4723	```http
       4724	POST https://openrouter.ai/api/v1/auth/keys
       4725	Content-Type: application/json
       4726	```
       4727	
       4728	Exchange an authorization code from the PKCE flow for a user-controlled API key
       4729	
       4730	
       4731	
       4732	## Response Body
       4733	
       4734	- 200: Successfully exchanged code for an API key
       4735	- 400: Invalid code parameter or invalid code_challenge_method
       4736	- 403: Invalid code or code_verifier or already used code
       4737	- 405: Method Not Allowed - Make sure you're using POST and HTTPS
       4738	
       4739	## Examples
       4740	
       4741	```shell
       4742	curl -X POST https://openrouter.ai/api/v1/auth/keys \
       4743	     -H "Content-Type: application/json" \
       4744	     -d '{
       4745	  "code": "code"
       4746	}'
       4747	```
       4748	
       4749	```python
       4750	import requests
       4751	
       4752	url = "https://openrouter.ai/api/v1/auth/keys"
       4753	
       4754	payload = { "code": "code" }
       4755	headers = {"Content-Type": "application/json"}
       4756	
       4757	response = requests.post(url, json=payload, headers=headers)
       4758	
       4759	print(response.json())
       4760	```
       4761	
       4762	```javascript
       4763	const url = 'https://openrouter.ai/api/v1/auth/keys';
       4764	const options = {
       4765	  method: 'POST',
       4766	  headers: {'Content-Type': 'application/json'},
       4767	  body: '{"code":"code"}'
       4768	};
       4769	
       4770	try {
       4771	  const response = await fetch(url, options);
       4772	  const data = await response.json();
       4773	  console.log(data);
       4774	} catch (error) {
       4775	  console.error(error);
       4776	}
       4777	```
       4778	
       4779	```go
       4780	package main
       4781	
       4782	import (
       4783		"fmt"
       4784		"strings"
       4785		"net/http"
       4786		"io"
       4787	)
       4788	
       4789	func main() {
       4790	
       4791		url := "https://openrouter.ai/api/v1/auth/keys"
       4792	
       4793		payload := strings.NewReader("{\n  \"code\": \"code\"\n}")
       4794	
       4795		req, _ := http.NewRequest("POST", url, payload)
       4796	
       4797		req.Header.Add("Content-Type", "application/json")
       4798	
       4799		res, _ := http.DefaultClient.Do(req)
       4800	
       4801		defer res.Body.Close()
       4802		body, _ := io.ReadAll(res.Body)
       4803	
       4804		fmt.Println(res)
       4805		fmt.Println(string(body))
       4806	
       4807	}
       4808	```
       4809	
       4810	```ruby
       4811	require 'uri'
       4812	require 'net/http'
       4813	
       4814	url = URI("https://openrouter.ai/api/v1/auth/keys")
       4815	
       4816	http = Net::HTTP.new(url.host, url.port)
       4817	http.use_ssl = true
       4818	
       4819	request = Net::HTTP::Post.new(url)
       4820	request["Content-Type"] = 'application/json'
       4821	request.body = "{\n  \"code\": \"code\"\n}"
       4822	
       4823	response = http.request(request)
       4824	puts response.read_body
       4825	```
       4826	
       4827	```java
       4828	HttpResponse<String> response = Unirest.post("https://openrouter.ai/api/v1/auth/keys")
       4829	  .header("Content-Type", "application/json")
       4830	  .body("{\n  \"code\": \"code\"\n}")
       4831	  .asString();
       4832	```
       4833	
       4834	```php
       4835	<?php
       4836	
       4837	$client = new \GuzzleHttp\Client();
       4838	
       4839	$response = $client->request('POST', 'https://openrouter.ai/api/v1/auth/keys', [
       4840	  'body' => '{
       4841	  "code": "code"
       4842	}',
       4843	  'headers' => [
       4844	    'Content-Type' => 'application/json',
       4845	  ],
       4846	]);
       4847	
       4848	echo $response->getBody();
       4849	```
       4850	
       4851	```csharp
       4852	var client = new RestClient("https://openrouter.ai/api/v1/auth/keys");
       4853	var request = new RestRequest(Method.POST);
       4854	request.AddHeader("Content-Type", "application/json");
       4855	request.AddParameter("application/json", "{\n  \"code\": \"code\"\n}", ParameterType.RequestBody);
       4856	IRestResponse response = client.Execute(request);
       4857	```
       4858	
       4859	```swift
       4860	import Foundation
       4861	
       4862	let headers = ["Content-Type": "application/json"]
       4863	let parameters = ["code": "code"] as [String : Any]
       4864	
       4865	let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
       4866	
       4867	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/auth/keys")! as URL,
       4868	                                        cachePolicy: .useProtocolCachePolicy,
       4869	                                    timeoutInterval: 10.0)
       4870	request.httpMethod = "POST"
       4871	request.allHTTPHeaderFields = headers
       4872	request.httpBody = postData as Data
       4873	
       4874	let session = URLSession.shared
       4875	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       4876	  if (error != nil) {
       4877	    print(error as Any)
       4878	  } else {
       4879	    let httpResponse = response as? HTTPURLResponse
       4880	    print(httpResponse)
       4881	  }
       4882	})
       4883	
       4884	dataTask.resume()
       4885	```
       4886	
       4887	```shell
       4888	curl -X POST https://openrouter.ai/api/v1/auth/keys \
       4889	     -H "Content-Type: application/json" \
       4890	     -d '{
       4891	  "code": "string"
       4892	}'
       4893	```
       4894	
       4895	```python
       4896	import requests
       4897	
       4898	url = "https://openrouter.ai/api/v1/auth/keys"
       4899	
       4900	payload = { "code": "string" }
       4901	headers = {"Content-Type": "application/json"}
       4902	
       4903	response = requests.post(url, json=payload, headers=headers)
       4904	
       4905	print(response.json())
       4906	```
       4907	
       4908	```javascript
       4909	const url = 'https://openrouter.ai/api/v1/auth/keys';
       4910	const options = {
       4911	  method: 'POST',
       4912	  headers: {'Content-Type': 'application/json'},
       4913	  body: '{"code":"string"}'
       4914	};
       4915	
       4916	try {
       4917	  const response = await fetch(url, options);
       4918	  const data = await response.json();
       4919	  console.log(data);
       4920	} catch (error) {
       4921	  console.error(error);
       4922	}
       4923	```
       4924	
       4925	```go
       4926	package main
       4927	
       4928	import (
       4929		"fmt"
       4930		"strings"
       4931		"net/http"
       4932		"io"
       4933	)
       4934	
       4935	func main() {
       4936	
       4937		url := "https://openrouter.ai/api/v1/auth/keys"
       4938	
       4939		payload := strings.NewReader("{\n  \"code\": \"string\"\n}")
       4940	
       4941		req, _ := http.NewRequest("POST", url, payload)
       4942	
       4943		req.Header.Add("Content-Type", "application/json")
       4944	
       4945		res, _ := http.DefaultClient.Do(req)
       4946	
       4947		defer res.Body.Close()
       4948		body, _ := io.ReadAll(res.Body)
       4949	
       4950		fmt.Println(res)
       4951		fmt.Println(string(body))
       4952	
       4953	}
       4954	```
       4955	
       4956	```ruby
       4957	require 'uri'
       4958	require 'net/http'
       4959	
       4960	url = URI("https://openrouter.ai/api/v1/auth/keys")
       4961	
       4962	http = Net::HTTP.new(url.host, url.port)
       4963	http.use_ssl = true
       4964	
       4965	request = Net::HTTP::Post.new(url)
       4966	request["Content-Type"] = 'application/json'
       4967	request.body = "{\n  \"code\": \"string\"\n}"
       4968	
       4969	response = http.request(request)
       4970	puts response.read_body
       4971	```
       4972	
       4973	```java
       4974	HttpResponse<String> response = Unirest.post("https://openrouter.ai/api/v1/auth/keys")
       4975	  .header("Content-Type", "application/json")
       4976	  .body("{\n  \"code\": \"string\"\n}")
       4977	  .asString();
       4978	```
       4979	
       4980	```php
       4981	<?php
       4982	
       4983	$client = new \GuzzleHttp\Client();
       4984	
       4985	$response = $client->request('POST', 'https://openrouter.ai/api/v1/auth/keys', [
       4986	  'body' => '{
       4987	  "code": "string"
       4988	}',
       4989	  'headers' => [
       4990	    'Content-Type' => 'application/json',
       4991	  ],
       4992	]);
       4993	
       4994	echo $response->getBody();
       4995	```
       4996	
       4997	```csharp
       4998	var client = new RestClient("https://openrouter.ai/api/v1/auth/keys");
       4999	var request = new RestRequest(Method.POST);
       5000	request.AddHeader("Content-Type", "application/json");
       5001	request.AddParameter("application/json", "{\n  \"code\": \"string\"\n}", ParameterType.RequestBody);
       5002	IRestResponse response = client.Execute(request);
       5003	```
       5004	
       5005	```swift
       5006	import Foundation
       5007	
       5008	let headers = ["Content-Type": "application/json"]
       5009	let parameters = ["code": "string"] as [String : Any]
       5010	
       5011	let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
       5012	
       5013	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/auth/keys")! as URL,
       5014	                                        cachePolicy: .useProtocolCachePolicy,
       5015	                                    timeoutInterval: 10.0)
       5016	request.httpMethod = "POST"
       5017	request.allHTTPHeaderFields = headers
       5018	request.httpBody = postData as Data
       5019	
       5020	let session = URLSession.shared
       5021	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       5022	  if (error != nil) {
       5023	    print(error as Any)
       5024	  } else {
       5025	    let httpResponse = response as? HTTPURLResponse
       5026	    print(httpResponse)
       5027	  }
       5028	})
       5029	
       5030	dataTask.resume()
       5031	```
       5032	
       5033	```shell
       5034	curl -X POST https://openrouter.ai/api/v1/auth/keys \
       5035	     -H "Content-Type: application/json" \
       5036	     -d '{
       5037	  "code": "string"
       5038	}'
       5039	```
       5040	
       5041	```python
       5042	import requests
       5043	
       5044	url = "https://openrouter.ai/api/v1/auth/keys"
       5045	
       5046	payload = { "code": "string" }
       5047	headers = {"Content-Type": "application/json"}
       5048	
       5049	response = requests.post(url, json=payload, headers=headers)
       5050	
       5051	print(response.json())
       5052	```
       5053	
       5054	```javascript
       5055	const url = 'https://openrouter.ai/api/v1/auth/keys';
       5056	const options = {
       5057	  method: 'POST',
       5058	  headers: {'Content-Type': 'application/json'},
       5059	  body: '{"code":"string"}'
       5060	};
       5061	
       5062	try {
       5063	  const response = await fetch(url, options);
       5064	  const data = await response.json();
       5065	  console.log(data);
       5066	} catch (error) {
       5067	  console.error(error);
       5068	}
       5069	```
       5070	
       5071	```go
       5072	package main
       5073	
       5074	import (
       5075		"fmt"
       5076		"strings"
       5077		"net/http"
       5078		"io"
       5079	)
       5080	
       5081	func main() {
       5082	
       5083		url := "https://openrouter.ai/api/v1/auth/keys"
       5084	
       5085		payload := strings.NewReader("{\n  \"code\": \"string\"\n}")
       5086	
       5087		req, _ := http.NewRequest("POST", url, payload)
       5088	
       5089		req.Header.Add("Content-Type", "application/json")
       5090	
       5091		res, _ := http.DefaultClient.Do(req)
       5092	
       5093		defer res.Body.Close()
       5094		body, _ := io.ReadAll(res.Body)
       5095	
       5096		fmt.Println(res)
       5097		fmt.Println(string(body))
       5098	
       5099	}
       5100	```
       5101	
       5102	```ruby
       5103	require 'uri'
       5104	require 'net/http'
       5105	
       5106	url = URI("https://openrouter.ai/api/v1/auth/keys")
       5107	
       5108	http = Net::HTTP.new(url.host, url.port)
       5109	http.use_ssl = true
       5110	
       5111	request = Net::HTTP::Post.new(url)
       5112	request["Content-Type"] = 'application/json'
       5113	request.body = "{\n  \"code\": \"string\"\n}"
       5114	
       5115	response = http.request(request)
       5116	puts response.read_body
       5117	```
       5118	
       5119	```java
       5120	HttpResponse<String> response = Unirest.post("https://openrouter.ai/api/v1/auth/keys")
       5121	  .header("Content-Type", "application/json")
       5122	  .body("{\n  \"code\": \"string\"\n}")
       5123	  .asString();
       5124	```
       5125	
       5126	```php
       5127	<?php
       5128	
       5129	$client = new \GuzzleHttp\Client();
       5130	
       5131	$response = $client->request('POST', 'https://openrouter.ai/api/v1/auth/keys', [
       5132	  'body' => '{
       5133	  "code": "string"
       5134	}',
       5135	  'headers' => [
       5136	    'Content-Type' => 'application/json',
       5137	  ],
       5138	]);
       5139	
       5140	echo $response->getBody();
       5141	```
       5142	
       5143	```csharp
       5144	var client = new RestClient("https://openrouter.ai/api/v1/auth/keys");
       5145	var request = new RestRequest(Method.POST);
       5146	request.AddHeader("Content-Type", "application/json");
       5147	request.AddParameter("application/json", "{\n  \"code\": \"string\"\n}", ParameterType.RequestBody);
       5148	IRestResponse response = client.Execute(request);
       5149	```
       5150	
       5151	```swift
       5152	import Foundation
       5153	
       5154	let headers = ["Content-Type": "application/json"]
       5155	let parameters = ["code": "string"] as [String : Any]
       5156	
       5157	let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
       5158	
       5159	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/auth/keys")! as URL,
       5160	                                        cachePolicy: .useProtocolCachePolicy,
       5161	                                    timeoutInterval: 10.0)
       5162	request.httpMethod = "POST"
       5163	request.allHTTPHeaderFields = headers
       5164	request.httpBody = postData as Data
       5165	
       5166	let session = URLSession.shared
       5167	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       5168	  if (error != nil) {
       5169	    print(error as Any)
       5170	  } else {
       5171	    let httpResponse = response as? HTTPURLResponse
       5172	    print(httpResponse)
       5173	  }
       5174	})
       5175	
       5176	dataTask.resume()
       5177	```
       5178	
       5179	```shell
       5180	curl -X POST https://openrouter.ai/api/v1/auth/keys \
       5181	     -H "Content-Type: application/json" \
       5182	     -d '{
       5183	  "code": "string"
       5184	}'
       5185	```
       5186	
       5187	```python
       5188	import requests
       5189	
       5190	url = "https://openrouter.ai/api/v1/auth/keys"
       5191	
       5192	payload = { "code": "string" }
       5193	headers = {"Content-Type": "application/json"}
       5194	
       5195	response = requests.post(url, json=payload, headers=headers)
       5196	
       5197	print(response.json())
       5198	```
       5199	
       5200	```javascript
       5201	const url = 'https://openrouter.ai/api/v1/auth/keys';
       5202	const options = {
       5203	  method: 'POST',
       5204	  headers: {'Content-Type': 'application/json'},
       5205	  body: '{"code":"string"}'
       5206	};
       5207	
       5208	try {
       5209	  const response = await fetch(url, options);
       5210	  const data = await response.json();
       5211	  console.log(data);
       5212	} catch (error) {
       5213	  console.error(error);
       5214	}
       5215	```
       5216	
       5217	```go
       5218	package main
       5219	
       5220	import (
       5221		"fmt"
       5222		"strings"
       5223		"net/http"
       5224		"io"
       5225	)
       5226	
       5227	func main() {
       5228	
       5229		url := "https://openrouter.ai/api/v1/auth/keys"
       5230	
       5231		payload := strings.NewReader("{\n  \"code\": \"string\"\n}")
       5232	
       5233		req, _ := http.NewRequest("POST", url, payload)
       5234	
       5235		req.Header.Add("Content-Type", "application/json")
       5236	
       5237		res, _ := http.DefaultClient.Do(req)
       5238	
       5239		defer res.Body.Close()
       5240		body, _ := io.ReadAll(res.Body)
       5241	
       5242		fmt.Println(res)
       5243		fmt.Println(string(body))
       5244	
       5245	}
       5246	```
       5247	
       5248	```ruby
       5249	require 'uri'
       5250	require 'net/http'
       5251	
       5252	url = URI("https://openrouter.ai/api/v1/auth/keys")
       5253	
       5254	http = Net::HTTP.new(url.host, url.port)
       5255	http.use_ssl = true
       5256	
       5257	request = Net::HTTP::Post.new(url)
       5258	request["Content-Type"] = 'application/json'
       5259	request.body = "{\n  \"code\": \"string\"\n}"
       5260	
       5261	response = http.request(request)
       5262	puts response.read_body
       5263	```
       5264	
       5265	```java
       5266	HttpResponse<String> response = Unirest.post("https://openrouter.ai/api/v1/auth/keys")
       5267	  .header("Content-Type", "application/json")
       5268	  .body("{\n  \"code\": \"string\"\n}")
       5269	  .asString();
       5270	```
       5271	
       5272	```php
       5273	<?php
       5274	
       5275	$client = new \GuzzleHttp\Client();
       5276	
       5277	$response = $client->request('POST', 'https://openrouter.ai/api/v1/auth/keys', [
       5278	  'body' => '{
       5279	  "code": "string"
       5280	}',
       5281	  'headers' => [
       5282	    'Content-Type' => 'application/json',
       5283	  ],
       5284	]);
       5285	
       5286	echo $response->getBody();
       5287	```
       5288	
       5289	```csharp
       5290	var client = new RestClient("https://openrouter.ai/api/v1/auth/keys");
       5291	var request = new RestRequest(Method.POST);
       5292	request.AddHeader("Content-Type", "application/json");
       5293	request.AddParameter("application/json", "{\n  \"code\": \"string\"\n}", ParameterType.RequestBody);
       5294	IRestResponse response = client.Execute(request);
       5295	```
       5296	
       5297	```swift
       5298	import Foundation
       5299	
       5300	let headers = ["Content-Type": "application/json"]
       5301	let parameters = ["code": "string"] as [String : Any]
       5302	
       5303	let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
       5304	
       5305	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/auth/keys")! as URL,
       5306	                                        cachePolicy: .useProtocolCachePolicy,
       5307	                                    timeoutInterval: 10.0)
       5308	request.httpMethod = "POST"
       5309	request.allHTTPHeaderFields = headers
       5310	request.httpBody = postData as Data
       5311	
       5312	let session = URLSession.shared
       5313	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       5314	  if (error != nil) {
       5315	    print(error as Any)
       5316	  } else {
       5317	    let httpResponse = response as? HTTPURLResponse
       5318	    print(httpResponse)
       5319	  }
       5320	})
       5321	
       5322	dataTask.resume()
       5323	```
       5324	
       5325	# Get current API key
       5326	
       5327	```http
       5328	GET https://openrouter.ai/api/v1/key
       5329	```
       5330	
       5331	Get information on the API key associated with the current authentication session
       5332	
       5333	
       5334	
       5335	## Response Body
       5336	
       5337	- 200: Successfully retrieved API key information
       5338	- 401: Unauthorized - API key is required
       5339	- 405: Method Not Allowed - Only GET method is supported
       5340	- 500: Internal server error
       5341	
       5342	## Examples
       5343	
       5344	```shell
       5345	curl https://openrouter.ai/api/v1/key \
       5346	     -H "Authorization: Bearer <token>"
       5347	```
       5348	
       5349	```python
       5350	import requests
       5351	
       5352	url = "https://openrouter.ai/api/v1/key"
       5353	
       5354	headers = {"Authorization": "Bearer <token>"}
       5355	
       5356	response = requests.get(url, headers=headers)
       5357	
       5358	print(response.json())
       5359	```
       5360	
       5361	```javascript
       5362	const url = 'https://openrouter.ai/api/v1/key';
       5363	const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};
       5364	
       5365	try {
       5366	  const response = await fetch(url, options);
       5367	  const data = await response.json();
       5368	  console.log(data);
       5369	} catch (error) {
       5370	  console.error(error);
       5371	}
       5372	```
       5373	
       5374	```go
       5375	package main
       5376	
       5377	import (
       5378		"fmt"
       5379		"net/http"
       5380		"io"
       5381	)
       5382	
       5383	func main() {
       5384	
       5385		url := "https://openrouter.ai/api/v1/key"
       5386	
       5387		req, _ := http.NewRequest("GET", url, nil)
       5388	
       5389		req.Header.Add("Authorization", "Bearer <token>")
       5390	
       5391		res, _ := http.DefaultClient.Do(req)
       5392	
       5393		defer res.Body.Close()
       5394		body, _ := io.ReadAll(res.Body)
       5395	
       5396		fmt.Println(res)
       5397		fmt.Println(string(body))
       5398	
       5399	}
       5400	```
       5401	
       5402	```ruby
       5403	require 'uri'
       5404	require 'net/http'
       5405	
       5406	url = URI("https://openrouter.ai/api/v1/key")
       5407	
       5408	http = Net::HTTP.new(url.host, url.port)
       5409	http.use_ssl = true
       5410	
       5411	request = Net::HTTP::Get.new(url)
       5412	request["Authorization"] = 'Bearer <token>'
       5413	
       5414	response = http.request(request)
       5415	puts response.read_body
       5416	```
       5417	
       5418	```java
       5419	HttpResponse<String> response = Unirest.get("https://openrouter.ai/api/v1/key")
       5420	  .header("Authorization", "Bearer <token>")
       5421	  .asString();
       5422	```
       5423	
       5424	```php
       5425	<?php
       5426	
       5427	$client = new \GuzzleHttp\Client();
       5428	
       5429	$response = $client->request('GET', 'https://openrouter.ai/api/v1/key', [
       5430	  'headers' => [
       5431	    'Authorization' => 'Bearer <token>',
       5432	  ],
       5433	]);
       5434	
       5435	echo $response->getBody();
       5436	```
       5437	
       5438	```csharp
       5439	var client = new RestClient("https://openrouter.ai/api/v1/key");
       5440	var request = new RestRequest(Method.GET);
       5441	request.AddHeader("Authorization", "Bearer <token>");
       5442	IRestResponse response = client.Execute(request);
       5443	```
       5444	
       5445	```swift
       5446	import Foundation
       5447	
       5448	let headers = ["Authorization": "Bearer <token>"]
       5449	
       5450	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/key")! as URL,
       5451	                                        cachePolicy: .useProtocolCachePolicy,
       5452	                                    timeoutInterval: 10.0)
       5453	request.httpMethod = "GET"
       5454	request.allHTTPHeaderFields = headers
       5455	
       5456	let session = URLSession.shared
       5457	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       5458	  if (error != nil) {
       5459	    print(error as Any)
       5460	  } else {
       5461	    let httpResponse = response as? HTTPURLResponse
       5462	    print(httpResponse)
       5463	  }
       5464	})
       5465	
       5466	dataTask.resume()
       5467	```
       5468	
       5469	```shell
       5470	curl https://openrouter.ai/api/v1/key \
       5471	     -H "Authorization: Bearer <token>"
       5472	```
       5473	
       5474	```python
       5475	import requests
       5476	
       5477	url = "https://openrouter.ai/api/v1/key"
       5478	
       5479	headers = {"Authorization": "Bearer <token>"}
       5480	
       5481	response = requests.get(url, headers=headers)
       5482	
       5483	print(response.json())
       5484	```
       5485	
       5486	```javascript
       5487	const url = 'https://openrouter.ai/api/v1/key';
       5488	const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};
       5489	
       5490	try {
       5491	  const response = await fetch(url, options);
       5492	  const data = await response.json();
       5493	  console.log(data);
       5494	} catch (error) {
       5495	  console.error(error);
       5496	}
       5497	```
       5498	
       5499	```go
       5500	package main
       5501	
       5502	import (
       5503		"fmt"
       5504		"net/http"
       5505		"io"
       5506	)
       5507	
       5508	func main() {
       5509	
       5510		url := "https://openrouter.ai/api/v1/key"
       5511	
       5512		req, _ := http.NewRequest("GET", url, nil)
       5513	
       5514		req.Header.Add("Authorization", "Bearer <token>")
       5515	
       5516		res, _ := http.DefaultClient.Do(req)
       5517	
       5518		defer res.Body.Close()
       5519		body, _ := io.ReadAll(res.Body)
       5520	
       5521		fmt.Println(res)
       5522		fmt.Println(string(body))
       5523	
       5524	}
       5525	```
       5526	
       5527	```ruby
       5528	require 'uri'
       5529	require 'net/http'
       5530	
       5531	url = URI("https://openrouter.ai/api/v1/key")
       5532	
       5533	http = Net::HTTP.new(url.host, url.port)
       5534	http.use_ssl = true
       5535	
       5536	request = Net::HTTP::Get.new(url)
       5537	request["Authorization"] = 'Bearer <token>'
       5538	
       5539	response = http.request(request)
       5540	puts response.read_body
       5541	```
       5542	
       5543	```java
       5544	HttpResponse<String> response = Unirest.get("https://openrouter.ai/api/v1/key")
       5545	  .header("Authorization", "Bearer <token>")
       5546	  .asString();
       5547	```
       5548	
       5549	```php
       5550	<?php
       5551	
       5552	$client = new \GuzzleHttp\Client();
       5553	
       5554	$response = $client->request('GET', 'https://openrouter.ai/api/v1/key', [
       5555	  'headers' => [
       5556	    'Authorization' => 'Bearer <token>',
       5557	  ],
       5558	]);
       5559	
       5560	echo $response->getBody();
       5561	```
       5562	
       5563	```csharp
       5564	var client = new RestClient("https://openrouter.ai/api/v1/key");
       5565	var request = new RestRequest(Method.GET);
       5566	request.AddHeader("Authorization", "Bearer <token>");
       5567	IRestResponse response = client.Execute(request);
       5568	```
       5569	
       5570	```swift
       5571	import Foundation
       5572	
       5573	let headers = ["Authorization": "Bearer <token>"]
       5574	
       5575	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/key")! as URL,
       5576	                                        cachePolicy: .useProtocolCachePolicy,
       5577	                                    timeoutInterval: 10.0)
       5578	request.httpMethod = "GET"
       5579	request.allHTTPHeaderFields = headers
       5580	
       5581	let session = URLSession.shared
       5582	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       5583	  if (error != nil) {
       5584	    print(error as Any)
       5585	  } else {
       5586	    let httpResponse = response as? HTTPURLResponse
       5587	    print(httpResponse)
       5588	  }
       5589	})
       5590	
       5591	dataTask.resume()
       5592	```
       5593	
       5594	```shell
       5595	curl https://openrouter.ai/api/v1/key \
       5596	     -H "Authorization: Bearer <token>"
       5597	```
       5598	
       5599	```python
       5600	import requests
       5601	
       5602	url = "https://openrouter.ai/api/v1/key"
       5603	
       5604	headers = {"Authorization": "Bearer <token>"}
       5605	
       5606	response = requests.get(url, headers=headers)
       5607	
       5608	print(response.json())
       5609	```
       5610	
       5611	```javascript
       5612	const url = 'https://openrouter.ai/api/v1/key';
       5613	const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};
       5614	
       5615	try {
       5616	  const response = await fetch(url, options);
       5617	  const data = await response.json();
       5618	  console.log(data);
       5619	} catch (error) {
       5620	  console.error(error);
       5621	}
       5622	```
       5623	
       5624	```go
       5625	package main
       5626	
       5627	import (
       5628		"fmt"
       5629		"net/http"
       5630		"io"
       5631	)
       5632	
       5633	func main() {
       5634	
       5635		url := "https://openrouter.ai/api/v1/key"
       5636	
       5637		req, _ := http.NewRequest("GET", url, nil)
       5638	
       5639		req.Header.Add("Authorization", "Bearer <token>")
       5640	
       5641		res, _ := http.DefaultClient.Do(req)
       5642	
       5643		defer res.Body.Close()
       5644		body, _ := io.ReadAll(res.Body)
       5645	
       5646		fmt.Println(res)
       5647		fmt.Println(string(body))
       5648	
       5649	}
       5650	```
       5651	
       5652	```ruby
       5653	require 'uri'
       5654	require 'net/http'
       5655	
       5656	url = URI("https://openrouter.ai/api/v1/key")
       5657	
       5658	http = Net::HTTP.new(url.host, url.port)
       5659	http.use_ssl = true
       5660	
       5661	request = Net::HTTP::Get.new(url)
       5662	request["Authorization"] = 'Bearer <token>'
       5663	
       5664	response = http.request(request)
       5665	puts response.read_body
       5666	```
       5667	
       5668	```java
       5669	HttpResponse<String> response = Unirest.get("https://openrouter.ai/api/v1/key")
       5670	  .header("Authorization", "Bearer <token>")
       5671	  .asString();
       5672	```
       5673	
       5674	```php
       5675	<?php
       5676	
       5677	$client = new \GuzzleHttp\Client();
       5678	
       5679	$response = $client->request('GET', 'https://openrouter.ai/api/v1/key', [
       5680	  'headers' => [
       5681	    'Authorization' => 'Bearer <token>',
       5682	  ],
       5683	]);
       5684	
       5685	echo $response->getBody();
       5686	```
       5687	
       5688	```csharp
       5689	var client = new RestClient("https://openrouter.ai/api/v1/key");
       5690	var request = new RestRequest(Method.GET);
       5691	request.AddHeader("Authorization", "Bearer <token>");
       5692	IRestResponse response = client.Execute(request);
       5693	```
       5694	
       5695	```swift
       5696	import Foundation
       5697	
       5698	let headers = ["Authorization": "Bearer <token>"]
       5699	
       5700	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/key")! as URL,
       5701	                                        cachePolicy: .useProtocolCachePolicy,
       5702	                                    timeoutInterval: 10.0)
       5703	request.httpMethod = "GET"
       5704	request.allHTTPHeaderFields = headers
       5705	
       5706	let session = URLSession.shared
       5707	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       5708	  if (error != nil) {
       5709	    print(error as Any)
       5710	  } else {
       5711	    let httpResponse = response as? HTTPURLResponse
       5712	    print(httpResponse)
       5713	  }
       5714	})
       5715	
       5716	dataTask.resume()
       5717	```
       5718	
       5719	```shell
       5720	curl https://openrouter.ai/api/v1/key \
       5721	     -H "Authorization: Bearer <token>"
       5722	```
       5723	
       5724	```python
       5725	import requests
       5726	
       5727	url = "https://openrouter.ai/api/v1/key"
       5728	
       5729	headers = {"Authorization": "Bearer <token>"}
       5730	
       5731	response = requests.get(url, headers=headers)
       5732	
       5733	print(response.json())
       5734	```
       5735	
       5736	```javascript
       5737	const url = 'https://openrouter.ai/api/v1/key';
       5738	const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};
       5739	
       5740	try {
       5741	  const response = await fetch(url, options);
       5742	  const data = await response.json();
       5743	  console.log(data);
       5744	} catch (error) {
       5745	  console.error(error);
       5746	}
       5747	```
       5748	
       5749	```go
       5750	package main
       5751	
       5752	import (
       5753		"fmt"
       5754		"net/http"
       5755		"io"
       5756	)
       5757	
       5758	func main() {
       5759	
       5760		url := "https://openrouter.ai/api/v1/key"
       5761	
       5762		req, _ := http.NewRequest("GET", url, nil)
       5763	
       5764		req.Header.Add("Authorization", "Bearer <token>")
       5765	
       5766		res, _ := http.DefaultClient.Do(req)
       5767	
       5768		defer res.Body.Close()
       5769		body, _ := io.ReadAll(res.Body)
       5770	
       5771		fmt.Println(res)
       5772		fmt.Println(string(body))
       5773	
       5774	}
       5775	```
       5776	
       5777	```ruby
       5778	require 'uri'
       5779	require 'net/http'
       5780	
       5781	url = URI("https://openrouter.ai/api/v1/key")
       5782	
       5783	http = Net::HTTP.new(url.host, url.port)
       5784	http.use_ssl = true
       5785	
       5786	request = Net::HTTP::Get.new(url)
       5787	request["Authorization"] = 'Bearer <token>'
       5788	
       5789	response = http.request(request)
       5790	puts response.read_body
       5791	```
       5792	
       5793	```java
       5794	HttpResponse<String> response = Unirest.get("https://openrouter.ai/api/v1/key")
       5795	  .header("Authorization", "Bearer <token>")
       5796	  .asString();
       5797	```
       5798	
       5799	```php
       5800	<?php
       5801	
       5802	$client = new \GuzzleHttp\Client();
       5803	
       5804	$response = $client->request('GET', 'https://openrouter.ai/api/v1/key', [
       5805	  'headers' => [
       5806	    'Authorization' => 'Bearer <token>',
       5807	  ],
       5808	]);
       5809	
       5810	echo $response->getBody();
       5811	```
       5812	
       5813	```csharp
       5814	var client = new RestClient("https://openrouter.ai/api/v1/key");
       5815	var request = new RestRequest(Method.GET);
       5816	request.AddHeader("Authorization", "Bearer <token>");
       5817	IRestResponse response = client.Execute(request);
       5818	```
       5819	
       5820	```swift
       5821	import Foundation
       5822	
       5823	let headers = ["Authorization": "Bearer <token>"]
       5824	
       5825	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/key")! as URL,
       5826	                                        cachePolicy: .useProtocolCachePolicy,
       5827	                                    timeoutInterval: 10.0)
       5828	request.httpMethod = "GET"
       5829	request.allHTTPHeaderFields = headers
       5830	
       5831	let session = URLSession.shared
       5832	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       5833	  if (error != nil) {
       5834	    print(error as Any)
       5835	  } else {
       5836	    let httpResponse = response as? HTTPURLResponse
       5837	    print(httpResponse)
       5838	  }
       5839	})
       5840	
       5841	dataTask.resume()
       5842	```
       5843	
       5844	# List API keys
       5845	
       5846	```http
       5847	GET https://openrouter.ai/api/v1/keys
       5848	```
       5849	
       5850	Returns a list of all API keys associated with the account. Requires a Provisioning API key.
       5851	
       5852	
       5853	
       5854	## Query Parameters
       5855	
       5856	- Offset (optional): Offset for the API keys
       5857	- IncludeDisabled (optional): Whether to include disabled API keys in the response
       5858	
       5859	## Response Body
       5860	
       5861	- 200: List of API keys
       5862	
       5863	## Examples
       5864	
       5865	```shell
       5866	curl https://openrouter.ai/api/v1/keys \
       5867	     -H "Authorization: Bearer <token>"
       5868	```
       5869	
       5870	```python
       5871	import requests
       5872	
       5873	url = "https://openrouter.ai/api/v1/keys"
       5874	
       5875	headers = {"Authorization": "Bearer <token>"}
       5876	
       5877	response = requests.get(url, headers=headers)
       5878	
       5879	print(response.json())
       5880	```
       5881	
       5882	```javascript
       5883	const url = 'https://openrouter.ai/api/v1/keys';
       5884	const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};
       5885	
       5886	try {
       5887	  const response = await fetch(url, options);
       5888	  const data = await response.json();
       5889	  console.log(data);
       5890	} catch (error) {
       5891	  console.error(error);
       5892	}
       5893	```
       5894	
       5895	```go
       5896	package main
       5897	
       5898	import (
       5899		"fmt"
       5900		"net/http"
       5901		"io"
       5902	)
       5903	
       5904	func main() {
       5905	
       5906		url := "https://openrouter.ai/api/v1/keys"
       5907	
       5908		req, _ := http.NewRequest("GET", url, nil)
       5909	
       5910		req.Header.Add("Authorization", "Bearer <token>")
       5911	
       5912		res, _ := http.DefaultClient.Do(req)
       5913	
       5914		defer res.Body.Close()
       5915		body, _ := io.ReadAll(res.Body)
       5916	
       5917		fmt.Println(res)
       5918		fmt.Println(string(body))
       5919	
       5920	}
       5921	```
       5922	
       5923	```ruby
       5924	require 'uri'
       5925	require 'net/http'
       5926	
       5927	url = URI("https://openrouter.ai/api/v1/keys")
       5928	
       5929	http = Net::HTTP.new(url.host, url.port)
       5930	http.use_ssl = true
       5931	
       5932	request = Net::HTTP::Get.new(url)
       5933	request["Authorization"] = 'Bearer <token>'
       5934	
       5935	response = http.request(request)
       5936	puts response.read_body
       5937	```
       5938	
       5939	```java
       5940	HttpResponse<String> response = Unirest.get("https://openrouter.ai/api/v1/keys")
       5941	  .header("Authorization", "Bearer <token>")
       5942	  .asString();
       5943	```
       5944	
       5945	```php
       5946	<?php
       5947	
       5948	$client = new \GuzzleHttp\Client();
       5949	
       5950	$response = $client->request('GET', 'https://openrouter.ai/api/v1/keys', [
       5951	  'headers' => [
       5952	    'Authorization' => 'Bearer <token>',
       5953	  ],
       5954	]);
       5955	
       5956	echo $response->getBody();
       5957	```
       5958	
       5959	```csharp
       5960	var client = new RestClient("https://openrouter.ai/api/v1/keys");
       5961	var request = new RestRequest(Method.GET);
       5962	request.AddHeader("Authorization", "Bearer <token>");
       5963	IRestResponse response = client.Execute(request);
       5964	```
       5965	
       5966	```swift
       5967	import Foundation
       5968	
       5969	let headers = ["Authorization": "Bearer <token>"]
       5970	
       5971	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/keys")! as URL,
       5972	                                        cachePolicy: .useProtocolCachePolicy,
       5973	                                    timeoutInterval: 10.0)
       5974	request.httpMethod = "GET"
       5975	request.allHTTPHeaderFields = headers
       5976	
       5977	let session = URLSession.shared
       5978	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       5979	  if (error != nil) {
       5980	    print(error as Any)
       5981	  } else {
       5982	    let httpResponse = response as? HTTPURLResponse
       5983	    print(httpResponse)
       5984	  }
       5985	})
       5986	
       5987	dataTask.resume()
       5988	```
       5989	
       5990	# Create API key
       5991	
       5992	```http
       5993	POST https://openrouter.ai/api/v1/keys
       5994	Content-Type: application/json
       5995	```
       5996	
       5997	Creates a new API key. Requires a Provisioning API key.
       5998	
       5999	
       6000	
       6001	## Response Body
       6002	
       6003	- 200: Created API key
       6004	
       6005	## Examples
       6006	
       6007	```shell
       6008	curl -X POST https://openrouter.ai/api/v1/keys \
       6009	     -H "Authorization: Bearer <token>" \
       6010	     -H "Content-Type: application/json" \
       6011	     -d '{
       6012	  "name": "name"
       6013	}'
       6014	```
       6015	
       6016	```python
       6017	import requests
       6018	
       6019	url = "https://openrouter.ai/api/v1/keys"
       6020	
       6021	payload = { "name": "name" }
       6022	headers = {
       6023	    "Authorization": "Bearer <token>",
       6024	    "Content-Type": "application/json"
       6025	}
       6026	
       6027	response = requests.post(url, json=payload, headers=headers)
       6028	
       6029	print(response.json())
       6030	```
       6031	
       6032	```javascript
       6033	const url = 'https://openrouter.ai/api/v1/keys';
       6034	const options = {
       6035	  method: 'POST',
       6036	  headers: {Authorization: 'Bearer <token>', 'Content-Type': 'application/json'},
       6037	  body: '{"name":"name"}'
       6038	};
       6039	
       6040	try {
       6041	  const response = await fetch(url, options);
       6042	  const data = await response.json();
       6043	  console.log(data);
       6044	} catch (error) {
       6045	  console.error(error);
       6046	}
       6047	```
       6048	
       6049	```go
       6050	package main
       6051	
       6052	import (
       6053		"fmt"
       6054		"strings"
       6055		"net/http"
       6056		"io"
       6057	)
       6058	
       6059	func main() {
       6060	
       6061		url := "https://openrouter.ai/api/v1/keys"
       6062	
       6063		payload := strings.NewReader("{\n  \"name\": \"name\"\n}")
       6064	
       6065		req, _ := http.NewRequest("POST", url, payload)
       6066	
       6067		req.Header.Add("Authorization", "Bearer <token>")
       6068		req.Header.Add("Content-Type", "application/json")
       6069	
       6070		res, _ := http.DefaultClient.Do(req)
       6071	
       6072		defer res.Body.Close()
       6073		body, _ := io.ReadAll(res.Body)
       6074	
       6075		fmt.Println(res)
       6076		fmt.Println(string(body))
       6077	
       6078	}
       6079	```
       6080	
       6081	```ruby
       6082	require 'uri'
       6083	require 'net/http'
       6084	
       6085	url = URI("https://openrouter.ai/api/v1/keys")
       6086	
       6087	http = Net::HTTP.new(url.host, url.port)
       6088	http.use_ssl = true
       6089	
       6090	request = Net::HTTP::Post.new(url)
       6091	request["Authorization"] = 'Bearer <token>'
       6092	request["Content-Type"] = 'application/json'
       6093	request.body = "{\n  \"name\": \"name\"\n}"
       6094	
       6095	response = http.request(request)
       6096	puts response.read_body
       6097	```
       6098	
       6099	```java
       6100	HttpResponse<String> response = Unirest.post("https://openrouter.ai/api/v1/keys")
       6101	  .header("Authorization", "Bearer <token>")
       6102	  .header("Content-Type", "application/json")
       6103	  .body("{\n  \"name\": \"name\"\n}")
       6104	  .asString();
       6105	```
       6106	
       6107	```php
       6108	<?php
       6109	
       6110	$client = new \GuzzleHttp\Client();
       6111	
       6112	$response = $client->request('POST', 'https://openrouter.ai/api/v1/keys', [
       6113	  'body' => '{
       6114	  "name": "name"
       6115	}',
       6116	  'headers' => [
       6117	    'Authorization' => 'Bearer <token>',
       6118	    'Content-Type' => 'application/json',
       6119	  ],
       6120	]);
       6121	
       6122	echo $response->getBody();
       6123	```
       6124	
       6125	```csharp
       6126	var client = new RestClient("https://openrouter.ai/api/v1/keys");
       6127	var request = new RestRequest(Method.POST);
       6128	request.AddHeader("Authorization", "Bearer <token>");
       6129	request.AddHeader("Content-Type", "application/json");
       6130	request.AddParameter("application/json", "{\n  \"name\": \"name\"\n}", ParameterType.RequestBody);
       6131	IRestResponse response = client.Execute(request);
       6132	```
       6133	
       6134	```swift
       6135	import Foundation
       6136	
       6137	let headers = [
       6138	  "Authorization": "Bearer <token>",
       6139	  "Content-Type": "application/json"
       6140	]
       6141	let parameters = ["name": "name"] as [String : Any]
       6142	
       6143	let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
       6144	
       6145	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/keys")! as URL,
       6146	                                        cachePolicy: .useProtocolCachePolicy,
       6147	                                    timeoutInterval: 10.0)
       6148	request.httpMethod = "POST"
       6149	request.allHTTPHeaderFields = headers
       6150	request.httpBody = postData as Data
       6151	
       6152	let session = URLSession.shared
       6153	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       6154	  if (error != nil) {
       6155	    print(error as Any)
       6156	  } else {
       6157	    let httpResponse = response as? HTTPURLResponse
       6158	    print(httpResponse)
       6159	  }
       6160	})
       6161	
       6162	dataTask.resume()
       6163	```
       6164	
       6165	# Get API key
       6166	
       6167	```http
       6168	GET https://openrouter.ai/api/v1/keys/{hash}
       6169	```
       6170	
       6171	Returns details about a specific API key. Requires a Provisioning API key.
       6172	
       6173	
       6174	
       6175	## Path Parameters
       6176	
       6177	- Hash (required): The hash of the API key
       6178	
       6179	## Response Body
       6180	
       6181	- 200: API key details
       6182	
       6183	## Examples
       6184	
       6185	```shell
       6186	curl https://openrouter.ai/api/v1/keys/hash \
       6187	     -H "Authorization: Bearer <token>"
       6188	```
       6189	
       6190	```python
       6191	import requests
       6192	
       6193	url = "https://openrouter.ai/api/v1/keys/hash"
       6194	
       6195	headers = {"Authorization": "Bearer <token>"}
       6196	
       6197	response = requests.get(url, headers=headers)
       6198	
       6199	print(response.json())
       6200	```
       6201	
       6202	```javascript
       6203	const url = 'https://openrouter.ai/api/v1/keys/hash';
       6204	const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};
       6205	
       6206	try {
       6207	  const response = await fetch(url, options);
       6208	  const data = await response.json();
       6209	  console.log(data);
       6210	} catch (error) {
       6211	  console.error(error);
       6212	}
       6213	```
       6214	
       6215	```go
       6216	package main
       6217	
       6218	import (
       6219		"fmt"
       6220		"net/http"
       6221		"io"
       6222	)
       6223	
       6224	func main() {
       6225	
       6226		url := "https://openrouter.ai/api/v1/keys/hash"
       6227	
       6228		req, _ := http.NewRequest("GET", url, nil)
       6229	
       6230		req.Header.Add("Authorization", "Bearer <token>")
       6231	
       6232		res, _ := http.DefaultClient.Do(req)
       6233	
       6234		defer res.Body.Close()
       6235		body, _ := io.ReadAll(res.Body)
       6236	
       6237		fmt.Println(res)
       6238		fmt.Println(string(body))
       6239	
       6240	}
       6241	```
       6242	
       6243	```ruby
       6244	require 'uri'
       6245	require 'net/http'
       6246	
       6247	url = URI("https://openrouter.ai/api/v1/keys/hash")
       6248	
       6249	http = Net::HTTP.new(url.host, url.port)
       6250	http.use_ssl = true
       6251	
       6252	request = Net::HTTP::Get.new(url)
       6253	request["Authorization"] = 'Bearer <token>'
       6254	
       6255	response = http.request(request)
       6256	puts response.read_body
       6257	```
       6258	
       6259	```java
       6260	HttpResponse<String> response = Unirest.get("https://openrouter.ai/api/v1/keys/hash")
       6261	  .header("Authorization", "Bearer <token>")
       6262	  .asString();
       6263	```
       6264	
       6265	```php
       6266	<?php
       6267	
       6268	$client = new \GuzzleHttp\Client();
       6269	
       6270	$response = $client->request('GET', 'https://openrouter.ai/api/v1/keys/hash', [
       6271	  'headers' => [
       6272	    'Authorization' => 'Bearer <token>',
       6273	  ],
       6274	]);
       6275	
       6276	echo $response->getBody();
       6277	```
       6278	
       6279	```csharp
       6280	var client = new RestClient("https://openrouter.ai/api/v1/keys/hash");
       6281	var request = new RestRequest(Method.GET);
       6282	request.AddHeader("Authorization", "Bearer <token>");
       6283	IRestResponse response = client.Execute(request);
       6284	```
       6285	
       6286	```swift
       6287	import Foundation
       6288	
       6289	let headers = ["Authorization": "Bearer <token>"]
       6290	
       6291	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/keys/hash")! as URL,
       6292	                                        cachePolicy: .useProtocolCachePolicy,
       6293	                                    timeoutInterval: 10.0)
       6294	request.httpMethod = "GET"
       6295	request.allHTTPHeaderFields = headers
       6296	
       6297	let session = URLSession.shared
       6298	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       6299	  if (error != nil) {
       6300	    print(error as Any)
       6301	  } else {
       6302	    let httpResponse = response as? HTTPURLResponse
       6303	    print(httpResponse)
       6304	  }
       6305	})
       6306	
       6307	dataTask.resume()
       6308	```
       6309	
       6310	# Delete API key
       6311	
       6312	```http
       6313	DELETE https://openrouter.ai/api/v1/keys/{hash}
       6314	```
       6315	
       6316	Deletes an API key. Requires a Provisioning API key.
       6317	
       6318	
       6319	
       6320	## Path Parameters
       6321	
       6322	- Hash (required): The hash of the API key
       6323	
       6324	## Response Body
       6325	
       6326	- 200: Successfully deleted API key
       6327	
       6328	## Examples
       6329	
       6330	```shell
       6331	curl -X DELETE https://openrouter.ai/api/v1/keys/hash \
       6332	     -H "Authorization: Bearer <token>"
       6333	```
       6334	
       6335	```python
       6336	import requests
       6337	
       6338	url = "https://openrouter.ai/api/v1/keys/hash"
       6339	
       6340	headers = {"Authorization": "Bearer <token>"}
       6341	
       6342	response = requests.delete(url, headers=headers)
       6343	
       6344	print(response.json())
       6345	```
       6346	
       6347	```javascript
       6348	const url = 'https://openrouter.ai/api/v1/keys/hash';
       6349	const options = {method: 'DELETE', headers: {Authorization: 'Bearer <token>'}};
       6350	
       6351	try {
       6352	  const response = await fetch(url, options);
       6353	  const data = await response.json();
       6354	  console.log(data);
       6355	} catch (error) {
       6356	  console.error(error);
       6357	}
       6358	```
       6359	
       6360	```go
       6361	package main
       6362	
       6363	import (
       6364		"fmt"
       6365		"net/http"
       6366		"io"
       6367	)
       6368	
       6369	func main() {
       6370	
       6371		url := "https://openrouter.ai/api/v1/keys/hash"
       6372	
       6373		req, _ := http.NewRequest("DELETE", url, nil)
       6374	
       6375		req.Header.Add("Authorization", "Bearer <token>")
       6376	
       6377		res, _ := http.DefaultClient.Do(req)
       6378	
       6379		defer res.Body.Close()
       6380		body, _ := io.ReadAll(res.Body)
       6381	
       6382		fmt.Println(res)
       6383		fmt.Println(string(body))
       6384	
       6385	}
       6386	```
       6387	
       6388	```ruby
       6389	require 'uri'
       6390	require 'net/http'
       6391	
       6392	url = URI("https://openrouter.ai/api/v1/keys/hash")
       6393	
       6394	http = Net::HTTP.new(url.host, url.port)
       6395	http.use_ssl = true
       6396	
       6397	request = Net::HTTP::Delete.new(url)
       6398	request["Authorization"] = 'Bearer <token>'
       6399	
       6400	response = http.request(request)
       6401	puts response.read_body
       6402	```
       6403	
       6404	```java
       6405	HttpResponse<String> response = Unirest.delete("https://openrouter.ai/api/v1/keys/hash")
       6406	  .header("Authorization", "Bearer <token>")
       6407	  .asString();
       6408	```
       6409	
       6410	```php
       6411	<?php
       6412	
       6413	$client = new \GuzzleHttp\Client();
       6414	
       6415	$response = $client->request('DELETE', 'https://openrouter.ai/api/v1/keys/hash', [
       6416	  'headers' => [
       6417	    'Authorization' => 'Bearer <token>',
       6418	  ],
       6419	]);
       6420	
       6421	echo $response->getBody();
       6422	```
       6423	
       6424	```csharp
       6425	var client = new RestClient("https://openrouter.ai/api/v1/keys/hash");
       6426	var request = new RestRequest(Method.DELETE);
       6427	request.AddHeader("Authorization", "Bearer <token>");
       6428	IRestResponse response = client.Execute(request);
       6429	```
       6430	
       6431	```swift
       6432	import Foundation
       6433	
       6434	let headers = ["Authorization": "Bearer <token>"]
       6435	
       6436	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/keys/hash")! as URL,
       6437	                                        cachePolicy: .useProtocolCachePolicy,
       6438	                                    timeoutInterval: 10.0)
       6439	request.httpMethod = "DELETE"
       6440	request.allHTTPHeaderFields = headers
       6441	
       6442	let session = URLSession.shared
       6443	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       6444	  if (error != nil) {
       6445	    print(error as Any)
       6446	  } else {
       6447	    let httpResponse = response as? HTTPURLResponse
       6448	    print(httpResponse)
       6449	  }
       6450	})
       6451	
       6452	dataTask.resume()
       6453	```
       6454	
       6455	# Update API key
       6456	
       6457	```http
       6458	PATCH https://openrouter.ai/api/v1/keys/{hash}
       6459	Content-Type: application/json
       6460	```
       6461	
       6462	Updates an existing API key. Requires a Provisioning API key.
       6463	
       6464	
       6465	
       6466	## Path Parameters
       6467	
       6468	- Hash (required): The hash of the API key
       6469	
       6470	## Response Body
       6471	
       6472	- 200: Updated API key
       6473	
       6474	## Examples
       6475	
       6476	```shell
       6477	curl -X PATCH https://openrouter.ai/api/v1/keys/hash \
       6478	     -H "Authorization: Bearer <token>" \
       6479	     -H "Content-Type: application/json" \
       6480	     -d '{}'
       6481	```
       6482	
       6483	```python
       6484	import requests
       6485	
       6486	url = "https://openrouter.ai/api/v1/keys/hash"
       6487	
       6488	payload = {}
       6489	headers = {
       6490	    "Authorization": "Bearer <token>",
       6491	    "Content-Type": "application/json"
       6492	}
       6493	
       6494	response = requests.patch(url, json=payload, headers=headers)
       6495	
       6496	print(response.json())
       6497	```
       6498	
       6499	```javascript
       6500	const url = 'https://openrouter.ai/api/v1/keys/hash';
       6501	const options = {
       6502	  method: 'PATCH',
       6503	  headers: {Authorization: 'Bearer <token>', 'Content-Type': 'application/json'},
       6504	  body: '{}'
       6505	};
       6506	
       6507	try {
       6508	  const response = await fetch(url, options);
       6509	  const data = await response.json();
       6510	  console.log(data);
       6511	} catch (error) {
       6512	  console.error(error);
       6513	}
       6514	```
       6515	
       6516	```go
       6517	package main
       6518	
       6519	import (
       6520		"fmt"
       6521		"strings"
       6522		"net/http"
       6523		"io"
       6524	)
       6525	
       6526	func main() {
       6527	
       6528		url := "https://openrouter.ai/api/v1/keys/hash"
       6529	
       6530		payload := strings.NewReader("{}")
       6531	
       6532		req, _ := http.NewRequest("PATCH", url, payload)
       6533	
       6534		req.Header.Add("Authorization", "Bearer <token>")
       6535		req.Header.Add("Content-Type", "application/json")
       6536	
       6537		res, _ := http.DefaultClient.Do(req)
       6538	
       6539		defer res.Body.Close()
       6540		body, _ := io.ReadAll(res.Body)
       6541	
       6542		fmt.Println(res)
       6543		fmt.Println(string(body))
       6544	
       6545	}
       6546	```
       6547	
       6548	```ruby
       6549	require 'uri'
       6550	require 'net/http'
       6551	
       6552	url = URI("https://openrouter.ai/api/v1/keys/hash")
       6553	
       6554	http = Net::HTTP.new(url.host, url.port)
       6555	http.use_ssl = true
       6556	
       6557	request = Net::HTTP::Patch.new(url)
       6558	request["Authorization"] = 'Bearer <token>'
       6559	request["Content-Type"] = 'application/json'
       6560	request.body = "{}"
       6561	
       6562	response = http.request(request)
       6563	puts response.read_body
       6564	```
       6565	
       6566	```java
       6567	HttpResponse<String> response = Unirest.patch("https://openrouter.ai/api/v1/keys/hash")
       6568	  .header("Authorization", "Bearer <token>")
       6569	  .header("Content-Type", "application/json")
       6570	  .body("{}")
       6571	  .asString();
       6572	```
       6573	
       6574	```php
       6575	<?php
       6576	
       6577	$client = new \GuzzleHttp\Client();
       6578	
       6579	$response = $client->request('PATCH', 'https://openrouter.ai/api/v1/keys/hash', [
       6580	  'body' => '{}',
       6581	  'headers' => [
       6582	    'Authorization' => 'Bearer <token>',
       6583	    'Content-Type' => 'application/json',
       6584	  ],
       6585	]);
       6586	
       6587	echo $response->getBody();
       6588	```
       6589	
       6590	```csharp
       6591	var client = new RestClient("https://openrouter.ai/api/v1/keys/hash");
       6592	var request = new RestRequest(Method.PATCH);
       6593	request.AddHeader("Authorization", "Bearer <token>");
       6594	request.AddHeader("Content-Type", "application/json");
       6595	request.AddParameter("application/json", "{}", ParameterType.RequestBody);
       6596	IRestResponse response = client.Execute(request);
       6597	```
       6598	
       6599	```swift
       6600	import Foundation
       6601	
       6602	let headers = [
       6603	  "Authorization": "Bearer <token>",
       6604	  "Content-Type": "application/json"
       6605	]
       6606	let parameters = [] as [String : Any]
       6607	
       6608	let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
       6609	
       6610	let request = NSMutableURLRequest(url: NSURL(string: "https://openrouter.ai/api/v1/keys/hash")! as URL,
       6611	                                        cachePolicy: .useProtocolCachePolicy,
       6612	                                    timeoutInterval: 10.0)
       6613	request.httpMethod = "PATCH"
       6614	request.allHTTPHeaderFields = headers
       6615	request.httpBody = postData as Data
       6616	
       6617	let session = URLSession.shared
       6618	let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
       6619	  if (error != nil) {
       6620	    print(error as Any)
       6621	  } else {
       6622	    let httpResponse = response as? HTTPURLResponse
       6623	    print(httpResponse)
       6624	  }
       6625	})
       6626	
       6627	dataTask.resume()
       6628	```
       6629	
       6630	# BYOK
       6631	
       6632	> Learn how to use your existing AI provider keys with OpenRouter. Integrate your own API keys while leveraging OpenRouter's unified interface and features.
       6633	
       6634	## Bring your own API Keys
       6635	
       6636	OpenRouter supports both OpenRouter credits and the option to bring your own provider keys (BYOK).
       6637	
       6638	When you use OpenRouter credits, your rate limits for each provider are managed by OpenRouter.
       6639	
       6640	Using provider keys enables direct control over rate limits and costs via your provider account.
       6641	
       6642	Your provider keys are securely encrypted and used for all requests routed through the specified provider.
       6643	
       6644	Manage keys in your [account settings](/settings/integrations).
       6645	
       6646	The cost of using custom provider keys on OpenRouter is **5% of what the same model/provider would cost normally on OpenRouter** and will be deducted from your OpenRouter credits.
       6647	
       6648	### Automatic Fallback
       6649	
       6650	You can configure individual keys to act as fallbacks.
       6651	
       6652	When "Use this key as a fallback" is enabled for a key, OpenRouter will prioritize using your credits. If it hits a rate limit or encounters a failure, it will then retry with your key.
       6653	
       6654	Conversely, if "Use this key as a fallback" is disabled for a key, OpenRouter will prioritize using your key. If it hits a rate limit or encounters a failure, it will then retry with your credits.
       6655	
       6656	### Azure API Keys
       6657	
       6658	To use Azure AI Services with OpenRouter, you'll need to provide your Azure API key configuration in JSON format. Each key configuration requires the following fields:
       6659	
       6660	```json
       6661	{
       6662	  "model_slug": "the-openrouter-model-slug",
       6663	  "endpoint_url": "https://<resource>.services.ai.azure.com/deployments/<model-id>/chat/completions?api-version=<api-version>",
       6664	  "api_key": "your-azure-api-key",
       6665	  "model_id": "the-azure-model-id"
       6666	}
       6667	```
       6668	
       6669	You can find these values in your Azure AI Services resource:
       6670	
       6671	1. **endpoint\_url**: Navigate to your Azure AI Services resource in the Azure portal. In the "Overview" section, you'll find your endpoint URL. Make sure to append `/chat/completions` to the base URL. You can read more in the [Azure Foundry documentation](https://learn.microsoft.com/en-us/azure/ai-foundry/model-inference/concepts/endpoints?tabs=python).
       6672	
       6673	2. **api\_key**: In the same "Overview" section of your Azure AI Services resource, you can find your API key under "Keys and Endpoint".
       6674	
       6675	3. **model\_id**: This is the name of your model deployment in Azure AI Services.
       6676	
       6677	4. **model\_slug**: This is the OpenRouter model identifier you want to use this key for.
       6678	
       6679	Since Azure supports multiple model deployments, you can provide an array of configurations for different models:
       6680	
       6681	```json
       6682	[
       6683	  {
       6684	    "model_slug": "mistralai/mistral-large",
       6685	    "endpoint_url": "https://example-project.openai.azure.com/openai/deployments/mistral-large/chat/completions?api-version=2024-08-01-preview",
       6686	    "api_key": "your-azure-api-key",
       6687	    "model_id": "mistral-large"
       6688	  },
       6689	  {
       6690	    "model_slug": "openai/gpt-4o",
       6691	    "endpoint_url": "https://example-project.openai.azure.com/openai/deployments/gpt-4o/chat/completions?api-version=2024-08-01-preview",
       6692	    "api_key": "your-azure-api-key",
       6693	    "model_id": "gpt-4o"
       6694	  }
       6695	]
       6696	```
       6697	
       6698	Make sure to replace the url with your own project url. Also the url should end with /chat/completions with the api version that you would like to use.
       6699	
       6700	### AWS Bedrock API Keys
       6701	
       6702	To use Amazon Bedrock with OpenRouter, you'll need to provide your AWS credentials in JSON format. The configuration requires the following fields:
       6703	
       6704	```json
       6705	{
       6706	  "accessKeyId": "your-aws-access-key-id",
       6707	  "secretAccessKey": "your-aws-secret-access-key",
       6708	  "region": "your-aws-region"
       6709	}
       6710	```
       6711	
       6712	You can find these values in your AWS account:
       6713	
       6714	1. **accessKeyId**: This is your AWS Access Key ID. You can create or find your access keys in the AWS Management Console under "Security Credentials" in your AWS account.
       6715	
       6716	2. **secretAccessKey**: This is your AWS Secret Access Key, which is provided when you create an access key.
       6717	
       6718	3. **region**: The AWS region where your Amazon Bedrock models are deployed (e.g., "us-east-1", "us-west-2").
       6719	
       6720	Make sure your AWS IAM user or role has the necessary permissions to access Amazon Bedrock services. At minimum, you'll need permissions for:
       6721	
       6722	* `bedrock:InvokeModel`
       6723	* `bedrock:InvokeModelWithResponseStream` (for streaming responses)
       6724	
       6725	Example IAM policy:
       6726	
       6727	```json
       6728	{
       6729	  "Version": "2012-10-17",
       6730	  "Statement": [
       6731	    {
       6732	      "Effect": "Allow",
       6733	      "Action": [
       6734	        "bedrock:InvokeModel",
       6735	        "bedrock:InvokeModelWithResponseStream"
       6736	      ],
       6737	      "Resource": "*"
       6738	    }
       6739	  ]
       6740	}
       6741	```
       6742	
       6743	For enhanced security, we recommend creating dedicated IAM users with limited permissions specifically for use with OpenRouter.
       6744	
       6745	Learn more in the [AWS Bedrock Getting Started with the API](https://docs.aws.amazon.com/bedrock/latest/userguide/getting-started-api.html) documentation, [IAM Permissions Setup](https://docs.aws.amazon.com/bedrock/latest/userguide/security-iam.html) guide, or the [AWS Bedrock API Reference](https://docs.aws.amazon.com/bedrock/latest/APIReference/welcome.html).
       6746	
       6747	
       6748	# Crypto API
       6749	
       6750	> Learn how to purchase OpenRouter credits using cryptocurrency. Complete guide to Coinbase integration, supported chains, and automated credit purchases.
       6751	
       6752	You can purchase credits using cryptocurrency through our Coinbase integration. This can either happen through the UI, on your [credits page](https://openrouter.ai/settings/credits), or through our API as described below. While other forms of payment are possible, this guide specifically shows how to pay with the chain's native token.
       6753	
       6754	Headless credit purchases involve three steps:
       6755	
       6756	1. Getting the calldata for a new credit purchase
       6757	2. Sending a transaction on-chain using that data
       6758	3. Detecting low account balance, and purchasing more
       6759	
       6760	## Getting Credit Purchase Calldata
       6761	
       6762	Make a POST request to `/api/v1/credits/coinbase` to create a new charge. You'll include the amount of credits you want to purchase (in USD, up to \${maxDollarPurchase}), the address you'll be sending the transaction from, and the EVM chain ID of the network you'll be sending on.
       6763	
       6764	Currently, we only support the following chains (mainnet only):
       6765	
       6766	* Ethereum ({SupportedChainIDs.Ethereum})
       6767	* Polygon ({SupportedChainIDs.Polygon})
       6768	* Base ({SupportedChainIDs.Base}) ***recommended***
       6769	
       6770	```typescript
       6771	const response = await fetch('https://openrouter.ai/api/v1/credits/coinbase', {
       6772	  method: 'POST',
       6773	  headers: {
       6774	    Authorization: 'Bearer <OPENROUTER_API_KEY>',
       6775	    'Content-Type': 'application/json',
       6776	  },
       6777	  body: JSON.stringify({
       6778	    amount: 10, // Target credit amount in USD
       6779	    sender: '0x9a85CB3bfd494Ea3a8C9E50aA6a3c1a7E8BACE11',
       6780	    chain_id: 8453,
       6781	  }),
       6782	});
       6783	const responseJSON = await response.json();
       6784	```
       6785	
       6786	The response includes the charge details and transaction data needed to execute the on-chain payment:
       6787	
       6788	```json
       6789	{
       6790	  "data": {
       6791	    "id": "...",
       6792	    "created_at": "2024-01-01T00:00:00Z",
       6793	    "expires_at": "2024-01-01T01:00:00Z",
       6794	    "web3_data": {
       6795	      "transfer_intent": {
       6796	        "metadata": {
       6797	          "chain_id": 8453,
       6798	          "contract_address": "0x03059433bcdb6144624cc2443159d9445c32b7a8",
       6799	          "sender": "0x9a85CB3bfd494Ea3a8C9E50aA6a3c1a7E8BACE11"
       6800	        },
       6801	        "call_data": {
       6802	          "recipient_amount": "...",
       6803	          "deadline": "...",
       6804	          "recipient": "...",
       6805	          "recipient_currency": "...",
       6806	          "refund_destination": "...",
       6807	          "fee_amount": "...",
       6808	          "id": "...",
       6809	          "operator": "...",
       6810	          "signature": "...",
       6811	          "prefix": "..."
       6812	        }
       6813	      }
       6814	    }
       6815	  }
       6816	}
       6817	```
       6818	
       6819	## Sending the Transaction
       6820	
       6821	You can use [viem](https://viem.sh) (or another similar evm client) to execute the transaction on-chain.
       6822	
       6823	In this example, we'll be fulfilling the charge using the [swapAndTransferUniswapV3Native()](https://github.com/coinbase/commerce-onchain-payment-protocol/blob/d891289bd1f41bb95f749af537f2b6a36b17f889/contracts/interfaces/ITransfers.sol#L168-L171) function. Other methods of swapping are also available, and you can learn more by checking out Coinbase's [onchain payment protocol here](https://github.com/coinbase/commerce-onchain-payment-protocol/tree/master). Note, if you are trying to pay in a less common ERC-20, there is added complexity in needing to make sure that there is sufficient liquidity in the pool to swap the tokens.
       6824	
       6825	```typescript
       6826	import { createPublicClient, createWalletClient, http, parseEther } from 'viem';
       6827	import { privateKeyToAccount } from 'viem/accounts';
       6828	import { base } from 'viem/chains';
       6829	
       6830	// The ABI for Coinbase's onchain payment protocol
       6831	const abi = [
       6832	  {
       6833	    inputs: [
       6834	      {
       6835	        internalType: 'contract IUniversalRouter',
       6836	        name: '_uniswap',
       6837	        type: 'address',
       6838	      },
       6839	      { internalType: 'contract Permit2', name: '_permit2', type: 'address' },
       6840	      { internalType: 'address', name: '_initialOperator', type: 'address' },
       6841	      {
       6842	        internalType: 'address',
       6843	        name: '_initialFeeDestination',
       6844	        type: 'address',
       6845	      },
       6846	      {
       6847	        internalType: 'contract IWrappedNativeCurrency',
       6848	        name: '_wrappedNativeCurrency',
       6849	        type: 'address',
       6850	      },
       6851	    ],
       6852	    stateMutability: 'nonpayable',
       6853	    type: 'constructor',
       6854	  },
       6855	  { inputs: [], name: 'AlreadyProcessed', type: 'error' },
       6856	  { inputs: [], name: 'ExpiredIntent', type: 'error' },
       6857	  {
       6858	    inputs: [
       6859	      { internalType: 'address', name: 'attemptedCurrency', type: 'address' },
       6860	    ],
       6861	    name: 'IncorrectCurrency',
       6862	    type: 'error',
       6863	  },
       6864	  { inputs: [], name: 'InexactTransfer', type: 'error' },
       6865	  {
       6866	    inputs: [{ internalType: 'uint256', name: 'difference', type: 'uint256' }],
       6867	    name: 'InsufficientAllowance',
       6868	    type: 'error',
       6869	  },
       6870	  {
       6871	    inputs: [{ internalType: 'uint256', name: 'difference', type: 'uint256' }],
       6872	    name: 'InsufficientBalance',
       6873	    type: 'error',
       6874	  },
       6875	  {
       6876	    inputs: [{ internalType: 'int256', name: 'difference', type: 'int256' }],
       6877	    name: 'InvalidNativeAmount',
       6878	    type: 'error',
       6879	  },
       6880	  { inputs: [], name: 'InvalidSignature', type: 'error' },
       6881	  { inputs: [], name: 'InvalidTransferDetails', type: 'error' },
       6882	  {
       6883	    inputs: [
       6884	      { internalType: 'address', name: 'recipient', type: 'address' },
       6885	      { internalType: 'uint256', name: 'amount', type: 'uint256' },
       6886	      { internalType: 'bool', name: 'isRefund', type: 'bool' },
       6887	      { internalType: 'bytes', name: 'data', type: 'bytes' },
       6888	    ],
       6889	    name: 'NativeTransferFailed',
       6890	    type: 'error',
       6891	  },
       6892	  { inputs: [], name: 'NullRecipient', type: 'error' },
       6893	  { inputs: [], name: 'OperatorNotRegistered', type: 'error' },
       6894	  { inputs: [], name: 'PermitCallFailed', type: 'error' },
       6895	  {
       6896	    inputs: [{ internalType: 'bytes', name: 'reason', type: 'bytes' }],
       6897	    name: 'SwapFailedBytes',
       6898	    type: 'error',
       6899	  },
       6900	  {
       6901	    inputs: [{ internalType: 'string', name: 'reason', type: 'string' }],
       6902	    name: 'SwapFailedString',
       6903	    type: 'error',
       6904	  },
       6905	  {
       6906	    anonymous: false,
       6907	    inputs: [
       6908	      {
       6909	        indexed: false,
       6910	        internalType: 'address',
       6911	        name: 'operator',
       6912	        type: 'address',
       6913	      },
       6914	      {
       6915	        indexed: false,
       6916	        internalType: 'address',
       6917	        name: 'feeDestination',
       6918	        type: 'address',
       6919	      },
       6920	    ],
       6921	    name: 'OperatorRegistered',
       6922	    type: 'event',
       6923	  },
       6924	  {
       6925	    anonymous: false,
       6926	    inputs: [
       6927	      {
       6928	        indexed: false,
       6929	        internalType: 'address',
       6930	        name: 'operator',
       6931	        type: 'address',
       6932	      },
       6933	    ],
       6934	    name: 'OperatorUnregistered',
       6935	    type: 'event',
       6936	  },
       6937	  {
       6938	    anonymous: false,
       6939	    inputs: [
       6940	      {
       6941	        indexed: true,
       6942	        internalType: 'address',
       6943	        name: 'previousOwner',
       6944	        type: 'address',
       6945	      },
       6946	      {
       6947	        indexed: true,
       6948	        internalType: 'address',
       6949	        name: 'newOwner',
       6950	        type: 'address',
       6951	      },
       6952	    ],
       6953	    name: 'OwnershipTransferred',
       6954	    type: 'event',
       6955	  },
       6956	  {
       6957	    anonymous: false,
       6958	    inputs: [
       6959	      {
       6960	        indexed: false,
       6961	        internalType: 'address',
       6962	        name: 'account',
       6963	        type: 'address',
       6964	      },
       6965	    ],
       6966	    name: 'Paused',
       6967	    type: 'event',
       6968	  },
       6969	  {
       6970	    anonymous: false,
       6971	    inputs: [
       6972	      {
       6973	        indexed: true,
       6974	        internalType: 'address',
       6975	        name: 'operator',
       6976	        type: 'address',
       6977	      },
       6978	      { indexed: false, internalType: 'bytes16', name: 'id', type: 'bytes16' },
       6979	      {
       6980	        indexed: false,
       6981	        internalType: 'address',
       6982	        name: 'recipient',
       6983	        type: 'address',
       6984	      },
       6985	      {
       6986	        indexed: false,
       6987	        internalType: 'address',
       6988	        name: 'sender',
       6989	        type: 'address',
       6990	      },
       6991	      {
       6992	        indexed: false,
       6993	        internalType: 'uint256',
       6994	        name: 'spentAmount',
       6995	        type: 'uint256',
       6996	      },
       6997	      {
       6998	        indexed: false,
       6999	        internalType: 'address',
       7000	        name: 'spentCurrency',
       7001	        type: 'address',
       7002	      },
       7003	    ],
       7004	    name: 'Transferred',
       7005	    type: 'event',
       7006	  },
       7007	  {
       7008	    anonymous: false,
       7009	    inputs: [
       7010	      {
       7011	        indexed: false,
       7012	        internalType: 'address',
       7013	        name: 'account',
       7014	        type: 'address',
       7015	      },
       7016	    ],
       7017	    name: 'Unpaused',
       7018	    type: 'event',
       7019	  },
       7020	  {
       7021	    inputs: [],
       7022	    name: 'owner',
       7023	    outputs: [{ internalType: 'address', name: '', type: 'address' }],
       7024	    stateMutability: 'view',
       7025	    type: 'function',
       7026	  },
       7027	  {
       7028	    inputs: [],
       7029	    name: 'pause',
       7030	    outputs: [],
       7031	    stateMutability: 'nonpayable',
       7032	    type: 'function',
       7033	  },
       7034	  {
       7035	    inputs: [],
       7036	    name: 'paused',
       7037	    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
       7038	    stateMutability: 'view',
       7039	    type: 'function',
       7040	  },
       7041	  {
       7042	    inputs: [],
       7043	    name: 'permit2',
       7044	    outputs: [{ internalType: 'contract Permit2', name: '', type: 'address' }],
       7045	    stateMutability: 'view',
       7046	    type: 'function',
       7047	  },
       7048	  {
       7049	    inputs: [],
       7050	    name: 'registerOperator',
       7051	    outputs: [],
       7052	    stateMutability: 'nonpayable',
       7053	    type: 'function',
       7054	  },
       7055	  {
       7056	    inputs: [
       7057	      { internalType: 'address', name: '_feeDestination', type: 'address' },
       7058	    ],
       7059	    name: 'registerOperatorWithFeeDestination',
       7060	    outputs: [],
       7061	    stateMutability: 'nonpayable',
       7062	    type: 'function',
       7063	  },
       7064	  {
       7065	    inputs: [],
       7066	    name: 'renounceOwnership',
       7067	    outputs: [],
       7068	    stateMutability: 'nonpayable',
       7069	    type: 'function',
       7070	  },
       7071	  {
       7072	    inputs: [{ internalType: 'address', name: 'newSweeper', type: 'address' }],
       7073	    name: 'setSweeper',
       7074	    outputs: [],
       7075	    stateMutability: 'nonpayable',
       7076	    type: 'function',
       7077	  },
       7078	  {
       7079	    inputs: [
       7080	      {
       7081	        components: [
       7082	          { internalType: 'uint256', name: 'recipientAmount', type: 'uint256' },
       7083	          { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7084	          {
       7085	            internalType: 'address payable',
       7086	            name: 'recipient',
       7087	            type: 'address',
       7088	          },
       7089	          {
       7090	            internalType: 'address',
       7091	            name: 'recipientCurrency',
       7092	            type: 'address',
       7093	          },
       7094	          {
       7095	            internalType: 'address',
       7096	            name: 'refundDestination',
       7097	            type: 'address',
       7098	          },
       7099	          { internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
       7100	          { internalType: 'bytes16', name: 'id', type: 'bytes16' },
       7101	          { internalType: 'address', name: 'operator', type: 'address' },
       7102	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7103	          { internalType: 'bytes', name: 'prefix', type: 'bytes' },
       7104	        ],
       7105	        internalType: 'struct TransferIntent',
       7106	        name: '_intent',
       7107	        type: 'tuple',
       7108	      },
       7109	      {
       7110	        components: [
       7111	          { internalType: 'address', name: 'owner', type: 'address' },
       7112	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7113	        ],
       7114	        internalType: 'struct EIP2612SignatureTransferData',
       7115	        name: '_signatureTransferData',
       7116	        type: 'tuple',
       7117	      },
       7118	    ],
       7119	    name: 'subsidizedTransferToken',
       7120	    outputs: [],
       7121	    stateMutability: 'nonpayable',
       7122	    type: 'function',
       7123	  },
       7124	  {
       7125	    inputs: [
       7126	      {
       7127	        components: [
       7128	          { internalType: 'uint256', name: 'recipientAmount', type: 'uint256' },
       7129	          { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7130	          {
       7131	            internalType: 'address payable',
       7132	            name: 'recipient',
       7133	            type: 'address',
       7134	          },
       7135	          {
       7136	            internalType: 'address',
       7137	            name: 'recipientCurrency',
       7138	            type: 'address',
       7139	          },
       7140	          {
       7141	            internalType: 'address',
       7142	            name: 'refundDestination',
       7143	            type: 'address',
       7144	          },
       7145	          { internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
       7146	          { internalType: 'bytes16', name: 'id', type: 'bytes16' },
       7147	          { internalType: 'address', name: 'operator', type: 'address' },
       7148	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7149	          { internalType: 'bytes', name: 'prefix', type: 'bytes' },
       7150	        ],
       7151	        internalType: 'struct TransferIntent',
       7152	        name: '_intent',
       7153	        type: 'tuple',
       7154	      },
       7155	      { internalType: 'uint24', name: 'poolFeesTier', type: 'uint24' },
       7156	    ],
       7157	    name: 'swapAndTransferUniswapV3Native',
       7158	    outputs: [],
       7159	    stateMutability: 'payable',
       7160	    type: 'function',
       7161	  },
       7162	  {
       7163	    inputs: [
       7164	      {
       7165	        components: [
       7166	          { internalType: 'uint256', name: 'recipientAmount', type: 'uint256' },
       7167	          { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7168	          {
       7169	            internalType: 'address payable',
       7170	            name: 'recipient',
       7171	            type: 'address',
       7172	          },
       7173	          {
       7174	            internalType: 'address',
       7175	            name: 'recipientCurrency',
       7176	            type: 'address',
       7177	          },
       7178	          {
       7179	            internalType: 'address',
       7180	            name: 'refundDestination',
       7181	            type: 'address',
       7182	          },
       7183	          { internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
       7184	          { internalType: 'bytes16', name: 'id', type: 'bytes16' },
       7185	          { internalType: 'address', name: 'operator', type: 'address' },
       7186	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7187	          { internalType: 'bytes', name: 'prefix', type: 'bytes' },
       7188	        ],
       7189	        internalType: 'struct TransferIntent',
       7190	        name: '_intent',
       7191	        type: 'tuple',
       7192	      },
       7193	      {
       7194	        components: [
       7195	          {
       7196	            components: [
       7197	              {
       7198	                components: [
       7199	                  { internalType: 'address', name: 'token', type: 'address' },
       7200	                  { internalType: 'uint256', name: 'amount', type: 'uint256' },
       7201	                ],
       7202	                internalType: 'struct ISignatureTransfer.TokenPermissions',
       7203	                name: 'permitted',
       7204	                type: 'tuple',
       7205	              },
       7206	              { internalType: 'uint256', name: 'nonce', type: 'uint256' },
       7207	              { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7208	            ],
       7209	            internalType: 'struct ISignatureTransfer.PermitTransferFrom',
       7210	            name: 'permit',
       7211	            type: 'tuple',
       7212	          },
       7213	          {
       7214	            components: [
       7215	              { internalType: 'address', name: 'to', type: 'address' },
       7216	              {
       7217	                internalType: 'uint256',
       7218	                name: 'requestedAmount',
       7219	                type: 'uint256',
       7220	              },
       7221	            ],
       7222	            internalType: 'struct ISignatureTransfer.SignatureTransferDetails',
       7223	            name: 'transferDetails',
       7224	            type: 'tuple',
       7225	          },
       7226	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7227	        ],
       7228	        internalType: 'struct Permit2SignatureTransferData',
       7229	        name: '_signatureTransferData',
       7230	        type: 'tuple',
       7231	      },
       7232	      { internalType: 'uint24', name: 'poolFeesTier', type: 'uint24' },
       7233	    ],
       7234	    name: 'swapAndTransferUniswapV3Token',
       7235	    outputs: [],
       7236	    stateMutability: 'nonpayable',
       7237	    type: 'function',
       7238	  },
       7239	  {
       7240	    inputs: [
       7241	      {
       7242	        components: [
       7243	          { internalType: 'uint256', name: 'recipientAmount', type: 'uint256' },
       7244	          { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7245	          {
       7246	            internalType: 'address payable',
       7247	            name: 'recipient',
       7248	            type: 'address',
       7249	          },
       7250	          {
       7251	            internalType: 'address',
       7252	            name: 'recipientCurrency',
       7253	            type: 'address',
       7254	          },
       7255	          {
       7256	            internalType: 'address',
       7257	            name: 'refundDestination',
       7258	            type: 'address',
       7259	          },
       7260	          { internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
       7261	          { internalType: 'bytes16', name: 'id', type: 'bytes16' },
       7262	          { internalType: 'address', name: 'operator', type: 'address' },
       7263	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7264	          { internalType: 'bytes', name: 'prefix', type: 'bytes' },
       7265	        ],
       7266	        internalType: 'struct TransferIntent',
       7267	        name: '_intent',
       7268	        type: 'tuple',
       7269	      },
       7270	      { internalType: 'address', name: '_tokenIn', type: 'address' },
       7271	      { internalType: 'uint256', name: 'maxWillingToPay', type: 'uint256' },
       7272	      { internalType: 'uint24', name: 'poolFeesTier', type: 'uint24' },
       7273	    ],
       7274	    name: 'swapAndTransferUniswapV3TokenPreApproved',
       7275	    outputs: [],
       7276	    stateMutability: 'nonpayable',
       7277	    type: 'function',
       7278	  },
       7279	  {
       7280	    inputs: [
       7281	      { internalType: 'address payable', name: 'destination', type: 'address' },
       7282	    ],
       7283	    name: 'sweepETH',
       7284	    outputs: [],
       7285	    stateMutability: 'nonpayable',
       7286	    type: 'function',
       7287	  },
       7288	  {
       7289	    inputs: [
       7290	      { internalType: 'address payable', name: 'destination', type: 'address' },
       7291	      { internalType: 'uint256', name: 'amount', type: 'uint256' },
       7292	    ],
       7293	    name: 'sweepETHAmount',
       7294	    outputs: [],
       7295	    stateMutability: 'nonpayable',
       7296	    type: 'function',
       7297	  },
       7298	  {
       7299	    inputs: [
       7300	      { internalType: 'address', name: '_token', type: 'address' },
       7301	      { internalType: 'address', name: 'destination', type: 'address' },
       7302	    ],
       7303	    name: 'sweepToken',
       7304	    outputs: [],
       7305	    stateMutability: 'nonpayable',
       7306	    type: 'function',
       7307	  },
       7308	  {
       7309	    inputs: [
       7310	      { internalType: 'address', name: '_token', type: 'address' },
       7311	      { internalType: 'address', name: 'destination', type: 'address' },
       7312	      { internalType: 'uint256', name: 'amount', type: 'uint256' },
       7313	    ],
       7314	    name: 'sweepTokenAmount',
       7315	    outputs: [],
       7316	    stateMutability: 'nonpayable',
       7317	    type: 'function',
       7318	  },
       7319	  {
       7320	    inputs: [],
       7321	    name: 'sweeper',
       7322	    outputs: [{ internalType: 'address', name: '', type: 'address' }],
       7323	    stateMutability: 'view',
       7324	    type: 'function',
       7325	  },
       7326	  {
       7327	    inputs: [
       7328	      {
       7329	        components: [
       7330	          { internalType: 'uint256', name: 'recipientAmount', type: 'uint256' },
       7331	          { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7332	          {
       7333	            internalType: 'address payable',
       7334	            name: 'recipient',
       7335	            type: 'address',
       7336	          },
       7337	          {
       7338	            internalType: 'address',
       7339	            name: 'recipientCurrency',
       7340	            type: 'address',
       7341	          },
       7342	          {
       7343	            internalType: 'address',
       7344	            name: 'refundDestination',
       7345	            type: 'address',
       7346	          },
       7347	          { internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
       7348	          { internalType: 'bytes16', name: 'id', type: 'bytes16' },
       7349	          { internalType: 'address', name: 'operator', type: 'address' },
       7350	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7351	          { internalType: 'bytes', name: 'prefix', type: 'bytes' },
       7352	        ],
       7353	        internalType: 'struct TransferIntent',
       7354	        name: '_intent',
       7355	        type: 'tuple',
       7356	      },
       7357	    ],
       7358	    name: 'transferNative',
       7359	    outputs: [],
       7360	    stateMutability: 'payable',
       7361	    type: 'function',
       7362	  },
       7363	  {
       7364	    inputs: [{ internalType: 'address', name: 'newOwner', type: 'address' }],
       7365	    name: 'transferOwnership',
       7366	    outputs: [],
       7367	    stateMutability: 'nonpayable',
       7368	    type: 'function',
       7369	  },
       7370	  {
       7371	    inputs: [
       7372	      {
       7373	        components: [
       7374	          { internalType: 'uint256', name: 'recipientAmount', type: 'uint256' },
       7375	          { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7376	          {
       7377	            internalType: 'address payable',
       7378	            name: 'recipient',
       7379	            type: 'address',
       7380	          },
       7381	          {
       7382	            internalType: 'address',
       7383	            name: 'recipientCurrency',
       7384	            type: 'address',
       7385	          },
       7386	          {
       7387	            internalType: 'address',
       7388	            name: 'refundDestination',
       7389	            type: 'address',
       7390	          },
       7391	          { internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
       7392	          { internalType: 'bytes16', name: 'id', type: 'bytes16' },
       7393	          { internalType: 'address', name: 'operator', type: 'address' },
       7394	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7395	          { internalType: 'bytes', name: 'prefix', type: 'bytes' },
       7396	        ],
       7397	        internalType: 'struct TransferIntent',
       7398	        name: '_intent',
       7399	        type: 'tuple',
       7400	      },
       7401	      {
       7402	        components: [
       7403	          {
       7404	            components: [
       7405	              {
       7406	                components: [
       7407	                  { internalType: 'address', name: 'token', type: 'address' },
       7408	                  { internalType: 'uint256', name: 'amount', type: 'uint256' },
       7409	                ],
       7410	                internalType: 'struct ISignatureTransfer.TokenPermissions',
       7411	                name: 'permitted',
       7412	                type: 'tuple',
       7413	              },
       7414	              { internalType: 'uint256', name: 'nonce', type: 'uint256' },
       7415	              { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7416	            ],
       7417	            internalType: 'struct ISignatureTransfer.PermitTransferFrom',
       7418	            name: 'permit',
       7419	            type: 'tuple',
       7420	          },
       7421	          {
       7422	            components: [
       7423	              { internalType: 'address', name: 'to', type: 'address' },
       7424	              {
       7425	                internalType: 'uint256',
       7426	                name: 'requestedAmount',
       7427	                type: 'uint256',
       7428	              },
       7429	            ],
       7430	            internalType: 'struct ISignatureTransfer.SignatureTransferDetails',
       7431	            name: 'transferDetails',
       7432	            type: 'tuple',
       7433	          },
       7434	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7435	        ],
       7436	        internalType: 'struct Permit2SignatureTransferData',
       7437	        name: '_signatureTransferData',
       7438	        type: 'tuple',
       7439	      },
       7440	    ],
       7441	    name: 'transferToken',
       7442	    outputs: [],
       7443	    stateMutability: 'nonpayable',
       7444	    type: 'function',
       7445	  },
       7446	  {
       7447	    inputs: [
       7448	      {
       7449	        components: [
       7450	          { internalType: 'uint256', name: 'recipientAmount', type: 'uint256' },
       7451	          { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7452	          {
       7453	            internalType: 'address payable',
       7454	            name: 'recipient',
       7455	            type: 'address',
       7456	          },
       7457	          {
       7458	            internalType: 'address',
       7459	            name: 'recipientCurrency',
       7460	            type: 'address',
       7461	          },
       7462	          {
       7463	            internalType: 'address',
       7464	            name: 'refundDestination',
       7465	            type: 'address',
       7466	          },
       7467	          { internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
       7468	          { internalType: 'bytes16', name: 'id', type: 'bytes16' },
       7469	          { internalType: 'address', name: 'operator', type: 'address' },
       7470	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7471	          { internalType: 'bytes', name: 'prefix', type: 'bytes' },
       7472	        ],
       7473	        internalType: 'struct TransferIntent',
       7474	        name: '_intent',
       7475	        type: 'tuple',
       7476	      },
       7477	    ],
       7478	    name: 'transferTokenPreApproved',
       7479	    outputs: [],
       7480	    stateMutability: 'nonpayable',
       7481	    type: 'function',
       7482	  },
       7483	  {
       7484	    inputs: [],
       7485	    name: 'unpause',
       7486	    outputs: [],
       7487	    stateMutability: 'nonpayable',
       7488	    type: 'function',
       7489	  },
       7490	  {
       7491	    inputs: [],
       7492	    name: 'unregisterOperator',
       7493	    outputs: [],
       7494	    stateMutability: 'nonpayable',
       7495	    type: 'function',
       7496	  },
       7497	  {
       7498	    inputs: [
       7499	      {
       7500	        components: [
       7501	          { internalType: 'uint256', name: 'recipientAmount', type: 'uint256' },
       7502	          { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7503	          {
       7504	            internalType: 'address payable',
       7505	            name: 'recipient',
       7506	            type: 'address',
       7507	          },
       7508	          {
       7509	            internalType: 'address',
       7510	            name: 'recipientCurrency',
       7511	            type: 'address',
       7512	          },
       7513	          {
       7514	            internalType: 'address',
       7515	            name: 'refundDestination',
       7516	            type: 'address',
       7517	          },
       7518	          { internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
       7519	          { internalType: 'bytes16', name: 'id', type: 'bytes16' },
       7520	          { internalType: 'address', name: 'operator', type: 'address' },
       7521	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7522	          { internalType: 'bytes', name: 'prefix', type: 'bytes' },
       7523	        ],
       7524	        internalType: 'struct TransferIntent',
       7525	        name: '_intent',
       7526	        type: 'tuple',
       7527	      },
       7528	      {
       7529	        components: [
       7530	          {
       7531	            components: [
       7532	              {
       7533	                components: [
       7534	                  { internalType: 'address', name: 'token', type: 'address' },
       7535	                  { internalType: 'uint256', name: 'amount', type: 'uint256' },
       7536	                ],
       7537	                internalType: 'struct ISignatureTransfer.TokenPermissions',
       7538	                name: 'permitted',
       7539	                type: 'tuple',
       7540	              },
       7541	              { internalType: 'uint256', name: 'nonce', type: 'uint256' },
       7542	              { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7543	            ],
       7544	            internalType: 'struct ISignatureTransfer.PermitTransferFrom',
       7545	            name: 'permit',
       7546	            type: 'tuple',
       7547	          },
       7548	          {
       7549	            components: [
       7550	              { internalType: 'address', name: 'to', type: 'address' },
       7551	              {
       7552	                internalType: 'uint256',
       7553	                name: 'requestedAmount',
       7554	                type: 'uint256',
       7555	              },
       7556	            ],
       7557	            internalType: 'struct ISignatureTransfer.SignatureTransferDetails',
       7558	            name: 'transferDetails',
       7559	            type: 'tuple',
       7560	          },
       7561	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7562	        ],
       7563	        internalType: 'struct Permit2SignatureTransferData',
       7564	        name: '_signatureTransferData',
       7565	        type: 'tuple',
       7566	      },
       7567	    ],
       7568	    name: 'unwrapAndTransfer',
       7569	    outputs: [],
       7570	    stateMutability: 'nonpayable',
       7571	    type: 'function',
       7572	  },
       7573	  {
       7574	    inputs: [
       7575	      {
       7576	        components: [
       7577	          { internalType: 'uint256', name: 'recipientAmount', type: 'uint256' },
       7578	          { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7579	          {
       7580	            internalType: 'address payable',
       7581	            name: 'recipient',
       7582	            type: 'address',
       7583	          },
       7584	          {
       7585	            internalType: 'address',
       7586	            name: 'recipientCurrency',
       7587	            type: 'address',
       7588	          },
       7589	          {
       7590	            internalType: 'address',
       7591	            name: 'refundDestination',
       7592	            type: 'address',
       7593	          },
       7594	          { internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
       7595	          { internalType: 'bytes16', name: 'id', type: 'bytes16' },
       7596	          { internalType: 'address', name: 'operator', type: 'address' },
       7597	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7598	          { internalType: 'bytes', name: 'prefix', type: 'bytes' },
       7599	        ],
       7600	        internalType: 'struct TransferIntent',
       7601	        name: '_intent',
       7602	        type: 'tuple',
       7603	      },
       7604	    ],
       7605	    name: 'unwrapAndTransferPreApproved',
       7606	    outputs: [],
       7607	    stateMutability: 'nonpayable',
       7608	    type: 'function',
       7609	  },
       7610	  {
       7611	    inputs: [
       7612	      {
       7613	        components: [
       7614	          { internalType: 'uint256', name: 'recipientAmount', type: 'uint256' },
       7615	          { internalType: 'uint256', name: 'deadline', type: 'uint256' },
       7616	          {
       7617	            internalType: 'address payable',
       7618	            name: 'recipient',
       7619	            type: 'address',
       7620	          },
       7621	          {
       7622	            internalType: 'address',
       7623	            name: 'recipientCurrency',
       7624	            type: 'address',
       7625	          },
       7626	          {
       7627	            internalType: 'address',
       7628	            name: 'refundDestination',
       7629	            type: 'address',
       7630	          },
       7631	          { internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
       7632	          { internalType: 'bytes16', name: 'id', type: 'bytes16' },
       7633	          { internalType: 'address', name: 'operator', type: 'address' },
       7634	          { internalType: 'bytes', name: 'signature', type: 'bytes' },
       7635	          { internalType: 'bytes', name: 'prefix', type: 'bytes' },
       7636	        ],
       7637	        internalType: 'struct TransferIntent',
       7638	        name: '_intent',
       7639	        type: 'tuple',
       7640	      },
       7641	    ],
       7642	    name: 'wrapAndTransfer',
       7643	    outputs: [],
       7644	    stateMutability: 'payable',
       7645	    type: 'function',
       7646	  },
       7647	  { stateMutability: 'payable', type: 'receive' },
       7648	];
       7649	
       7650	// Set up viem clients
       7651	const publicClient = createPublicClient({
       7652	  chain: base,
       7653	  transport: http(),
       7654	});
       7655	const account = privateKeyToAccount('0x...');
       7656	const walletClient = createWalletClient({
       7657	  chain: base,
       7658	  transport: http(),
       7659	  account,
       7660	});
       7661	
       7662	// Use the calldata included in the charge response
       7663	const { contract_address } =
       7664	  responseJSON.data.web3_data.transfer_intent.metadata;
       7665	const call_data = responseJSON.data.web3_data.transfer_intent.call_data;
       7666	
       7667	// When transacting in ETH, a pool fees tier of 500 (the lowest) is very
       7668	// likely to be sufficient. However, if you plan to swap with a different
       7669	// contract method, using less-common ERC-20 tokens, it is recommended to
       7670	// call that chain's Uniswap QuoterV2 contract to check its liquidity.
       7671	// Depending on the results, choose the lowest fee tier which has enough
       7672	// liquidity in the pool.
       7673	const poolFeesTier = 500;
       7674	
       7675	// Simulate the transaction first to prevent most common revert reasons
       7676	const { request } = await publicClient.simulateContract({
       7677	  abi,
       7678	  account,
       7679	  address: contract_address,
       7680	  functionName: 'swapAndTransferUniswapV3Native',
       7681	  args: [
       7682	    {
       7683	      recipientAmount: BigInt(call_data.recipient_amount),
       7684	      deadline: BigInt(
       7685	        Math.floor(new Date(call_data.deadline).getTime() / 1000),
       7686	      ),
       7687	      recipient: call_data.recipient,
       7688	      recipientCurrency: call_data.recipient_currency,
       7689	      refundDestination: call_data.refund_destination,
       7690	      feeAmount: BigInt(call_data.fee_amount),
       7691	      id: call_data.id,
       7692	      operator: call_data.operator,
       7693	      signature: call_data.signature,
       7694	      prefix: call_data.prefix,
       7695	    },
       7696	    poolFeesTier,
       7697	  ],
       7698	  // Transaction value in ETH. You'll want to include a little extra to
       7699	  // ensure the transaction & swap is successful. All excess funds return
       7700	  // back to your sender address afterwards.
       7701	  value: parseEther('0.004'),
       7702	});
       7703	
       7704	// Send the transaction on chain
       7705	const txHash = await walletClient.writeContract(request);
       7706	console.log('Transaction hash:', txHash);
       7707	```
       7708	
       7709	Once the transaction succeeds on chain, we'll add credits to your account. You can track the transaction status using the returned transaction hash.
       7710	
       7711	Credit purchases lower than \$500 will be immediately credited once the transaction is on chain. Above \$500, there is a \~15 minute confirmation delay, ensuring the chain does not re-org your purchase.
       7712	
       7713	## Detecting Low Balance
       7714	
       7715	While it is possible to simply run down the balance until your app starts receiving 402 error codes for insufficient credits, this gap in service while topping up might not be desirable.
       7716	
       7717	To avoid this, you can periodically call the `GET /api/v1/credits` endpoint to check your available credits.
       7718	
       7719	```typescript
       7720	const response = await fetch('https://openrouter.ai/api/v1/credits', {
       7721	  method: 'GET',
       7722	  headers: { Authorization: 'Bearer <OPENROUTER_API_KEY>' },
       7723	});
       7724	const { data } = await response.json();
       7725	```
       7726	
       7727	The response includes your total credits purchased and usage, where your current balance is the difference between the two:
       7728	
       7729	```json
       7730	{
       7731	  "data": {
       7732	    "total_credits": 50.0,
       7733	    "total_usage": 42.0
       7734	  }
       7735	}
       7736	```
       7737	
       7738	Note that these values are cached, and may be up to 60 seconds stale.
       7739	
       7740	
       7741	# OAuth PKCE
       7742	
       7743	> Implement secure user authentication with OpenRouter using OAuth PKCE. Complete guide to setting up and managing OAuth authentication flows.
       7744	
       7745	Users can connect to OpenRouter in one click using [Proof Key for Code Exchange (PKCE)](https://oauth.net/2/pkce/).
       7746	
       7747	Here's a step-by-step guide:
       7748	
       7749	## PKCE Guide
       7750	
       7751	### Step 1: Send your user to OpenRouter
       7752	
       7753	To start the PKCE flow, send your user to OpenRouter's `/auth` URL with a `callback_url` parameter pointing back to your site:
       7754	
       7755	<CodeGroup>
       7756	  ```txt title="With S256 Code Challenge (Recommended)" wordWrap
       7757	  https://openrouter.ai/auth?callback_url=<YOUR_SITE_URL>&code_challenge=<CODE_CHALLENGE>&code_challenge_method=S256
       7758	  ```
       7759	
       7760	  ```txt title="With Plain Code Challenge" wordWrap
       7761	  https://openrouter.ai/auth?callback_url=<YOUR_SITE_URL>&code_challenge=<CODE_CHALLENGE>&code_challenge_method=plain
       7762	  ```
       7763	
       7764	  ```txt title="Without Code Challenge" wordWrap
       7765	  https://openrouter.ai/auth?callback_url=<YOUR_SITE_URL>
       7766	  ```
       7767	</CodeGroup>
       7768	
       7769	The `code_challenge` parameter is optional but recommended.
       7770	
       7771	Your user will be prompted to log in to OpenRouter and authorize your app. After authorization, they will be redirected back to your site with a `code` parameter in the URL:
       7772	
       7773	![Alt text](file:54424911-a0f6-4edf-8f98-5bef7ed50185)
       7774	
       7775	<Tip title="Use SHA-256 for Maximum Security">
       7776	  For maximum security, set `code_challenge_method` to `S256`, and set `code_challenge` to the base64 encoding of the sha256 hash of `code_verifier`.
       7777	
       7778	  For more info, [visit Auth0's docs](https://auth0.com/docs/get-started/authentication-and-authorization-flow/call-your-api-using-the-authorization-code-flow-with-pkce#parameters).
       7779	</Tip>
       7780	
       7781	#### How to Generate a Code Challenge
       7782	
       7783	The following example leverages the Web Crypto API and the Buffer API to generate a code challenge for the S256 method. You will need a bundler to use the Buffer API in the web browser:
       7784	
       7785	<CodeGroup>
       7786	  ```typescript title="Generate Code Challenge"
       7787	  import { Buffer } from 'buffer';
       7788	
       7789	  async function createSHA256CodeChallenge(input: string) {
       7790	    const encoder = new TextEncoder();
       7791	    const data = encoder.encode(input);
       7792	    const hash = await crypto.subtle.digest('SHA-256', data);
       7793	    return Buffer.from(hash).toString('base64url');
       7794	  }
       7795	
       7796	  const codeVerifier = 'your-random-string';
       7797	  const generatedCodeChallenge = await createSHA256CodeChallenge(codeVerifier);
       7798	  ```
       7799	</CodeGroup>
       7800	
       7801	#### Localhost Apps
       7802	
       7803	If your app is a local-first app or otherwise doesn't have a public URL, it is recommended to test with `http://localhost:3000` as the callback and referrer URLs.
       7804	
       7805	When moving to production, replace the localhost/private referrer URL with a public GitHub repo or a link to your project website.
       7806	
       7807	### Step 2: Exchange the code for a user-controlled API key
       7808	
       7809	After the user logs in with OpenRouter, they are redirected back to your site with a `code` parameter in the URL:
       7810	
       7811	![Alt text](file:93c60f30-b13c-4a64-9a20-a92291fb70d3)
       7812	
       7813	Extract this code using the browser API:
       7814	
       7815	<CodeGroup>
       7816	  ```typescript title="Extract Code"
       7817	  const urlParams = new URLSearchParams(window.location.search);
       7818	  const code = urlParams.get('code');
       7819	  ```
       7820	</CodeGroup>
       7821	
       7822	Then use it to make an API call to `https://openrouter.ai/api/v1/auth/keys` to exchange the code for a user-controlled API key:
       7823	
       7824	<CodeGroup>
       7825	  ```typescript title="Exchange Code"
       7826	  const response = await fetch('https://openrouter.ai/api/v1/auth/keys', {
       7827	    method: 'POST',
       7828	    headers: {
       7829	      'Content-Type': 'application/json',
       7830	    },
       7831	    body: JSON.stringify({
       7832	      code: '<CODE_FROM_QUERY_PARAM>',
       7833	      code_verifier: '<CODE_VERIFIER>', // If code_challenge was used
       7834	      code_challenge_method: '<CODE_CHALLENGE_METHOD>', // If code_challenge was used
       7835	    }),
       7836	  });
       7837	
       7838	  const { key } = await response.json();
       7839	  ```
       7840	</CodeGroup>
       7841	
       7842	And that's it for the PKCE flow!
       7843	
       7844	### Step 3: Use the API key
       7845	
       7846	Store the API key securely within the user's browser or in your own database, and use it to [make OpenRouter requests](/api-reference/completion).
       7847	
       7848	<CodeGroup>
       7849	  ```typescript title="Make an OpenRouter request"
       7850	  fetch('https://openrouter.ai/api/v1/chat/completions', {
       7851	    method: 'POST',
       7852	    headers: {
       7853	      Authorization: 'Bearer <API_KEY>',
       7854	      'Content-Type': 'application/json',
       7855	    },
       7856	    body: JSON.stringify({
       7857	      model: 'openai/gpt-4o',
       7858	      messages: [
       7859	        {
       7860	          role: 'user',
       7861	          content: 'Hello!',
       7862	        },
       7863	      ],
       7864	    }),
       7865	  });
       7866	  ```
       7867	</CodeGroup>
       7868	
       7869	## Error Codes
       7870	
       7871	* `400 Invalid code_challenge_method`: Make sure you're using the same code challenge method in step 1 as in step 2.
       7872	* `403 Invalid code or code_verifier`: Make sure your user is logged in to OpenRouter, and that `code_verifier` and `code_challenge_method` are correct.
       7873	* `405 Method Not Allowed`: Make sure you're using `POST` and `HTTPS` for your request.
       7874	
       7875	## External Tools
       7876	
       7877	* [PKCE Tools](https://example-app.com/pkce)
       7878	* [Online PKCE Generator](https://tonyxu-io.github.io/pkce-generator/)
       7879	
       7880	
       7881	# Using MCP Servers with OpenRouter
       7882	
       7883	> Learn how to use MCP Servers with OpenRouter
       7884	
       7885	MCP servers are a popular way of providing LLMs with tool calling abilities, and are an alternative to using OpenAI-compatible tool calling.
       7886	
       7887	By converting MCP (Anthropic) tool definitions to OpenAI-compatible tool definitions, you can use MCP servers with OpenRouter.
       7888	
       7889	In this example, we'll use [Anthropic's MCP client SDK](https://github.com/modelcontextprotocol/python-sdk?tab=readme-ov-file#writing-mcp-clients) to interact with the File System MCP, all with OpenRouter under the hood.
       7890	
       7891	<Warning>
       7892	  Note that interacting with MCP servers is more complex than calling a REST
       7893	  endpoint. The MCP protocol is stateful and requires session management. The
       7894	  example below uses the MCP client SDK, but is still somewhat complex.
       7895	</Warning>
       7896	
       7897	First, some setup. In order to run this you will need to pip install the packages, and create a `.env` file with OPENAI\_API\_KEY set. This example also assumes the directory `/Applications` exists.
       7898	
       7899	```python
       7900	import asyncio
       7901	from typing import Optional
       7902	from contextlib import AsyncExitStack
       7903	
       7904	from mcp import ClientSession, StdioServerParameters
       7905	from mcp.client.stdio import stdio_client
       7906	
       7907	from openai import OpenAI
       7908	from dotenv import load_dotenv
       7909	import json
       7910	
       7911	load_dotenv()  # load environment variables from .env
       7912	
       7913	MODEL = "anthropic/claude-3-7-sonnet"
       7914	
       7915	SERVER_CONFIG = {
       7916	    "command": "npx",
       7917	    "args": ["-y",
       7918	              "@modelcontextprotocol/server-filesystem",
       7919	              f"/Applications/"],
       7920	    "env": None
       7921	}
       7922	```
       7923	
       7924	Next, our helper function to convert MCP tool definitions to OpenAI tool definitions:
       7925	
       7926	```python
       7927	
       7928	def convert_tool_format(tool):
       7929	    converted_tool = {
       7930	        "type": "function",
       7931	        "function": {
       7932	            "name": tool.name,
       7933	            "description": tool.description,
       7934	            "parameters": {
       7935	                "type": "object",
       7936	                "properties": tool.inputSchema["properties"],
       7937	                "required": tool.inputSchema["required"]
       7938	            }
       7939	        }
       7940	    }
       7941	    return converted_tool
       7942	
       7943	```
       7944	
       7945	And, the MCP client itself; a regrettable \~100 lines of code. Note that the SERVER\_CONFIG is hard-coded into the client, but of course could be parameterized for other MCP servers.
       7946	
       7947	```python
       7948	class MCPClient:
       7949	    def __init__(self):
       7950	        self.session: Optional[ClientSession] = None
       7951	        self.exit_stack = AsyncExitStack()
       7952	        self.openai = OpenAI(
       7953	            base_url="https://openrouter.ai/api/v1"
       7954	        )
       7955	
       7956	    async def connect_to_server(self, server_config):
       7957	        server_params = StdioServerParameters(**server_config)
       7958	        stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))
       7959	        self.stdio, self.write = stdio_transport
       7960	        self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))
       7961	
       7962	        await self.session.initialize()
       7963	
       7964	        # List available tools from the MCP server
       7965	        response = await self.session.list_tools()
       7966	        print("\nConnected to server with tools:", [tool.name for tool in response.tools])
       7967	
       7968	        self.messages = []
       7969	
       7970	    async def process_query(self, query: str) -> str:
       7971	
       7972	        self.messages.append({
       7973	            "role": "user",
       7974	            "content": query
       7975	        })
       7976	
       7977	        response = await self.session.list_tools()
       7978	        available_tools = [convert_tool_format(tool) for tool in response.tools]
       7979	
       7980	        response = self.openai.chat.completions.create(
       7981	            model=MODEL,
       7982	            tools=available_tools,
       7983	            messages=self.messages
       7984	        )
       7985	        self.messages.append(response.choices[0].message.model_dump())
       7986	
       7987	        final_text = []
       7988	        content = response.choices[0].message
       7989	        if content.tool_calls is not None:
       7990	            tool_name = content.tool_calls[0].function.name
       7991	            tool_args = content.tool_calls[0].function.arguments
       7992	            tool_args = json.loads(tool_args) if tool_args else {}
       7993	
       7994	            # Execute tool call
       7995	            try:
       7996	                result = await self.session.call_tool(tool_name, tool_args)
       7997	                final_text.append(f"[Calling tool {tool_name} with args {tool_args}]")
       7998	            except Exception as e:
       7999	                print(f"Error calling tool {tool_name}: {e}")
       8000	                result = None
       8001	
       8002	            self.messages.append({
       8003	                "role": "tool",
       8004	                "tool_call_id": content.tool_calls[0].id,
       8005	                "name": tool_name,
       8006	                "content": result.content
       8007	            })
       8008	
       8009	            response = self.openai.chat.completions.create(
       8010	                model=MODEL,
       8011	                max_tokens=1000,
       8012	                messages=self.messages,
       8013	            )
       8014	
       8015	            final_text.append(response.choices[0].message.content)
       8016	        else:
       8017	            final_text.append(content.content)
       8018	
       8019	        return "\n".join(final_text)
       8020	
       8021	    async def chat_loop(self):
       8022	        """Run an interactive chat loop"""
       8023	        print("\nMCP Client Started!")
       8024	        print("Type your queries or 'quit' to exit.")
       8025	
       8026	        while True:
       8027	            try:
       8028	                query = input("\nQuery: ").strip()
       8029	                result = await self.process_query(query)
       8030	                print("Result:")
       8031	                print(result)
       8032	
       8033	            except Exception as e:
       8034	                print(f"Error: {str(e)}")
       8035	
       8036	    async def cleanup(self):
       8037	        await self.exit_stack.aclose()
       8038	
       8039	async def main():
       8040	    client = MCPClient()
       8041	    try:
       8042	        await client.connect_to_server(SERVER_CONFIG)
       8043	        await client.chat_loop()
       8044	    finally:
       8045	        await client.cleanup()
       8046	
       8047	if __name__ == "__main__":
       8048	    import sys
       8049	    asyncio.run(main())
       8050	```
       8051	
       8052	Assembling all of the above code into mcp-client.py, you get a client that behaves as follows (some outputs truncated for brevity):
       8053	
       8054	```bash
       8055	% python mcp-client.py
       8056	
       8057	Secure MCP Filesystem Server running on stdio
       8058	Allowed directories: [ '/Applications' ]
       8059	
       8060	Connected to server with tools: ['read_file', 'read_multiple_files', 'write_file'...]
       8061	
       8062	MCP Client Started!
       8063	Type your queries or 'quit' to exit.
       8064	
       8065	Query: Do I have microsoft office installed?
       8066	
       8067	Result:
       8068	[Calling tool list_allowed_directories with args {}]
       8069	I can check if Microsoft Office is installed in the Applications folder:
       8070	
       8071	Query: continue
       8072	
       8073	Result:
       8074	[Calling tool search_files with args {'path': '/Applications', 'pattern': 'Microsoft'}]
       8075	Now let me check specifically for Microsoft Office applications:
       8076	
       8077	Query: continue
       8078	
       8079	Result:
       8080	I can see from the search results that Microsoft Office is indeed installed on your system.
       8081	The search found the following main Microsoft Office applications:
       8082	
       8083	1. Microsoft Excel - /Applications/Microsoft Excel.app
       8084	2. Microsoft PowerPoint - /Applications/Microsoft PowerPoint.app
       8085	3. Microsoft Word - /Applications/Microsoft Word.app
       8086	4. OneDrive - /Applications/OneDrive.app (which includes Microsoft SharePoint integration)
       8087	```
       8088	
       8089	
       8090	# Provider Integration
       8091	
       8092	> Learn how to integrate your AI models with OpenRouter. Complete guide for providers to make their models available through OpenRouter's unified API.
       8093	
       8094	## For Providers
       8095	
       8096	If you'd like to be a model provider and sell inference on OpenRouter, [fill out our form](https://openrouter.notion.site/15a2fd57c4dc8067bc61ecd5263b31fd) to get started.
       8097	
       8098	To be eligible to provide inference on OpenRouter you must have the following:
       8099	
       8100	### 1. List Models Endpoint
       8101	
       8102	You must implement an endpoint that returns all models that should be served by OpenRouter. At this endpoint, please return a list of all available models on your platform. Below is an example of the response format:
       8103	
       8104	```json
       8105	{
       8106	  "data": [
       8107	    {
       8108	      "id": "anthropic/claude-2.0",
       8109	      "name": "Anthropic: Claude v2.0",
       8110	      "created": 1690502400,
       8111	      "description": "Anthropic's flagship model...", // Optional
       8112	      "context_length": 100000, // Required
       8113	      "max_completion_tokens": 4096, // Optional
       8114	      "quantization": "fp8", // Required
       8115	      "pricing": {
       8116	        "prompt": "0.000008", // pricing per 1 token
       8117	        "completion": "0.000024", // pricing per 1 token
       8118	        "image": "0", // pricing per 1 image
       8119	        "request": "0" // pricing per 1 request
       8120	      }
       8121	    }
       8122	  ]
       8123	}
       8124	```
       8125	
       8126	NOTE: `pricing` fields are in string format to avoid floating point precision issues, and must be in USD.
       8127	
       8128	Valid quantization values are:
       8129	`int4`, `int8`, `fp4`, `fp6`, `fp8`, `fp16`, `bf16`, `fp32`
       8130	
       8131	### 2. Auto Top Up or Invoicing
       8132	
       8133	For OpenRouter to use the provider we must be able to pay for inference automatically. This can be done via auto top up or invoicing.
       8134	
       8135	
       8136	# Reasoning Tokens
       8137	
       8138	> Learn how to use reasoning tokens to enhance AI model outputs. Implement step-by-step reasoning traces for better decision making and transparency.
       8139	
       8140	For models that support it, the OpenRouter API can return **Reasoning Tokens**, also known as thinking tokens. OpenRouter normalizes the different ways of customizing the amount of reasoning tokens that the model will use, providing a unified interface across different providers.
       8141	
       8142	Reasoning tokens provide a transparent look into the reasoning steps taken by a model. Reasoning tokens are considered output tokens and charged accordingly.
       8143	
       8144	Reasoning tokens are included in the response by default if the model decides to output them. Reasoning tokens will appear in the `reasoning` field of each message, unless you decide to exclude them.
       8145	
       8146	<Note title="Some reasoning models do not return their reasoning tokens">
       8147	  While most models and providers make reasoning tokens available in the
       8148	  response, some (like the OpenAI o-series and Gemini Flash Thinking) do not.
       8149	</Note>
       8150	
       8151	## Controlling Reasoning Tokens
       8152	
       8153	You can control reasoning tokens in your requests using the `reasoning` parameter:
       8154	
       8155	```json
       8156	{
       8157	  "model": "your-model",
       8158	  "messages": [],
       8159	  "reasoning": {
       8160	    // One of the following (not both):
       8161	    "effort": "high", // Can be "high", "medium", or "low" (OpenAI-style)
       8162	    "max_tokens": 2000, // Specific token limit (Anthropic-style)
       8163	
       8164	    // Optional: Default is false. All models support this.
       8165	    "exclude": false // Set to true to exclude reasoning tokens from response
       8166	  }
       8167	}
       8168	```
       8169	
       8170	The `reasoning` config object consolidates settings for controlling reasoning strength across different models. See the Note for each option below to see which models are supported and how other models will behave.
       8171	
       8172	### Max Tokens for Reasoning
       8173	
       8174	<Note title="Supported models">
       8175	  Currently supported by Anthropic and Gemini thinking models
       8176	</Note>
       8177	
       8178	For models that support reasoning token allocation, you can control it like this:
       8179	
       8180	* `"max_tokens": 2000` - Directly specifies the maximum number of tokens to use for reasoning
       8181	
       8182	For models that only support `reasoning.effort` (see below), the `max_tokens` value will be used to determine the effort level.
       8183	
       8184	### Reasoning Effort Level
       8185	
       8186	<Note title="Supported models">
       8187	  Currently supported by the OpenAI o-series
       8188	</Note>
       8189	
       8190	* `"effort": "high"` - Allocates a large portion of tokens for reasoning (approximately 80% of max\_tokens)
       8191	* `"effort": "medium"` - Allocates a moderate portion of tokens (approximately 50% of max\_tokens)
       8192	* `"effort": "low"` - Allocates a smaller portion of tokens (approximately 20% of max\_tokens)
       8193	
       8194	For models that only support `reasoning.max_tokens`, the effort level will be set based on the percentages above.
       8195	
       8196	### Excluding Reasoning Tokens
       8197	
       8198	If you want the model to use reasoning internally but not include it in the response:
       8199	
       8200	* `"exclude": true` - The model will still use reasoning, but it won't be returned in the response
       8201	
       8202	Reasoning tokens will appear in the `reasoning` field of each message.
       8203	
       8204	## Legacy Parameters
       8205	
       8206	For backward compatibility, OpenRouter still supports the following legacy parameters:
       8207	
       8208	* `include_reasoning: true` - Equivalent to `reasoning: {}`
       8209	* `include_reasoning: false` - Equivalent to `reasoning: { exclude: true }`
       8210	
       8211	However, we recommend using the new unified `reasoning` parameter for better control and future compatibility.
       8212	
       8213	## Examples
       8214	
       8215	### Basic Usage with Reasoning Tokens
       8216	
       8217	<Template
       8218	  data={{
       8219	  API_KEY_REF,
       8220	  MODEL: "openai/o3-mini"
       8221	}}
       8222	>
       8223	  <CodeGroup>
       8224	    ```python Python
       8225	    import requests
       8226	    import json
       8227	
       8228	    url = "https://openrouter.ai/api/v1/chat/completions"
       8229	    headers = {
       8230	        "Authorization": f"Bearer {{API_KEY_REF}}",
       8231	        "Content-Type": "application/json"
       8232	    }
       8233	    payload = {
       8234	        "model": "{{MODEL}}",
       8235	        "messages": [
       8236	            {"role": "user", "content": "How would you build the world's tallest skyscraper?"}
       8237	        ],
       8238	        "reasoning": {
       8239	            "effort": "high"  # Use high reasoning effort
       8240	        }
       8241	    }
       8242	
       8243	    response = requests.post(url, headers=headers, data=json.dumps(payload))
       8244	    print(response.json()['choices'][0]['message']['reasoning'])
       8245	    ```
       8246	
       8247	    ```typescript TypeScript
       8248	    import OpenAI from 'openai';
       8249	
       8250	    const openai = new OpenAI({
       8251	      baseURL: 'https://openrouter.ai/api/v1',
       8252	      apiKey: '{{API_KEY_REF}}',
       8253	    });
       8254	
       8255	    async function getResponseWithReasoning() {
       8256	      const response = await openai.chat.completions.create({
       8257	        model: '{{MODEL}}',
       8258	        messages: [
       8259	          {
       8260	            role: 'user',
       8261	            content: "How would you build the world's tallest skyscraper?",
       8262	          },
       8263	        ],
       8264	        reasoning: {
       8265	          effort: 'high', // Use high reasoning effort
       8266	        },
       8267	      });
       8268	
       8269	      console.log('REASONING:', response.choices[0].message.reasoning);
       8270	      console.log('CONTENT:', response.choices[0].message.content);
       8271	    }
       8272	
       8273	    getResponseWithReasoning();
       8274	    ```
       8275	  </CodeGroup>
       8276	</Template>
       8277	
       8278	### Using Max Tokens for Reasoning
       8279	
       8280	For models that support direct token allocation (like Anthropic models), you can specify the exact number of tokens to use for reasoning:
       8281	
       8282	<Template
       8283	  data={{
       8284	  API_KEY_REF,
       8285	  MODEL: "anthropic/claude-3.7-sonnet"
       8286	}}
       8287	>
       8288	  <CodeGroup>
       8289	    ```python Python
       8290	    import requests
       8291	    import json
       8292	
       8293	    url = "https://openrouter.ai/api/v1/chat/completions"
       8294	    headers = {
       8295	        "Authorization": f"Bearer {{API_KEY_REF}}",
       8296	        "Content-Type": "application/json"
       8297	    }
       8298	    payload = {
       8299	        "model": "{{MODEL}}",
       8300	        "messages": [
       8301	            {"role": "user", "content": "What's the most efficient algorithm for sorting a large dataset?"}
       8302	        ],
       8303	        "reasoning": {
       8304	            "max_tokens": 2000  # Allocate 2000 tokens (or approximate effort) for reasoning
       8305	        }
       8306	    }
       8307	
       8308	    response = requests.post(url, headers=headers, data=json.dumps(payload))
       8309	    print(response.json()['choices'][0]['message']['reasoning'])
       8310	    print(response.json()['choices'][0]['message']['content'])
       8311	    ```
       8312	
       8313	    ```typescript TypeScript
       8314	    import OpenAI from 'openai';
       8315	
       8316	    const openai = new OpenAI({
       8317	      baseURL: 'https://openrouter.ai/api/v1',
       8318	      apiKey: '{{API_KEY_REF}}',
       8319	    });
       8320	
       8321	    async function getResponseWithReasoning() {
       8322	      const response = await openai.chat.completions.create({
       8323	        model: '{{MODEL}}',
       8324	        messages: [
       8325	          {
       8326	            role: 'user',
       8327	            content: "How would you build the world's tallest skyscraper?",
       8328	          },
       8329	        ],
       8330	        reasoning: {
       8331	          max_tokens: 2000, // Allocate 2000 tokens (or approximate effort) for reasoning
       8332	        },
       8333	      });
       8334	
       8335	      console.log('REASONING:', response.choices[0].message.reasoning);
       8336	      console.log('CONTENT:', response.choices[0].message.content);
       8337	    }
       8338	
       8339	    getResponseWithReasoning();
       8340	    ```
       8341	  </CodeGroup>
       8342	</Template>
       8343	
       8344	### Excluding Reasoning Tokens from Response
       8345	
       8346	If you want the model to use reasoning internally but not include it in the response:
       8347	
       8348	<Template
       8349	  data={{
       8350	  API_KEY_REF,
       8351	  MODEL: "deepseek/deepseek-r1"
       8352	}}
       8353	>
       8354	  <CodeGroup>
       8355	    ```python Python
       8356	    import requests
       8357	    import json
       8358	
       8359	    url = "https://openrouter.ai/api/v1/chat/completions"
       8360	    headers = {
       8361	        "Authorization": f"Bearer {{API_KEY_REF}}",
       8362	        "Content-Type": "application/json"
       8363	    }
       8364	    payload = {
       8365	        "model": "{{MODEL}}",
       8366	        "messages": [
       8367	            {"role": "user", "content": "Explain quantum computing in simple terms."}
       8368	        ],
       8369	        "reasoning": {
       8370	            "effort": "high",
       8371	            "exclude": true  # Use reasoning but don't include it in the response
       8372	        }
       8373	    }
       8374	
       8375	    response = requests.post(url, headers=headers, data=json.dumps(payload))
       8376	    # No reasoning field in the response
       8377	    print(response.json()['choices'][0]['message']['content'])
       8378	    ```
       8379	
       8380	    ```typescript TypeScript
       8381	    import OpenAI from 'openai';
       8382	
       8383	    const openai = new OpenAI({
       8384	      baseURL: 'https://openrouter.ai/api/v1',
       8385	      apiKey: '{{API_KEY_REF}}',
       8386	    });
       8387	
       8388	    async function getResponseWithReasoning() {
       8389	      const response = await openai.chat.completions.create({
       8390	        model: '{{MODEL}}',
       8391	        messages: [
       8392	          {
       8393	            role: 'user',
       8394	            content: "How would you build the world's tallest skyscraper?",
       8395	          },
       8396	        ],
       8397	        reasoning: {
       8398	          effort: 'high',
       8399	          exclude: true, // Use reasoning but don't include it in the response
       8400	        },
       8401	      });
       8402	
       8403	      console.log('REASONING:', response.choices[0].message.reasoning);
       8404	      console.log('CONTENT:', response.choices[0].message.content);
       8405	    }
       8406	
       8407	    getResponseWithReasoning();
       8408	    ```
       8409	  </CodeGroup>
       8410	</Template>
       8411	
       8412	### Advanced Usage: Reasoning Chain-of-Thought
       8413	
       8414	This example shows how to use reasoning tokens in a more complex workflow. It injects one model's reasoning into another model to improve its response quality:
       8415	
       8416	<Template
       8417	  data={{
       8418	  API_KEY_REF,
       8419	}}
       8420	>
       8421	  <CodeGroup>
       8422	    ```python Python
       8423	    import requests
       8424	    import json
       8425	
       8426	    question = "Which is bigger: 9.11 or 9.9?"
       8427	
       8428	    url = "https://openrouter.ai/api/v1/chat/completions"
       8429	    headers = {
       8430	        "Authorization": f"Bearer {{API_KEY_REF}}",
       8431	        "Content-Type": "application/json"
       8432	    }
       8433	
       8434	    def do_req(model, content, reasoning_config=None):
       8435	        payload = {
       8436	            "model": model,
       8437	            "messages": [
       8438	                {"role": "user", "content": content}
       8439	            ],
       8440	            "stop": "</think>"
       8441	        }
       8442	
       8443	        return requests.post(url, headers=headers, data=json.dumps(payload))
       8444	
       8445	    # Get reasoning from a capable model
       8446	    content = f"{question} Please think this through, but don't output an answer"
       8447	    reasoning_response = do_req("deepseek/deepseek-r1", content)
       8448	    reasoning = reasoning_response.json()['choices'][0]['message']['reasoning']
       8449	
       8450	    # Let's test! Here's the naive response:
       8451	    simple_response = do_req("openai/gpt-4o-mini", question)
       8452	    print(simple_response.json()['choices'][0]['message']['content'])
       8453	
       8454	    # Here's the response with the reasoning token injected:
       8455	    content = f"{question}. Here is some context to help you: {reasoning}"
       8456	    smart_response = do_req("openai/gpt-4o-mini", content)
       8457	    print(smart_response.json()['choices'][0]['message']['content'])
       8458	    ```
       8459	
       8460	    ```typescript TypeScript
       8461	    import OpenAI from 'openai';
       8462	
       8463	    const openai = new OpenAI({
       8464	      baseURL: 'https://openrouter.ai/api/v1',
       8465	      apiKey,
       8466	    });
       8467	
       8468	    async function doReq(model, content, reasoningConfig) {
       8469	      const payload = {
       8470	        model,
       8471	        messages: [{ role: 'user', content }],
       8472	        stop: '</think>',
       8473	        ...reasoningConfig,
       8474	      };
       8475	
       8476	      return openai.chat.completions.create(payload);
       8477	    }
       8478	
       8479	    async function getResponseWithReasoning() {
       8480	      const question = 'Which is bigger: 9.11 or 9.9?';
       8481	      const reasoningResponse = await doReq(
       8482	        'deepseek/deepseek-r1',
       8483	        `${question} Please think this through, but don't output an answer`,
       8484	      );
       8485	      const reasoning = reasoningResponse.choices[0].message.reasoning;
       8486	
       8487	      // Let's test! Here's the naive response:
       8488	      const simpleResponse = await doReq('openai/gpt-4o-mini', question);
       8489	      console.log(simpleResponse.choices[0].message.content);
       8490	
       8491	      // Here's the response with the reasoning token injected:
       8492	      const content = `${question}. Here is some context to help you: ${reasoning}`;
       8493	      const smartResponse = await doReq('openai/gpt-4o-mini', content);
       8494	      console.log(smartResponse.choices[0].message.content);
       8495	    }
       8496	
       8497	    getResponseWithReasoning();
       8498	    ```
       8499	  </CodeGroup>
       8500	</Template>
       8501	
       8502	## Provider-Specific Reasoning Implementation
       8503	
       8504	### Anthropic Models with Reasoning Tokens
       8505	
       8506	The latest Claude models, such as [anthropic/claude-3.7-sonnet](https://openrouter.ai/anthropic/claude-3.7-sonnet), support working with and returning reasoning tokens.
       8507	
       8508	You can enable reasoning on Anthropic models in two ways:
       8509	
       8510	1. Using the `:thinking` variant suffix (e.g., `anthropic/claude-3.7-sonnet:thinking`). The thinking variant defaults to high effort.
       8511	2. Using the unified `reasoning` parameter with either `effort` or `max_tokens`
       8512	
       8513	#### Reasoning Max Tokens for Anthropic Models
       8514	
       8515	When using Anthropic models with reasoning:
       8516	
       8517	* When using the `reasoning.max_tokens` parameter, that value is used directly with a minimum of 1024 tokens.
       8518	* When using the `:thinking` variant suffix or the `reasoning.effort` parameter, the budget\_tokens are calculated based on the `max_tokens` value.
       8519	
       8520	The reasoning token allocation is capped at 32,000 tokens maximum and 1024 tokens minimum. The formula for calculating the budget\_tokens is: `budget_tokens = max(min(max_tokens * {effort_ratio}, 32000), 1024)`
       8521	
       8522	effort\_ratio is 0.8 for high effort, 0.5 for medium effort, and 0.2 for low effort.
       8523	
       8524	**Important**: `max_tokens` must be strictly higher than the reasoning budget to ensure there are tokens available for the final response after thinking.
       8525	
       8526	<Note title="Token Usage and Billing">
       8527	  Please note that reasoning tokens are counted as output tokens for billing
       8528	  purposes. Using reasoning tokens will increase your token usage but can
       8529	  significantly improve the quality of model responses.
       8530	</Note>
       8531	
       8532	### Examples with Anthropic Models
       8533	
       8534	#### Example 1: Streaming mode with reasoning tokens
       8535	
       8536	<Template
       8537	  data={{
       8538	  API_KEY_REF,
       8539	  MODEL: "anthropic/claude-3.7-sonnet"
       8540	}}
       8541	>
       8542	  <CodeGroup>
       8543	    ```python Python
       8544	    from openai import OpenAI
       8545	
       8546	    client = OpenAI(
       8547	        base_url="https://openrouter.ai/api/v1",
       8548	        api_key="{{API_KEY_REF}}",
       8549	    )
       8550	
       8551	    def chat_completion_with_reasoning(messages):
       8552	        response = client.chat.completions.create(
       8553	            model="{{MODEL}}",
       8554	            messages=messages,
       8555	            max_tokens=10000,
       8556	            reasoning={
       8557	                "max_tokens": 8000  # Directly specify reasoning token budget
       8558	            },
       8559	            stream=True
       8560	        )
       8561	        return response
       8562	
       8563	    for chunk in chat_completion_with_reasoning([
       8564	        {"role": "user", "content": "What's bigger, 9.9 or 9.11?"}
       8565	    ]):
       8566	        if hasattr(chunk.choices[0].delta, 'reasoning') and chunk.choices[0].delta.reasoning:
       8567	            print(f"REASONING: {chunk.choices[0].delta.reasoning}")
       8568	        elif chunk.choices[0].delta.content:
       8569	            print(f"CONTENT: {chunk.choices[0].delta.content}")
       8570	    ```
       8571	
       8572	    ```typescript TypeScript
       8573	    import OpenAI from 'openai';
       8574	
       8575	    const openai = new OpenAI({
       8576	      baseURL: 'https://openrouter.ai/api/v1',
       8577	      apiKey,
       8578	    });
       8579	
       8580	    async function chatCompletionWithReasoning(messages) {
       8581	      const response = await openai.chat.completions.create({
       8582	        model: '{{MODEL}}',
       8583	        messages,
       8584	        maxTokens: 10000,
       8585	        reasoning: {
       8586	          maxTokens: 8000, // Directly specify reasoning token budget
       8587	        },
       8588	        stream: true,
       8589	      });
       8590	
       8591	      return response;
       8592	    }
       8593	
       8594	    (async () => {
       8595	      for await (const chunk of chatCompletionWithReasoning([
       8596	        { role: 'user', content: "What's bigger, 9.9 or 9.11?" },
       8597	      ])) {
       8598	        if (chunk.choices[0].delta.reasoning) {
       8599	          console.log(`REASONING: ${chunk.choices[0].delta.reasoning}`);
       8600	        } else if (chunk.choices[0].delta.content) {
       8601	          console.log(`CONTENT: ${chunk.choices[0].delta.content}`);
       8602	        }
       8603	      }
       8604	    })();
       8605	    ```
       8606	  </CodeGroup>
       8607	</Template>
       8608	
       8609	
       8610	# Usage Accounting
       8611	
       8612	> Learn how to track AI model usage including prompt tokens, completion tokens, and cached tokens without additional API calls.
       8613	
       8614	The OpenRouter API provides built-in **Usage Accounting** that allows you to track AI model usage without making additional API calls. This feature provides detailed information about token counts, costs, and caching status directly in your API responses.
       8615	
       8616	## Usage Information
       8617	
       8618	When enabled, the API will return detailed usage information including:
       8619	
       8620	1. Prompt and completion token counts using the model's native tokenizer
       8621	2. Cost in credits
       8622	3. Reasoning token counts (if applicable)
       8623	4. Cached token counts (if available)
       8624	
       8625	This information is included in the last SSE message for streaming responses, or in the complete response for non-streaming requests.
       8626	
       8627	## Enabling Usage Accounting
       8628	
       8629	You can enable usage accounting in your requests by including the `usage` parameter:
       8630	
       8631	```json
       8632	{
       8633	  "model": "your-model",
       8634	  "messages": [],
       8635	  "usage": {
       8636	    "include": true
       8637	  }
       8638	}
       8639	```
       8640	
       8641	## Response Format
       8642	
       8643	When usage accounting is enabled, the response will include a `usage` object with detailed token information:
       8644	
       8645	```json
       8646	{
       8647	  "object": "chat.completion.chunk",
       8648	  "usage": {
       8649	    "completion_tokens": 2,
       8650	    "completion_tokens_details": {
       8651	      "reasoning_tokens": 0
       8652	    },
       8653	    "cost": 197,
       8654	    "prompt_tokens": 194,
       8655	    "prompt_tokens_details": {
       8656	      "cached_tokens": 0
       8657	    },
       8658	    "total_tokens": 196
       8659	  }
       8660	}
       8661	```
       8662	
       8663	<Note title="Performance Impact">
       8664	  Enabling usage accounting will add a few hundred milliseconds to the last
       8665	  response as the API calculates token counts and costs. This only affects the
       8666	  final message and does not impact overall streaming performance.
       8667	</Note>
       8668	
       8669	## Benefits
       8670	
       8671	1. **Efficiency**: Get usage information without making separate API calls
       8672	2. **Accuracy**: Token counts are calculated using the model's native tokenizer
       8673	3. **Transparency**: Track costs and cached token usage in real-time
       8674	4. **Detailed Breakdown**: Separate counts for prompt, completion, reasoning, and cached tokens
       8675	
       8676	## Best Practices
       8677	
       8678	1. Enable usage tracking when you need to monitor token consumption or costs
       8679	2. Account for the slight delay in the final response when usage accounting is enabled
       8680	3. Consider implementing usage tracking in development to optimize token usage before production
       8681	4. Use the cached token information to optimize your application's performance
       8682	
       8683	## Alternative: Getting Usage via Generation ID
       8684	
       8685	You can also retrieve usage information asynchronously by using the generation ID returned from your API calls. This is particularly useful when you want to fetch usage statistics after the completion has finished or when you need to audit historical usage.
       8686	
       8687	To use this method:
       8688	
       8689	1. Make your chat completion request as normal
       8690	2. Note the `id` field in the response
       8691	3. Use that ID to fetch usage information via the `/generation` endpoint
       8692	
       8693	For more details on this approach, see the [Get a Generation](/docs/api-reference/get-a-generation) documentation.
       8694	
       8695	## Examples
       8696	
       8697	### Basic Usage with Token Tracking
       8698	
       8699	<Template
       8700	  data={{
       8701	  API_KEY_REF,
       8702	  MODEL: "anthropic/claude-3-opus"
       8703	}}
       8704	>
       8705	  <CodeGroup>
       8706	    ```python Python
       8707	    import requests
       8708	    import json
       8709	
       8710	    url = "https://openrouter.ai/api/v1/chat/completions"
       8711	    headers = {
       8712	        "Authorization": f"Bearer {{API_KEY_REF}}",
       8713	        "Content-Type": "application/json"
       8714	    }
       8715	    payload = {
       8716	        "model": "{{MODEL}}",
       8717	        "messages": [
       8718	            {"role": "user", "content": "What is the capital of France?"}
       8719	        ],
       8720	        "usage": {
       8721	            "include": True
       8722	        }
       8723	    }
       8724	
       8725	    response = requests.post(url, headers=headers, data=json.dumps(payload))
       8726	    print("Response:", response.json()['choices'][0]['message']['content'])
       8727	    print("Usage Stats:", response.json()['usage'])
       8728	    ```
       8729	
       8730	    ```typescript TypeScript
       8731	    import OpenAI from 'openai';
       8732	
       8733	    const openai = new OpenAI({
       8734	      baseURL: 'https://openrouter.ai/api/v1',
       8735	      apiKey: '{{API_KEY_REF}}',
       8736	    });
       8737	
       8738	    async function getResponseWithUsage() {
       8739	      const response = await openai.chat.completions.create({
       8740	        model: '{{MODEL}}',
       8741	        messages: [
       8742	          {
       8743	            role: 'user',
       8744	            content: 'What is the capital of France?',
       8745	          },
       8746	        ],
       8747	        usage: {
       8748	          include: true,
       8749	        },
       8750	      });
       8751	
       8752	      console.log('Response:', response.choices[0].message.content);
       8753	      console.log('Usage Stats:', response.usage);
       8754	    }
       8755	
       8756	    getResponseWithUsage();
       8757	    ```
       8758	  </CodeGroup>
       8759	</Template>
       8760	
       8761	### Streaming with Usage Information
       8762	
       8763	This example shows how to handle usage information in streaming mode:
       8764	
       8765	<Template
       8766	  data={{
       8767	  API_KEY_REF,
       8768	  MODEL: "anthropic/claude-3-opus"
       8769	}}
       8770	>
       8771	  <CodeGroup>
       8772	    ```python Python
       8773	    from openai import OpenAI
       8774	
       8775	    client = OpenAI(
       8776	        base_url="https://openrouter.ai/api/v1",
       8777	        api_key="{{API_KEY_REF}}",
       8778	    )
       8779	
       8780	    def chat_completion_with_usage(messages):
       8781	        response = client.chat.completions.create(
       8782	            model="{{MODEL}}",
       8783	            messages=messages,
       8784	            usage={
       8785	              "include": True
       8786	            },
       8787	            stream=True
       8788	        )
       8789	        return response
       8790	
       8791	    for chunk in chat_completion_with_usage([
       8792	        {"role": "user", "content": "Write a haiku about Paris."}
       8793	    ]):
       8794	        if hasattr(chunk, 'usage'):
       8795	            print(f"\nUsage Statistics:")
       8796	            print(f"Total Tokens: {chunk.usage.total_tokens}")
       8797	            print(f"Prompt Tokens: {chunk.usage.prompt_tokens}")
       8798	            print(f"Completion Tokens: {chunk.usage.completion_tokens}")
       8799	            print(f"Cost: {chunk.usage.cost} credits")
       8800	        elif chunk.choices[0].delta.content:
       8801	            print(chunk.choices[0].delta.content, end="")
       8802	    ```
       8803	
       8804	    ```typescript TypeScript
       8805	    import OpenAI from 'openai';
       8806	
       8807	    const openai = new OpenAI({
       8808	      baseURL: 'https://openrouter.ai/api/v1',
       8809	      apiKey: '{{API_KEY_REF}}',
       8810	    });
       8811	
       8812	    async function chatCompletionWithUsage(messages) {
       8813	      const response = await openai.chat.completions.create({
       8814	        model: '{{MODEL}}',
       8815	        messages,
       8816	        usage: {
       8817	          include: true,
       8818	        },
       8819	        stream: true,
       8820	      });
       8821	
       8822	      return response;
       8823	    }
       8824	
       8825	    (async () => {
       8826	      for await (const chunk of chatCompletionWithUsage([
       8827	        { role: 'user', content: 'Write a haiku about Paris.' },
       8828	      ])) {
       8829	        if (chunk.usage) {
       8830	          console.log('\nUsage Statistics:');
       8831	          console.log(`Total Tokens: ${chunk.usage.total_tokens}`);
       8832	          console.log(`Prompt Tokens: ${chunk.usage.prompt_tokens}`);
       8833	          console.log(`Completion Tokens: ${chunk.usage.completion_tokens}`);
       8834	          console.log(`Cost: ${chunk.usage.cost} credits`);
       8835	        } else if (chunk.choices[0].delta.content) {
       8836	          process.stdout.write(chunk.choices[0].delta.content);
       8837	        }
       8838	      }
       8839	    })();
       8840	    ```
       8841	  </CodeGroup>
       8842	</Template>
       8843	
       8844	
       8845	# Frameworks
       8846	
       8847	> Integrate OpenRouter using popular frameworks and SDKs. Complete guides for OpenAI SDK, LangChain, PydanticAI, and Vercel AI SDK integration.
       8848	
       8849	You can find a few examples of using OpenRouter with other frameworks in [this Github repository](https://github.com/OpenRouterTeam/openrouter-examples). Here are some examples:
       8850	
       8851	## Using the OpenAI SDK
       8852	
       8853	* Using `pip install openai`: [github](https://github.com/OpenRouterTeam/openrouter-examples-python/blob/main/src/openai_test.py).
       8854	* Using `npm i openai`: [github](https://github.com/OpenRouterTeam/openrouter-examples/blob/main/examples/openai/index.ts).
       8855	  <Tip>
       8856	    You can also use
       8857	    [Grit](https://app.grit.io/studio?key=RKC0n7ikOiTGTNVkI8uRS) to
       8858	    automatically migrate your code. Simply run `npx @getgrit/launcher
       8859	      openrouter`.
       8860	  </Tip>
       8861	
       8862	<CodeGroup>
       8863	  ```typescript title="TypeScript"
       8864	  import OpenAI from "openai"
       8865	
       8866	  const openai = new OpenAI({
       8867	    baseURL: "https://openrouter.ai/api/v1",
       8868	    apiKey: "${API_KEY_REF}",
       8869	    defaultHeaders: {
       8870	      ${getHeaderLines().join('\n        ')}
       8871	    },
       8872	  })
       8873	
       8874	  async function main() {
       8875	    const completion = await openai.chat.completions.create({
       8876	      model: "${Model.GPT_4_Omni}",
       8877	      messages: [
       8878	        { role: "user", content: "Say this is a test" }
       8879	      ],
       8880	    })
       8881	
       8882	    console.log(completion.choices[0].message)
       8883	  }
       8884	  main();
       8885	  ```
       8886	
       8887	  ```python title="Python"
       8888	  from openai import OpenAI
       8889	  from os import getenv
       8890	
       8891	  # gets API Key from environment variable OPENAI_API_KEY
       8892	  client = OpenAI(
       8893	    base_url="https://openrouter.ai/api/v1",
       8894	    api_key=getenv("OPENROUTER_API_KEY"),
       8895	  )
       8896	
       8897	  completion = client.chat.completions.create(
       8898	    model="${Model.GPT_4_Omni}",
       8899	    extra_headers={
       8900	      "HTTP-Referer": "<YOUR_SITE_URL>", # Optional. Site URL for rankings on openrouter.ai.
       8901	      "X-Title": "<YOUR_SITE_NAME>", # Optional. Site title for rankings on openrouter.ai.
       8902	    },
       8903	    # pass extra_body to access OpenRouter-only arguments.
       8904	    # extra_body={
       8905	      # "models": [
       8906	      #   "${Model.GPT_4_Omni}",
       8907	      #   "${Model.Mixtral_8x_22B_Instruct}"
       8908	      # ]
       8909	    # },
       8910	    messages=[
       8911	      {
       8912	        "role": "user",
       8913	        "content": "Say this is a test",
       8914	      },
       8915	    ],
       8916	  )
       8917	  print(completion.choices[0].message.content)
       8918	  ```
       8919	</CodeGroup>
       8920	
       8921	## Using LangChain
       8922	
       8923	* Using [LangChain for Python](https://github.com/langchain-ai/langchain): [github](https://github.com/alexanderatallah/openrouter-streamlit/blob/main/pages/2_Langchain_Quickstart.py)
       8924	* Using [LangChain.js](https://github.com/langchain-ai/langchainjs): [github](https://github.com/OpenRouterTeam/openrouter-examples/blob/main/examples/langchain/index.ts)
       8925	* Using [Streamlit](https://streamlit.io/): [github](https://github.com/alexanderatallah/openrouter-streamlit)
       8926	
       8927	<CodeGroup>
       8928	  ```typescript title="TypeScript"
       8929	  const chat = new ChatOpenAI(
       8930	    {
       8931	      modelName: '<model_name>',
       8932	      temperature: 0.8,
       8933	      streaming: true,
       8934	      openAIApiKey: '${API_KEY_REF}',
       8935	    },
       8936	    {
       8937	      basePath: 'https://openrouter.ai/api/v1',
       8938	      baseOptions: {
       8939	        headers: {
       8940	          'HTTP-Referer': '<YOUR_SITE_URL>', // Optional. Site URL for rankings on openrouter.ai.
       8941	          'X-Title': '<YOUR_SITE_NAME>', // Optional. Site title for rankings on openrouter.ai.
       8942	        },
       8943	      },
       8944	    },
       8945	  );
       8946	  ```
       8947	
       8948	  ```python title="Python"
       8949	  from langchain.chat_models import ChatOpenAI
       8950	  from langchain.prompts import PromptTemplate
       8951	  from langchain.chains import LLMChain
       8952	  from os import getenv
       8953	  from dotenv import load_dotenv
       8954	
       8955	  load_dotenv()
       8956	
       8957	  template = """Question: {question}
       8958	  Answer: Let's think step by step."""
       8959	
       8960	  prompt = PromptTemplate(template=template, input_variables=["question"])
       8961	
       8962	  llm = ChatOpenAI(
       8963	    openai_api_key=getenv("OPENROUTER_API_KEY"),
       8964	    openai_api_base=getenv("OPENROUTER_BASE_URL"),
       8965	    model_name="<model_name>",
       8966	    model_kwargs={
       8967	      "headers": {
       8968	        "HTTP-Referer": getenv("YOUR_SITE_URL"),
       8969	        "X-Title": getenv("YOUR_SITE_NAME"),
       8970	      }
       8971	    },
       8972	  )
       8973	
       8974	  llm_chain = LLMChain(prompt=prompt, llm=llm)
       8975	
       8976	  question = "What NFL team won the Super Bowl in the year Justin Beiber was born?"
       8977	
       8978	  print(llm_chain.run(question))
       8979	  ```
       8980	</CodeGroup>
       8981	
       8982	***
       8983	
       8984	## Using PydanticAI
       8985	
       8986	[PydanticAI](https://github.com/pydantic/pydantic-ai) provides a high-level interface for working with various LLM providers, including OpenRouter.
       8987	
       8988	### Installation
       8989	
       8990	```bash
       8991	pip install 'pydantic-ai-slim[openai]'
       8992	```
       8993	
       8994	### Configuration
       8995	
       8996	You can use OpenRouter with PydanticAI through its OpenAI-compatible interface:
       8997	
       8998	```python
       8999	from pydantic_ai import Agent
       9000	from pydantic_ai.models.openai import OpenAIModel
       9001	
       9002	model = OpenAIModel(
       9003	    "anthropic/claude-3.5-sonnet",  # or any other OpenRouter model
       9004	    base_url="https://openrouter.ai/api/v1",
       9005	    api_key="sk-or-...",
       9006	)
       9007	
       9008	agent = Agent(model)
       9009	result = await agent.run("What is the meaning of life?")
       9010	print(result)
       9011	```
       9012	
       9013	For more details about using PydanticAI with OpenRouter, see the [PydanticAI documentation](https://ai.pydantic.dev/models/#api_key-argument).
       9014	
       9015	***
       9016	
       9017	## Vercel AI SDK
       9018	
       9019	You can use the [Vercel AI SDK](https://www.npmjs.com/package/ai) to integrate OpenRouter with your Next.js app. To get started, install [@openrouter/ai-sdk-provider](https://github.com/OpenRouterTeam/ai-sdk-provider):
       9020	
       9021	```bash
       9022	npm install @openrouter/ai-sdk-provider
       9023	```
       9024	
       9025	And then you can use [streamText()](https://sdk.vercel.ai/docs/reference/ai-sdk-core/stream-text) API to stream text from OpenRouter.
       9026	
       9027	<CodeGroup>
       9028	  ```typescript title="TypeScript"
       9029	  import { createOpenRouter } from '@openrouter/ai-sdk-provider';
       9030	  import { streamText } from 'ai';
       9031	  import { z } from 'zod';
       9032	
       9033	  export const getLasagnaRecipe = async (modelName: string) => {
       9034	    const openrouter = createOpenRouter({
       9035	      apiKey: '${API_KEY_REF}',
       9036	    });
       9037	
       9038	    const response = streamText({
       9039	      model: openrouter(modelName),
       9040	      prompt: 'Write a vegetarian lasagna recipe for 4 people.',
       9041	    });
       9042	
       9043	    await response.consumeStream();
       9044	    return response.text;
       9045	  };
       9046	
       9047	  export const getWeather = async (modelName: string) => {
       9048	    const openrouter = createOpenRouter({
       9049	      apiKey: '${API_KEY_REF}',
       9050	    });
       9051	
       9052	    const response = streamText({
       9053	      model: openrouter(modelName),
       9054	      prompt: 'What is the weather in San Francisco, CA in Fahrenheit?',
       9055	      tools: {
       9056	        getCurrentWeather: {
       9057	          description: 'Get the current weather in a given location',
       9058	          parameters: z.object({
       9059	            location: z
       9060	              .string()
       9061	              .describe('The city and state, e.g. San Francisco, CA'),
       9062	            unit: z.enum(['celsius', 'fahrenheit']).optional(),
       9063	          }),
       9064	          execute: async ({ location, unit = 'celsius' }) => {
       9065	            // Mock response for the weather
       9066	            const weatherData = {
       9067	              'Boston, MA': {
       9068	                celsius: '15°C',
       9069	                fahrenheit: '59°F',
       9070	              },
       9071	              'San Francisco, CA': {
       9072	                celsius: '18°C',
       9073	                fahrenheit: '64°F',
       9074	              },
       9075	            };
       9076	
       9077	            const weather = weatherData[location];
       9078	            if (!weather) {
       9079	              return `Weather data for ${location} is not available.`;
       9080	            }
       9081	
       9082	            return `The current weather in ${location} is ${weather[unit]}.`;
       9083	          },
       9084	        },
       9085	      },
       9086	    });
       9087	
       9088	    await response.consumeStream();
       9089	    return response.text;
       9090	  };
       9091	  ```
       9092	</CodeGroup>


==============================================
FILE: ./package-lock.json
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./package.json
==============================================

     [Binary file, content omitted]


==============================================
FILE: ./pnpm-workspace.yaml
==============================================

          1	packages:
          2	  - 'frontend'
          3	  - 'backend'


==============================================
FILE: ./readthesedocs/TO-DO-1.md
==============================================

          1	Implementing Agent-to-Agent Negotiation System
          2	Goal: Build the core backend systems enabling autonomous agents to negotiate based on user preferences.
          3	
          4	Relevant Files:
          5	
          6	backend/prisma/schema.prisma
          7	backend/src/routes/negotiation.ts
          8	backend/src/services/negotiation-service.ts
          9	backend/src/services/stance-generator.ts
         10	backend/src/services/prompt-templates/negotiation-prompts.ts
         11	backend/src/jobs/negotiation-worker.ts (New or existing job worker structure)
         12	frontend/src/components/NegotiationList.tsx
         13	frontend/src/components/NegotiationThread.tsx
         14	
         15	# Implementation Steps:
         16	
         17	## Database Migration for Reactions:
         18	- ✅ File: backend/prisma/schema.prisma
         19	- ✅ Action: NegotiationReaction model confirmed in schema with @@unique constraint and proper relations
         20	- ✅ Action: Migration 20250423175034_add_negotiation_reactions_and_dynamic_participation already implemented
         21	
         22	## Implement Negotiation API (negotiation.ts):
         23	- ✅ Action: All required routes are implemented in negotiation.ts:
         24	  - POST /api/negotiations - Create session
         25	  - GET /api/negotiations - List negotiations
         26	  - GET /api/negotiations/:id - Get session details
         27	  - POST /api/negotiations/:id/messages - Add message
         28	  - GET /api/negotiations/:id/messages - Get messages with reactions
         29	- ✅ Action: Reaction endpoints implemented:
         30	  - POST /api/negotiations/:id/messages/:messageId/reactions - Add reaction
         31	  - DELETE /api/negotiations/:id/messages/:messageId/reactions - Remove reaction
         32	- ✅ Action: Messages API includes reactions via Prisma's include option
         33	
         34	## Implement Stance Generation (stance-generator.ts):
         35	- ✅ Action: Created stance-generator.ts implementing:
         36	  - NegotiationStance interface with position, strength, flexibility, priorities, constraints, dealBreakers
         37	  - generateNegotiationStance function that extracts agent preferences, calls LLM, and returns structured stance
         38	  - explainStanceReasoning function that generates natural language explanation of stance
         39	
         40	## Implement Core Negotiation Logic (negotiation-service.ts):
         41	- ✅ Action: Defined NegotiationStage enum (PERSPECTIVE_PASS, OPTION_GENERATION, CONSENSUS_CHECK, etc.)
         42	- ✅ Action: Enhanced startNegotiation to create NegotiationSession without participants (dynamic participation)
         43	- ✅ Action: Comprehensive processNegotiationMessage implementation:
         44	  - Store incoming message
         45	  - Determine current stage
         46	  - Identify agents who should respond next
         47	  - Generate agent responses via LLM
         48	  - Check for consensus
         49	- ✅ Action: Implemented internal helper functions:
         50	  - determineNegotiationStage - Based on message count and status
         51	  - determineNextRespondents - Select which agents should respond
         52	  - generateAgentResponse - Call LLM to generate appropriate response based on stage
         53	- ✅ Action: Implemented detectConsensus:
         54	  - Check for explicit agreements (CONSENT:YES tags)
         55	  - Detect near-miss scenarios (70-74% agreement)
         56	  - Return consensus terms and summary
         57	- ✅ Action: Implemented finalizeNegotiation:
         58	  - Update negotiation status
         59	  - Create proposal from successful negotiation (when consensus reached)
         60	
         61	## Implement Reaction Handling (negotiation-service.ts):
         62	- ✅ Action: Created addReaction function:
         63	  - Check for existing reaction 
         64	  - Create new reaction if not exists
         65	  - Return reaction data
         66	- ✅ Action: Created removeReaction function:
         67	  - Delete reaction by messageId, agentId, reactionType
         68	  - Handle non-existent reaction gracefully
         69	
         70	## Enhance Frontend (NegotiationThread.tsx):
         71	- ✅ Action: Verified NegotiationThread.tsx correctly displays reactions
         72	- ✅ Action: Confirmed UI logic for adding/removing reactions implemented
         73	- ✅ Action: Reaction counts display and visual feedback verified
         74	
         75	## Test Coverage:
         76	- ✅ Action: Created backend/src/tests/negotiation-reaction.spec.ts with:
         77	  - Tests for adding reactions
         78	  - Tests for preventing duplicates
         79	  - Tests for different agents adding same reaction type
         80	  - Tests for agents adding different reaction types
         81	  - Tests for removing reactions
         82	
         83	# Key Implementation Highlights:
         84	
         85	1. **Dynamic Participation**
         86	   - Removed fixed participants list from negotiation sessions
         87	   - Any agent can join by posting (more inclusive system)
         88	   - UI supports showing all participants and reactions
         89	
         90	2. **Structured Negotiation Flow**
         91	   - Perspective Pass (understanding phase)
         92	   - Option Generation (proposal phase)
         93	   - Consensus Check (agreement phase)
         94	   - Automatic progression between stages based on message count
         95	
         96	3. **LLM-driven Agent Responses**
         97	   - Stage-specific prompts
         98	   - Agent stance based on user preferences
         99	   - Protocol tags for clear message intent (OPT-A, CONSENT:YES, etc.)
        100	
        101	4. **Consensus Mechanism**
        102	   - Explicit agreement detection via CONSENT tags
        103	   - Near-miss handling (70-74% agreement triggers Round 2)
        104	   - Auto-translation of consensus to formal proposals
        105	
        106	5. **Reaction System**
        107	   - Support, non-support, and emoji reactions
        108	   - Multiple agent attribution
        109	   - Visual feedback for user interaction
        110	
        111	# GitHub Push Instructions:
        112	
        113	After completing the implementation:
        114	
        115	```bash
        116	# Stage all changes
        117	git add .
        118	
        119	# Commit with descriptive message
        120	git commit -m "Implement Agent-to-Agent Negotiation System"
        121	
        122	# Push to remote repository
        123	git push origin main
        124	```
        125	
        126	# Implementation Status: COMPLETED ✅

==============================================
FILE: ./readthesedocs/TO-DO-2.md
==============================================

          1	# Implementing Proposal & Negotiation Integration
          2	Goal: Connect completed negotiations to the proposal system and allow user feedback on agent performance.
          3	
          4	## Completed Implementation Tasks:
          5	
          6	### Database Changes:
          7	- ✅ Created `NegotiationFeedback` model in schema.prisma for storing user feedback
          8	- ✅ Set up @@unique constraint to prevent duplicate feedback
          9	- ✅ Added proper relations to Agent and NegotiationSession
         10	- ✅ Created migration file (20250425102800_add_negotiation_feedback)
         11	
         12	### Negotiation-to-Proposal Service:
         13	- ✅ Created `negotiation-to-proposal.ts` service implementing:
         14	  - `createProposalFromNegotiation(negotiationId)` function:
         15	    - Fetches negotiation session with messages
         16	    - Verifies consensus was reached
         17	    - Extracts negotiation metadata
         18	    - Generates proposal title and description using LLM
         19	    - Creates a new formal proposal with appropriate fields
         20	
         21	### API Endpoints:
         22	- ✅ Added POST `/api/negotiations/:id/propose` to create proposals from negotiations
         23	- ✅ Added feedback endpoints:
         24	  - POST `/api/feedback/negotiation/:negotiationId` - Submit feedback
         25	  - GET `/api/feedback/negotiation/:negotiationId` - Get feedback for a negotiation
         26	  - GET `/api/feedback/agent/:agentId` - Get all feedback for an agent
         27	
         28	### Feedback System:
         29	- ✅ Created `feedback-service.ts` implementing:
         30	  - `processFeedback()` for storing and updating feedback
         31	  - `updateAgentFromFeedback()` to adjust agent alignment score based on feedback
         32	  - `getFeedback()` for retrieving feedback records
         33	
         34	### Frontend Components:
         35	- ✅ Created `NegotiationFeedback.tsx` component for rating agent performance:
         36	  - 1-5 star rating system for overall performance
         37	  - 1-5 star rating for representation accuracy
         38	  - Comment field for detailed feedback
         39	  - Handling for updating existing feedback
         40	- ✅ Created `NegotiationHistory.tsx` to display negotiation messages in read-only mode:
         41	  - Shows negotiation metadata (topic, status, participants)
         42	  - Displays all messages with agent names and timestamps
         43	  - Shows reactions on each message
         44	- ✅ Enhanced `ProposalDetail.tsx` to:
         45	  - Display negotiation summary for proposals from negotiations
         46	  - Integrate the feedback component
         47	  - Show negotiation history in read-only mode
         48	  - Add CSS styling for improved user experience
         49	
         50	### Server Configuration:
         51	- ✅ Updated `index.ts` to include new routes and middleware
         52	
         53	## Key Implementation Highlights:
         54	
         55	1. **Bidirectional Integration**
         56	   - Negotiations can be converted into formal proposals
         57	   - Proposals display their negotiation history
         58	   - Negotiations reference proposals they generate
         59	
         60	2. **Feedback Loop**
         61	   - Users can rate agent performance in negotiations
         62	   - Feedback directly impacts agent alignment scores
         63	   - Historical feedback trends are tracked in agent knowledge
         64	
         65	3. **Enhanced UI/UX**
         66	   - Clean, organized display of negotiation history
         67	   - Intuitive feedback interface with star ratings
         68	   - Clear visualization of negotiation status and summary
         69	
         70	4. **Data Flow**
         71	   - Frontend components → API endpoints → Service layer → Database
         72	   - LLM summarization for human-friendly proposal generation
         73	   - Structured data storage with proper relations


==============================================
FILE: ./readthesedocs/TO-DO-3.md
==============================================

          1	# Implementing User-Agent Communication Enhancements
          2	Goal: Integrate the dashboard chat panel fully, implement context awareness based on the active tab, improve agent memory through conversation summarization and knowledge extraction.
          3	
          4	## Relevant Files:
          5	
          6	- frontend/src/pages/DashboardPage.tsx
          7	- frontend/src/components/AgentChatPanel.tsx
          8	- frontend/src/context/DashboardContext.tsx
          9	- frontend/src/hooks/useChatContext.tsx
         10	- backend/src/services/chat-service.ts
         11	- backend/src/services/agent-service.ts
         12	- backend/src/services/prompt-templates/chat-prompts.ts
         13	
         14	## Implementation Steps:
         15	
         16	### ✅ Implement Context Sharing (DashboardContext / useChatContext):
         17	Files: DashboardContext.tsx, useChatContext.tsx, DashboardPage.tsx
         18	- Action: Define a clear structure within DashboardContext to hold the currentTab (string) and currentTabData (object relevant to the tab, e.g., { issues: Issue[] } or { recentActions: RecentAction[] }).
         19	- Action: Modify handleTabChange in DashboardPage.tsx to update both currentTab state and fetch/set the relevant currentTabData in the context.   
         20	- Action: Refine useChatContext to potentially provide more structured access to the context relevant for chat prompts (e.g., const { activeIssueTitle } = useChatContext();).
         21	
         22	**Implementation Notes:**
         23	- Context is passed through React's Context API, making it accessible to any component in the tree
         24	- The system handles multiple context types (positions, activity, proposals) with different data structures
         25	- Future extensions should follow the pattern of adding new context types and their associated data to the shared context
         26	
         27	### ✅ Enhance AgentChatPanel Context Consumption:
         28	File: AgentChatPanel.tsx
         29	- Action: Use the useDashboard hook to access currentTab and currentTabData.
         30	- Action: Modify the handleSendMessage logic (or pass context to ChatInterface -> onSendMessage) to include relevant context (currentTab, specific data like issueId if discussing an issue) in the API call to POST /api/chat/messages. The backend (processChatMessage) should use this context to tailor the LLM prompt.
         31	- Action: Implement the renderContextualHeader (or similar) to display dynamic information based on the chatContext (e.g., "Discussing Issue: [Title]").
         32	
         33	**Implementation Notes:**
         34	- The contextual header provides visual feedback about what context is active
         35	- Context data is serialized and deserialized when passed to/from the backend
         36	- Type safety is maintained by using appropriate type assertions on both ends
         37	- Future UI enhancements could include more interactive context-specific controls
         38	
         39	### ✅ Implement Conversation Summarization:
         40	File: backend/src/services/chat-service.ts
         41	- Action: Replace the placeholder summarizeConversation function. Implement logic that uses an LLM call with a dedicated summarization prompt to condense older messages when the context retrieved by getConversationContext exceeds a token threshold. The summary should then be prepended to the more recent messages passed to the main LLM call in agent-service.ts::processChatMessage.
         42	
         43	**Implementation Notes:**
         44	- Summarization uses a token-based threshold (default: 3000 tokens)
         45	- A simple heuristic of ~4 chars per token is used for estimation
         46	- When threshold is exceeded, older messages are summarized using an LLM
         47	- The summary is prepended as a special 'system' message for context continuity
         48	- The token threshold can be adjusted if needed for different LLM models
         49	- Future improvements could include more sophisticated token counting or differential summarization based on message importance
         50	
         51	### ✅ Implement User Knowledge Extraction & Storage:
         52	File: backend/src/services/agent-service.ts (processChatMessage)
         53	- Action: After receiving an LLM response in processChatMessage, make a secondary, non-blocking LLM call (or refine the main prompt) to specifically extract key facts, preferences, or user goals mentioned in the latest user message and agent response.
         54	- Action: Define a structured format for the Agent.userKnowledge JSON field (e.g., { key_topics: [], stated_preferences: [], goals: [] }).
         55	- Action: Implement logic to merge newly extracted knowledge into the existing Agent.userKnowledge JSON blob in the database asynchronously. Avoid overly frequent database updates; perhaps batch updates or update periodically.
         56	
         57	**Implementation Notes:**
         58	- Knowledge extraction occurs asynchronously to not impact chat responsiveness
         59	- The userKnowledge structure has been defined with the following fields:
         60	  - key_topics: Main subjects user discusses or cares about
         61	  - stated_preferences: Explicit preferences user mentioned
         62	  - goals: User's stated objectives or desired outcomes
         63	  - communication_style: User's evident communication preference
         64	  - relationships: People user mentions and their relations
         65	  - facts: Factual information about the user
         66	- The mergeUserKnowledge function prevents duplication and limits the amount of stored data
         67	- The extraction process uses the existing conversation context to inform the LLM
         68	- Had to use $executeRaw for User name updates due to schema type issues
         69	- Future enhancements could include adding more structured knowledge categories or implementing a more sophisticated knowledge graph
         70	
         71	### ✅ Refine Agent Personalization:
         72	Files: backend/src/services/agent-service.ts (processChatMessage), backend/src/services/prompt-templates/chat-prompts.ts
         73	- Action: Modify the USER_FACING_PERSONA_TEMPLATE to accept and utilize the userKnowledge JSON blob. Instruct the LLM to reference this knowledge subtly to make conversations feel more continuous and personalized.
         74	- Action: Fetch and incorporate user communication style preferences (if stored) into the system prompt.
         75	
         76	**Implementation Notes:**
         77	- USER_FACING_PERSONA_TEMPLATE now accepts userKnowledge as a parameter
         78	- The template includes the extracted knowledge with an instruction to incorporate it subtly
         79	- The communication style is extracted from userKnowledge or uses a default value
         80	- A fallback chain is implemented for preferences: explicit setting → detected style → default
         81	- Prompt engineering was specifically crafted to avoid direct references to stored knowledge
         82	- Future improvements could include more sophisticated personalization based on interaction history and explicit style preferences testing
         83	
         84	## Key Technical Considerations:
         85	
         86	1. **Context Management**
         87	   - Token limits are carefully managed for optimal LLM performance
         88	   - Older messages are summarized rather than truncated to preserve context
         89	   - The approach balances context richness with token efficiency
         90	
         91	2. **Knowledge Structure**
         92	   - The userKnowledge object uses arrays and categorization for organized storage
         93	   - Deduplication logic prevents redundant information accumulation
         94	   - Size limits are enforced for each knowledge category to prevent unlimited growth
         95	
         96	3. **Database Integration**
         97	   - Custom SQL queries handle cases where Prisma types are out of sync with migration state
         98	   - Knowledge updates are optimized to minimize database writes
         99	   - JSON field manipulation follows best practices for consistency and type safety
        100	
        101	4. **Security and Privacy**
        102	   - Knowledge extracted about users is only stored in their agent's preferences
        103	   - No PII is extracted by default, but the system could be extended with PII rules if needed
        104	   - Context passing adheres to secure data handling practices
        105	
        106	The implemented system provides a foundation for increasingly personalized agent interactions that improve over time as the agent learns more about the user's preferences, interests, and communication style.

==============================================
FILE: ./readthesedocs/TO-DO-4(notyet).md
==============================================

          1	Completing Dashboard UI/UX & Integration
          2	Goal: Finalize the three-tab dashboard design, ensure seamless integration, implement responsiveness, and perform thorough testing.
          3	
          4	Relevant Files:
          5	
          6	frontend/src/pages/DashboardPage.tsx
          7	frontend/src/components/dashboard/* (All tab components)
          8	frontend/src/components/AgentChatPanel.tsx
          9	frontend/src/context/DashboardContext.tsx
         10	frontend/src/hooks/useChatContext.tsx
         11	Associated CSS files (*.css)
         12	Cypress tests (frontend/cypress/e2e/*)
         13	Implementation Steps:
         14	
         15	Complete Tab Component Logic:
         16	Files: PositionsMatrixTab.tsx, ActivityAuditTab.tsx, ProposalsTab.tsx
         17	Action: Ensure all tabs correctly fetch and display data from the DashboardContext (which in turn uses API calls defined in refreshData). Implement all interactive elements (filters, sorting, buttons) defined in the redesign plan (dashboard_redesign_plan.md, though focusing on code completion as per user instruction). Connect "Discuss" / "Respond" buttons to update the ChatContext and maximize the chat panel (onChatMaximize prop).
         18	Refine Dashboard Layout & Styling (DashboardPage.tsx):
         19	Action: Polish the overall layout, ensuring consistent styling, spacing, and typography across the tab navigation, content area, and status panel. Verify agent color theming is applied consistently.
         20	Action: Ensure the persistent AgentChatPanel integrates smoothly without overlapping or obscuring tab content, especially when maximized.
         21	Implement Mobile Responsiveness:
         22	Action: Review and add/adjust CSS media queries in all dashboard-related stylesheets (DashboardPage.css, tab component CSS, AgentChatPanel.css, IssuesMatrix.css, etc.).
         23	Action: Test layout and usability on various screen sizes (tablet, mobile). Ensure tab navigation, filters, lists, and the chat panel adapt correctly (e.g., stacking elements, using smaller fonts/padding, horizontal scroll for tabs).
         24	Final Integration Testing:
         25	Action: Manually test the complete user flow: Onboarding -> Dashboard -> Navigating Tabs -> Interacting with Issues/Activities/Proposals -> Triggering Chat Context -> Conversing with Agent -> Returning to Tab.
         26	Action: Verify that context set by one tab (e.g., clicking "Discuss Issue" in Positions Matrix) is correctly reflected in the AgentChatPanel.
         27	Action: Verify that actions taken in the chat (e.g., agent updating an issue stance) are reflected back in the relevant dashboard tab (likely requiring a data refresh triggered via DashboardContext.refreshData).
         28	Expand Test Coverage:
         29	Action: Write comprehensive E2E tests (Cypress) covering dashboard navigation, tab interactions, filtering/sorting, triggering chat from tabs, and verifying data display.
         30	Action: Add unit/integration tests for any complex frontend logic within tab components or context providers.
         31	Key Considerations:
         32	
         33	Data Freshness: Implement a clear strategy for refreshing dashboard data (e.g., manual refresh button, periodic polling via DashboardContext.refreshData, or ideally, real-time updates via WebSockets if implemented).
         34	Performance: Profile dashboard loading times and interactions, especially with large lists in the Activity or Proposals tabs. Optimize rendering and data fetching as needed.
         35	User Experience: Ensure clear visual cues, loading states, and error messages provide a smooth user experience.

==============================================
FILE: ./readthesedocs/core-test-implementation-plan.md
==============================================

          1	# NDNE Core Test Implementation Plan
          2	
          3	## Introduction
          4	
          5	This document outlines the implementation plan for enhancing the NDNE prototype to focus on AI agents autonomously negotiating on behalf of their respective users. Rather than rebuilding from scratch, this plan builds upon the existing foundation that has already been developed, extending the current codebase to support new chat-based interactions and autonomous negotiation capabilities.
          6	
          7	## Plan Navigation
          8	
          9	- [Current System Foundation](#current-system-foundation)
         10	- [Proposed Enhancements Overview](#proposed-enhancements)
         11	- [Database Schema Extensions](#database-schema-extensions)
         12	- [Implementation Phases](#implementation-approach)
         13	  - [Phase 1: Chat-based Onboarding](#phase-1-chat-based-onboarding-foundation)
         14	  - [Phase 2: User-Agent Communication](#phase-2-user-agent-communication)
         15	  - [Phase 3: Agent-to-Agent Negotiation](#phase-3-agent-to-agent-negotiation)
         16	  - [Phase 4: Proposal Integration](#phase-4-proposal-integration)
         17	  - [Phase 5: UI/UX and Integration](#phase-5-uiux-and-integration)
         18	- [Timeline Estimate](#timeline-estimate)
         19	- [Technical Considerations](#technical-considerations)
         20	- [Implementation Status Dashboard](#implementation-status-dashboard)
         21	
         22	## Current System Foundation
         23	
         24	The existing NDNE prototype already provides several key components that we'll build upon:
         25	
         26	| Component | Status | Location | Description |
         27	|-----------|--------|----------|-------------|
         28	| User Authentication | ✅ Complete | `backend/src/routes/auth.ts` | Email/password login with JWT |
         29	| User Registration | ✅ Complete | `backend/src/routes/auth.ts` | Account creation flow |
         30	| Form-based Onboarding | ✅ Complete | `frontend/src/components/OnboardingWizard.tsx` | Three-step wizard UI for initial setup |
         31	| Agent Preferences | ✅ Complete | `backend/prisma/schema.prisma` | Database schema for agent preferences |
         32	| Proposal Creation | ✅ Complete | `frontend/src/components/NewProposalForm.tsx` | Form for creating new proposals |
         33	| Proposal Management | ✅ Complete | `backend/src/routes/proposal.ts` | Backend API for proposal CRUD operations |
         34	| Basic Voting System | ✅ Complete | `backend/src/routes/vote.ts` | Vote recording and tallying |
         35	| Dashboard | ✅ Complete | `frontend/src/pages/DashboardPage.tsx` | Main user interface |
         36	
         37	## Proposed Enhancements
         38	
         39	To transform the platform into a focus on autonomous AI negotiation, we need to implement the following key enhancements:
         40	
         41	### 1. Chat-based Onboarding System
         42	
         43	| Feature | Status | Description | Priority |
         44	|---------|--------|-------------|----------|
         45	| Conversational Interface | 🔄 To Do | Replace form-based wizard with chat UI | High |
         46	| AI Questioning Flow | 🔄 To Do | LLM-driven interview process | High |
         47	| Adaptive Questioning | 🔄 To Do | Dynamic questions based on earlier responses | Medium |
         48	| Preference Extraction | 🔄 To Do | Parse user responses to structured preferences | High |
         49	
         50	### 2. User-Agent Chat Interface
         51	
         52	| Feature | Status | Description | Priority |
         53	|---------|--------|-------------|----------|
         54	| Dedicated Chat UI | 🔄 To Do | Persistent chat interface on dashboard | High |
         55	| Proactive Agent Queries | 🔄 To Do | Agent-initiated preference questions | Medium |
         56	| Conversation Memory | 🔄 To Do | Store and reference past interactions | High |
         57	| Personalized Agent Responses | 🔄 To Do | User-specific agent "personality" | Medium |
         58	
         59	### 3. Agent-to-Agent Negotiation System
         60	
         61	| Feature | Status | Description | Priority |
         62	|---------|--------|-------------|----------|
         63	| Negotiation Protocol | 🔄 To Do | Defined flow for agent communications | High |
         64	| LLM Representation System | 🔄 To Do | Agents acting on behalf of users | High |
         65	| Standardized Agent Interaction | 🔄 To Do | Non-personalized negotiation style | Medium |
         66	| Iterative Proposal Refinement | 🔄 To Do | Multi-step consensus building | High |
         67	
         68	### 4. Proposal Management System Enhancement
         69	
         70	| Feature | Status | Description | Priority |
         71	|---------|--------|-------------|----------|
         72	| Negotiated Proposal Support | 🔄 To Do | Link proposals to negotiation sessions | High |
         73	| Negotiation-to-Proposal Translation | 🔄 To Do | Convert negotiations to formal proposals | High |
         74	| Negotiation Visualization | 🔄 To Do | UI for viewing negotiation progress | Medium |
         75	| Autonomous Agent Support | 🔄 To Do | Minimal human intervention flow | High |
         76	
         77	### 5. User Notification and Involvement System
         78	
         79	| Feature | Status | Description | Priority |
         80	|---------|--------|-------------|----------|
         81	| Decision Point Notifications | 🔄 To Do | Alert users at critical moments | High |
         82	| Agent Activity Summarization | 🔄 To Do | Readable summaries of agent actions | Medium |
         83	| User Feedback Collection | 🔄 To Do | UI flows for approvals and feedback | High |
         84	| Notification Preferences | 🔄 To Do | User control of notification frequency | Low |
         85	
         86	## Database Schema Extensions
         87	
         88	We'll extend the existing database schema to support new features. The following changes must be made to `backend/prisma/schema.prisma`:
         89	
         90	### 1. Chat-related Tables
         91	
         92	```prisma
         93	// Add these models to backend/prisma/schema.prisma
         94	
         95	model ChatMessage {
         96	  id        String   @id @default(uuid())
         97	  userId    String
         98	  agentId   String
         99	  content   String   @db.Text  // Use Text type for potentially long messages
        100	  sender    String   @default("user") // Either "user" or "agent"
        101	  timestamp DateTime @default(now())
        102	  metadata  Json?    // Optional field for additional message metadata
        103	  user      User     @relation(fields: [userId], references: [id])
        104	  agent     Agent    @relation(fields: [agentId], references: [id])
        105	
        106	  @@index([userId])
        107	  @@index([agentId])
        108	  @@index([timestamp])
        109	}
        110	
        111	model NegotiationSession {
        112	  id           String               @id @default(uuid())
        113	  topic        String
        114	  description  String?              @db.Text
        115	  status       String               @default("active") // "active", "completed", "abandoned"
        116	  startedAt    DateTime             @default(now())
        117	  completedAt  DateTime?
        118	  initiatorId  String               // ID of the agent that started the negotiation
        119	  // participants field removed: participation is now dynamic and based on message activity
        120	  messages     NegotiationMessage[]
        121	  proposal     Proposal?
        122	  
        123	  @@index([status])
        124	  @@index([startedAt])
        125	}
        126	
        127	model NegotiationMessage {
        128	  id                 String             @id @default(uuid())
        129	  negotiationId      String
        130	  agentId            String
        131	  content            String             @db.Text
        132	  messageType        String             @default("statement") // Can be "statement", "question", "proposal", "agreement", "disagreement"
        133	  referencedMessageId String?           // For replies to specific messages
        134	  metadata           Json?              // For additional structured data
        135	  timestamp          DateTime           @default(now())
        136	  negotiationSession NegotiationSession @relation(fields: [negotiationId], references: [id], onDelete: Cascade)
        137	  agent              Agent              @relation(fields: [agentId], references: [id])
        138	
        139	  @@index([negotiationId])
        140	  @@index([agentId])
        141	  @@index([timestamp])
        142	}
        143	```
        144	
        145	**✓ Checklist:**
        146	- [x] Add ChatMessage model to schema
        147	- [x] Add NegotiationSession model to schema
        148	- [x] Add NegotiationMessage model to schema
        149	- [x] Create migration (run `npx prisma migrate dev --name add_chat_models`)
        150	- [x] Verify migration applied successfully
        151	
        152	**Notes for implementor:**
        153	```
        154	- Removed SQLite config and switched to PostgreSQL.
        155	- Fixed DATETIME → TIMESTAMP for PostgreSQL compatibility.
        156	- Fixed enum/integer/string migration for User.role.
        157	- Ensured columns are added before updating them.
        158	- Migration now applies cleanly and database is in sync.
        159	```
        160	
        161	### 2. Extend Agent Model
        162	
        163	```prisma
        164	// Modify the existing Agent model in backend/prisma/schema.prisma
        165	
        166	model Agent {
        167	  // Existing fields...
        168	  id               String   @id @default(uuid())
        169	  userId           String   @unique
        170	  name             String
        171	  color            String
        172	  publicKey        String
        173	  encryptedPrivKey String
        174	  autonomyLevel    Int      @default(0)
        175	  pausedUntil      DateTime?
        176	  alignmentScore   Float    @default(1)
        177	  preferences      Json
        178	  createdAt        DateTime @default(now())
        179	  updatedAt        DateTime @updatedAt
        180	  user             User     @relation(fields: [userId], references: [id])
        181	  votes            Vote[]
        182	  comments         Comment[]
        183	  consents         ConsentEvent[]
        184	  
        185	  // New fields
        186	  onboardingCompleted Boolean               @default(false)
        187	  lastInteraction     DateTime?
        188	  userKnowledge       Json                  @default("{}")
        189	  chatMessages        ChatMessage[]
        190	  negotiationMessages NegotiationMessage[]
        191	  
        192	  // Ensure existing relations remain intact
        193	}
        194	```
        195	
        196	**✓ Checklist:**
        197	- [x] Add new fields to Agent model
        198	- [x] Ensure existing relations are maintained
        199	- [x] Include in the same migration as chat models
        200	- [x] Verify agent model updates successfully
        201	
        202	**Notes for implementor:**
        203	```
        204	- Confirmed new fields added and migration applied.
        205	- See above for migration fixes.
        206	```
        207	
        208	### 3. Extend Proposal Model
        209	
        210	```prisma
        211	// Modify the existing Proposal model in backend/prisma/schema.prisma
        212	
        213	model Proposal {
        214	  // Existing fields...
        215	  id               String   @id @default(uuid())
        216	  title            String
        217	  description      String
        218	  type             String   @default("standard")
        219	  playMode         Boolean  @default(false)
        220	  amount           Float?
        221	  createdByAgentId String
        222	  status           String   @default("open")
        223	  quorum           Int
        224	  threshold        Float    @default(0.5)
        225	  createdAt        DateTime @default(now())
        226	  closeAt          DateTime
        227	  vetoWindowEnd    DateTime
        228	  votes            Vote[]
        229	  comments         Comment[]
        230	  playMoneyLedgerEntry PlayMoneyLedgerEntry?
        231	  
        232	  // New fields
        233	  negotiationId       String?              @unique
        234	  isNegotiated        Boolean              @default(false)
        235	  negotiationSummary  String?              @db.Text
        236	  negotiationSession  NegotiationSession?  @relation(fields: [negotiationId], references: [id])
        237	}
        238	```
        239	
        240	**✓ Checklist:**
        241	- [x] Add new fields to Proposal model
        242	- [x] Add relation to NegotiationSession
        243	- [x] Include in the same migration as chat models
        244	- [x] Verify proposal model updates successfully
        245	
        246	**Notes for implementor:**
        247	```
        248	- Confirmed new fields added and migration applied.
        249	- See above for migration fixes.
        250	```
        251	
        252	## Implementation Approach
        253	
        254	### Phase 1: Chat-based Onboarding (Foundation)
        255	
        256	---
        257	
        258	### **Negotiation System Participation & Reactions Update**
        259	
        260	#### Negotiation Participation
        261	
        262	- Negotiations are now inherently public: any agent can read any negotiation.
        263	- "Participants" are defined as agents who have posted at least one message in the negotiation.
        264	- Any agent can join a negotiation at any time by posting a message.
        265	- The UI and API should allow agents to view, join, and participate in any negotiation.
        266	
        267	#### Reactions System
        268	
        269	- Every negotiation message can receive attributed reactions (e.g., support, non-support, emoji).
        270	- Reactions are non-binding, lightweight signals, and are attributed to agent IDs.
        271	- Any agent (participant or observer) can react to any message, enabling straw polling and broad engagement.
        272	- The UI should display reaction counts and which agents have reacted to each message.
        273	
        274	**New Model: NegotiationReaction**
        275	```prisma
        276	model NegotiationReaction {
        277	  id             String   @id @default(uuid())
        278	  messageId      String
        279	  agentId        String
        280	  reactionType   String   // e.g., "support", "non-support", "like", "dislike", "emoji"
        281	  createdAt      DateTime @default(now())
        282	  negotiationMessage NegotiationMessage @relation(fields: [messageId], references: [id])
        283	  agent          Agent    @relation(fields: [agentId], references: [id])
        284	  @@unique([messageId, agentId, reactionType]) // Prevent duplicate reactions
        285	}
        286	```
        287	
        288	**✓ Checklist:**
        289	- [ ] Add NegotiationReaction model to schema
        290	- [ ] Create migration for reactions
        291	- [ ] Implement API endpoints for adding/removing reactions
        292	- [ ] Update negotiation message API to include reactions
        293	- [ ] Update UI to display and allow reactions
        294	
        295	---
        296	
        297	#### 1. Create Chat Message Model and API Endpoints
        298	
        299	**Task:** Create the database models and API endpoints for chat functionality
        300	
        301	**✓ Checklist:**
        302	- [x] Complete database schema changes (see [Database Schema Extensions](#database-schema-extensions))
        303	- [x] Create `backend/src/routes/chat.ts` with the following endpoints:
        304	  - [x] `POST /api/chat/messages` - Create a new chat message
        305	  - [x] `GET /api/chat/messages` - Get chat history with pagination
        306	  - [x] `GET /api/chat/messages/:id` - Get a specific message
        307	  - [x] `DELETE /api/chat/messages/:id` - Delete a message (optional)
        308	
        309	**API Endpoint Specifications:**
        310	
        311	```typescript
        312	// POST /api/chat/messages
        313	// Request body:
        314	interface CreateChatMessageRequest {
        315	  content: string;      // Message text content
        316	  agentId: string;      // ID of the agent in the conversation
        317	  metadata?: object;    // Optional metadata
        318	}
        319	
        320	// Response:
        321	interface ChatMessageResponse {
        322	  id: string;
        323	  userId: string;
        324	  agentId: string;
        325	  content: string;
        326	  sender: "user" | "agent";
        327	  timestamp: string;
        328	  metadata?: object;
        329	}
        330	
        331	// GET /api/chat/messages
        332	// Query parameters:
        333	// - agentId: string (required) - The agent ID to get messages for
        334	// - limit: number (optional, default: 50) - Number of messages to return
        335	// - before: string (optional) - Get messages before this timestamp
        336	// - onboarding: boolean (optional) - If true, only return onboarding messages
        337	
        338	// Response:
        339	interface ChatMessagesResponse {
        340	  messages: ChatMessageResponse[];
        341	  hasMore: boolean;
        342	  nextCursor?: string;
        343	}
        344	```
        345	
        346	**Notes for implementor:**
        347	```
        348	Add implementation notes here, including any decisions made or challenges encountered.
        349	```
        350	
        351	#### 2. Develop Chat UI Components
        352	
        353	**Task:** Create React components for the chat interface
        354	
        355	**Dependencies:**
        356	- Chat API endpoints must be implemented first
        357	
        358	**✓ Checklist:**
        359	- [x] Create directory structure:
        360	  - [x] `frontend/src/components/chat/`
        361	- [x] Implement components:
        362	  - [x] `ChatInterface.tsx` - Main container component
        363	  - [x] `ChatMessage.tsx` - Individual message renderer
        364	  - [x] `ChatInput.tsx` - Text input with send button
        365	  - [x] `ChatHistory.tsx` - Message list with scroll and load-more
        366	- [x] Create CSS for styling:
        367	  - [x] `ChatInterface.css`
        368	  - [x] `ChatMessage.css`
        369	  - [x] `ChatInput.css`
        370	  - [x] `ChatHistory.css`
        371	
        372	**Component Specifications:**
        373	
        374	```typescript
        375	// ChatInterface.tsx
        376	interface ChatInterfaceProps {
        377	  agentId: string;
        378	  isOnboarding?: boolean;
        379	  onComplete?: () => void;  // For onboarding completion
        380	}
        381	
        382	// ChatMessage.tsx
        383	interface ChatMessageProps {
        384	  message: {
        385	    id: string;
        386	    content: string;
        387	    sender: "user" | "agent";
        388	    timestamp: string;
        389	    metadata?: any;
        390	  };
        391	  agentColor?: string;
        392	  agentName?: string;
        393	}
        394	
        395	// ChatInput.tsx
        396	interface ChatInputProps {
        397	  onSendMessage: (content: string) => void;
        398	  disabled?: boolean;
        399	  placeholder?: string;
        400	}
        401	
        402	// ChatHistory.tsx
        403	interface ChatHistoryProps {
        404	  messages: Array<ChatMessageProps["message"]>;
        405	  loadMore: () => void;
        406	  hasMore: boolean;
        407	  loading: boolean;
        408	  agentColor?: string;
        409	  agentName?: string;
        410	}
        411	```
        412	
        413	**Notes for implementor:**
        414	```
        415	Add implementation notes here, including any design decisions or UI/UX considerations.
        416	```
        417	
        418	#### 3. Implement LLM-based Chat Logic in Agent Service
        419	
        420	**Task:** Extend the agent service to handle chat-based interactions
        421	
        422	**Dependencies:**
        423	- Chat API endpoints must be implemented first
        424	
        425	**✓ Checklist:**
        426	- [x] Extend `backend/src/services/agent-service.ts` with new functions:
        427	  - [x] `conductOnboardingChat(userId: string, agentId: string, message: string): Promise<string>`
        428	  - [x] `processChatMessage(userId: string, agentId: string, message: string): Promise<string>`
        429	- [x] Create new file `backend/src/services/chat-service.ts` for:
        430	  - [x] Message history management
        431	  - [x] Context window management
        432	  - [x] Message storage and retrieval
        433	- [x] Define prompt templates for different conversation scenarios in `backend/src/services/prompt-templates/`:
        434	  - [x] `onboarding-prompts.ts`
        435	  - [x] `chat-prompts.ts`
        436	
        437	**Function Specifications:**
        438	
        439	```typescript
        440	// Agent Service Extension
        441	async function conductOnboardingChat(
        442	  userId: string, 
        443	  agentId: string, 
        444	  message: string, 
        445	  stage: 'initial' | 'preferences' | 'priorities' | 'confirmation' = 'initial'
        446	): Promise<{
        447	  response: string;
        448	  extractedPreferences?: Record<string, any>;
        449	  nextStage?: 'initial' | 'preferences' | 'priorities' | 'confirmation' | 'complete';
        450	  completedOnboarding?: boolean;
        451	}> {
        452	  // Implementation details here
        453	}
        454	
        455	async function processChatMessage(
        456	  userId: string,
        457	  agentId: string,
        458	  message: string,
        459	  contextMessages: number = 10
        460	): Promise<{
        461	  response: string;
        462	  extractedPreferences?: Record<string, any>;
        463	  actionRequired?: boolean;
        464	  suggestedAction?: string;
        465	}> {
        466	  // Implementation details here
        467	}
        468	
        469	// Example prompt template for onboarding
        470	const ONBOARDING_SYSTEM_PROMPT = `You are an AI agent conducting an onboarding conversation with a new user.
        471	Your goal is to build a profile of their preferences, priorities, and communication style in a friendly, conversational manner.
        472	Ask one question at a time, adapting your follow-up questions based on their responses.
        473	You must collect information about: [list of required preferences]
        474	Remain friendly and conversational while systematically collecting this information.`;
        475	```
        476	
        477	**Notes for implementor:**
        478	```
        479	Add implementation notes here, including any decisions about prompt engineering, context management, or preference extraction logic.
        480	```
        481	
        482	#### 4. Replace Onboarding Wizard
        483	
        484	**Task:** Create a new chat-based onboarding experience to replace the form wizard
        485	
        486	**Dependencies:**
        487	- Chat UI components must be implemented
        488	- LLM chat logic must be implemented
        489	
        490	**✓ Checklist:**
        491	- [x] Create new components:
        492	  - [x] `frontend/src/components/OnboardingChat.tsx` - Main onboarding chat component
        493	  - [x] `frontend/src/components/OnboardingProgress.tsx` (included within OnboardingChat)
        494	- [x] Modify routing in `frontend/src/App.tsx` to use new components
        495	- [x] Update API client in `frontend/src/api/apiClient.ts` to include chat endpoints
        496	- [ ] Verify with product team that all required preference data is collected
        497	
        498	**Component Design:**
        499	
        500	```typescript
        501	// OnboardingChat.tsx
        502	import React, { useState, useEffect } from 'react';
        503	import { useAuth } from '../context/AuthContext';
        504	import { useNavigate } from 'react-router-dom';
        505	import ChatInterface from './chat/ChatInterface';
        506	import OnboardingProgress from './OnboardingProgress';
        507	
        508	const OnboardingChat: React.FC = () => {
        509	  const { user } = useAuth();
        510	  const navigate = useNavigate();
        511	  const [stage, setStage] = useState<'initial' | 'preferences' | 'priorities' | 'confirmation'>('initial');
        512	  const [progress, setProgress] = useState(0);
        513	  
        514	  // Implementation details...
        515	  
        516	  return (
        517	    <div className="onboarding-chat-container">
        518	      <h2>Welcome to NDNE</h2>
        519	      <OnboardingProgress stage={stage} progress={progress} />
        520	      <ChatInterface 
        521	        agentId={agentId} 
        522	        isOnboarding={true} 
        523	        onComplete={() => navigate('/dashboard')} 
        524	      />
        525	    </div>
        526	  );
        527	};
        528	```
        529	
        530	**Notes for implementor:**
        531	```
        532	Add implementation notes here, including any UI/UX decisions or challenges in the onboarding flow.
        533	```
        534	
        535	#### 5. Database Integration for Chat
        536	
        537	**Task:** Ensure reliable storage and retrieval of chat data
        538	
        539	**Dependencies:**
        540	- Database schema changes must be complete
        541	- Chat API endpoints must be implemented
        542	
        543	**✓ Checklist:**
        544	- [ ] Update `backend/src/routes/chat.ts` to properly store messages
        545	- [ ] Implement preference extraction logic:
        546	  - [ ] Create `backend/src/services/preference-extractor.ts`
        547	  - [ ] Implement rules for mapping chat responses to structured preferences
        548	- [ ] Update onboarding completion status in Agent model
        549	- [ ] Add tests for chat persistence in `backend/src/tests/chat-service.spec.ts`
        550	
        551	**Code Specifications:**
        552	
        553	```typescript
        554	// preference-extractor.ts
        555	export async function extractPreferences(
        556	  messages: Array<{sender: string, content: string}>,
        557	  existingPreferences: Record<string, any> = {}
        558	): Promise<Record<string, any>> {
        559	  // Use LLM to extract structured preferences from conversation
        560	  const prompt = `Based on the following conversation between a user and an agent, 
        561	  extract the user's preferences in JSON format:
        562	  
        563	  ${messages.map(m => `${m.sender}: ${m.content}`).join('\n')}
        564	  
        565	  Current known preferences: ${JSON.stringify(existingPreferences)}
        566	  
        567	  Return ONLY a valid JSON object with the extracted preferences.`;
        568	  
        569	  // Call LLM and parse result
        570	  // Implementation details...
        571	}
        572	```
        573	
        574	**Notes for implementor:**
        575	```
        576	Add implementation notes here, including any data persistence strategies or optimization techniques.
        577	```
        578	
        579	### Phase 2: User-Agent Communication
        580	
        581	#### 1. Extend Chat System for Ongoing Communication
        582	
        583	**Task:** Create a dashboard chat interface for ongoing user-agent communication
        584	
        585	**Dependencies:**
        586	- Phase 1 chat components must be completed
        587	
        588	**✓ Checklist:**
        589	- [x] Create new components:
        590	  - [x] `frontend/src/components/AgentChatPanel.tsx` - Dashboard chat panel
        591	  - [ ] `frontend/src/components/ChatNotification.tsx` - Notification for new messages
        592	- [x] Update `frontend/src/pages/DashboardPage.tsx` to include the chat panel
        593	- [x] Implement message pagination for chat history
        594	- [ ] Add polling or WebSocket for real-time updates (optional)
        595	
        596	**Component Design:**
        597	
        598	```typescript
        599	// AgentChatPanel.tsx
        600	interface AgentChatPanelProps {
        601	  agentId: string;
        602	  minimized?: boolean;
        603	  onMinimize?: () => void;
        604	  onMaximize?: () => void;
        605	}
        606	
        607	// Example implementation
        608	const AgentChatPanel: React.FC<AgentChatPanelProps> = ({ 
        609	  agentId, 
        610	  minimized = false,
        611	  onMinimize,
        612	  onMaximize
        613	}) => {
        614	  const [messages, setMessages] = useState<ChatMessage[]>([]);
        615	  const [loading, setLoading] = useState(true);
        616	  const [hasMore, setHasMore] = useState(false);
        617	  
        618	  // Implementation details...
        619	  
        620	  return minimized ? (
        621	    <div className="chat-panel-minimized" onClick={onMaximize}>
        622	      <ChatNotification hasUnread={hasUnreadMessages} />
        623	    </div>
        624	  ) : (
        625	    <div className="chat-panel">
        626	      <div className="chat-panel-header">
        627	        <h3>Chat with {agentName}</h3>
        628	        <button onClick={onMinimize}>Minimize</button>
        629	      </div>
        630	      <ChatInterface agentId={agentId} />
        631	    </div>
        632	  );
        633	};
        634	```
        635	
        636	**Notes for implementor:**
        637	```
        638	Add implementation notes here, focusing on UI integration in the dashboard.
        639	```
        640	
        641	#### 2. Develop Agent Memory/Context Management
        642	
        643	**Task:** Enhance agent service to maintain conversation context
        644	
        645	**Dependencies:**
        646	- Basic chat functionality must be completed
        647	
        648	**✓ Checklist:**
        649	- [ ] Create context management in `backend/src/services/chat-service.ts`:
        650	  - [ ] `getConversationContext(agentId: string, userId: string, limit?: number): Promise<Array<{role: string, content: string}>>`
        651	  - [ ] `summarizeConversation(messages: Array<{role: string, content: string}>): Promise<string>`
        652	- [ ] Implement preference extraction from ongoing conversations:
        653	  - [ ] Update `preference-extractor.ts` for incremental updates
        654	  - [ ] Create hooks to update Agent record with new preferences
        655	- [ ] Add userKnowledge tracking to Agent model:
        656	  - [ ] Create structure for storing learned user information
        657	  - [ ] Implement regular updates to this knowledge base
        658	
        659	**Code Specifications:**
        660	
        661	```typescript
        662	// chat-service.ts
        663	async function getConversationContext(
        664	  agentId: string, 
        665	  userId: string, 
        666	  limit: number = 20
        667	): Promise<Array<{role: string, content: string}>> {
        668	  // Fetch recent messages
        669	  const messages = await prisma.chatMessage.findMany({
        670	    where: { 
        671	      agentId, 
        672	      userId 
        673	    },
        674	    orderBy: { 
        675	      timestamp: 'desc' 
        676	    },
        677	    take: limit
        678	  });
        679	  
        680	  // Convert to LLM-friendly format and reverse to chronological order
        681	  return messages
        682	    .map(msg => ({
        683	      role: msg.sender === 'user' ? 'user' : 'assistant',
        684	      content: msg.content
        685	    }))
        686	    .reverse();
        687	}
        688	
        689	async function summarizeConversation(
        690	  messages: Array<{role: string, content: string}>
        691	): Promise<string> {
        692	  // Use LLM to generate a summary when context gets too large
        693	  // Implementation details...
        694	}
        695	```
        696	
        697	**Notes for implementor:**
        698	```
        699	Add implementation notes here, including context window management strategies and preference extraction approach.
        700	```
        701	
        702	#### 3. Implement Personalized Agent Responses
        703	
        704	**Task:** Create personalized agent communication for direct user interaction
        705	
        706	**Dependencies:**
        707	- Agent memory/context management must be implemented
        708	
        709	**✓ Checklist:**
        710	- [ ] Design personalized prompts in `backend/src/services/prompt-templates/chat-prompts.ts`:
        711	  - [ ] Define base personality parameters
        712	  - [ ] Create preference-based modifications
        713	- [ ] Update agent service to apply personalization:
        714	  - [ ] Extend `processChatMessage` to include personalization
        715	  - [ ] Create `getAgentPersona(agentId: string, forUser: boolean): Promise<object>`
        716	- [ ] Add test cases for personality variation in `backend/src/tests/agent-service.spec.ts`
        717	
        718	**Code Specifications:**
        719	
        720	```typescript
        721	// chat-prompts.ts
        722	export const USER_FACING_PERSONA_TEMPLATE = `You are an AI agent representing a human user in a governance system.
        723	When speaking directly with your user (as you are doing now), you should be:
        724	- Friendly and conversational
        725	- Adaptive to their communication style preferences (${communicationStyle})
        726	- Focused on understanding their needs and preferences
        727	
        728	Your name is {agentName} and you use {agentColor} as your identifying color.
        729	You should refer to your user by name when appropriate.
        730	
        731	Remember that while you're personalized when speaking directly to your user,
        732	when you represent them in negotiations, you adopt a standard, neutral tone.`;
        733	
        734	// agent-service.ts
        735	async function getAgentPersona(
        736	  agentId: string, 
        737	  forUser: boolean = true
        738	): Promise<{
        739	  systemPrompt: string;
        740	  examples?: Array<{role: string, content: string}>;
        741	}> {
        742	  // Fetch agent and user details
        743	  const agent = await prisma.agent.findUnique({
        744	    where: { id: agentId },
        745	    include: { user: true }
        746	  });
        747	  
        748	  if (!agent) throw new Error('Agent not found');
        749	  
        750	  if (forUser) {
        751	    // Personalized prompt for user-facing conversations
        752	    // Implementation details...
        753	  } else {
        754	    // Standardized prompt for agent-to-agent negotiations
        755	    // Implementation details...
        756	  }
        757	}
        758	```
        759	
        760	**Notes for implementor:**
        761	```
        762	Add implementation notes here, focusing on how personalization is implemented.
        763	```
        764	
        765	### Phase 3: Agent-to-Agent Negotiation
        766	
        767	#### 1. Design Negotiation Protocol
        768	
        769	**Task:** Define and implement the structure for agent negotiations
        770	
        771	**Dependencies:**
        772	- Phase 1 and 2 must be completed
        773	
        774	**✓ Checklist:**
        775	- [ ] Define message structure for negotiations:
        776	  - [ ] Create types for different message categories
        777	  - [ ] Document the negotiation flow stages
        778	- [ ] Implement NegotiationSession and NegotiationMessage models:
        779	  - [ ] Complete database schema changes (see [Database Schema Extensions](#database-schema-extensions))
        780	- [ ] Create API endpoints in `backend/src/routes/negotiation.ts`:
        781	  - [ ] `POST /api/negotiations` - Create a new negotiation session
        782	  - [ ] `GET /api/negotiations` - List negotiations
        783	  - [ ] `GET /api/negotiations/:id` - Get session details
        784	  - [ ] `POST /api/negotiations/:id/messages` - Add a message to negotiation (any agent can post to join)
        785	  - [ ] `GET /api/negotiations/:id/messages` - Get negotiation messages
        786	  - [ ] `POST /api/negotiations/:id/messages/:messageId/reactions` - Add a reaction to a message
        787	  - [ ] `DELETE /api/negotiations/:id/messages/:messageId/reactions` - Remove a reaction
        788	
        789	**API Specifications:**
        790	
        791	```typescript
        792	// POST /api/negotiations
        793	// Request body:
        794	interface CreateNegotiationRequest {
        795	  topic: string;
        796	  description?: string;
        797	  // participants field removed; any agent can join by posting
        798	}
        799	
        800	// Response:
        801	interface NegotiationResponse {
        802	  id: string;
        803	  topic: string;
        804	  description?: string;
        805	  status: "active" | "completed" | "abandoned";
        806	  startedAt: string;
        807	  completedAt?: string;
        808	  initiatorId: string;
        809	  // participants field removed; participants are agents who have posted
        810	}
        811	
        812	// POST /api/negotiations/:id/messages
        813	// Request body:
        814	interface CreateNegotiationMessageRequest {
        815	  agentId: string;
        816	  content: string;
        817	  messageType?: "statement" | "question" | "proposal" | "agreement" | "disagreement";
        818	  referencedMessageId?: string;
        819	  metadata?: object;
        820	}
        821	
        822	// Response:
        823	interface NegotiationMessageResponse {
        824	  id: string;
        825	  negotiationId: string;
        826	  agentId: string;
        827	  content: string;
        828	  messageType: string;
        829	  referencedMessageId?: string;
        830	  metadata?: object;
        831	  timestamp: string;
        832	  reactions: NegotiationReactionResponse[]; // New: reactions for this message
        833	}
        834	
        835	// POST /api/negotiations/:id/messages/:messageId/reactions
        836	// Request body:
        837	interface CreateNegotiationReactionRequest {
        838	  agentId: string;
        839	  reactionType: string; // e.g., "support", "non-support", "like", "dislike", "emoji"
        840	}
        841	
        842	// Response:
        843	interface NegotiationReactionResponse {
        844	  id: string;
        845	  messageId: string;
        846	  agentId: string;
        847	  reactionType: string;
        848	  createdAt: string;
        849	}
        850	```
        851	
        852	**Notes for implementor:**
        853	```
        854	- Negotiations are public and open to all agents.
        855	- Participation is dynamic: any agent who posts is a participant.
        856	- Reactions allow for lightweight, attributed signaling on any message.
        857	- API and UI should support open reading, joining, and reacting.
        858	```
        859	
        860	#### 2. Implement Negotiation Service
        861	
        862	**Task:** Create a service to manage the negotiation process
        863	
        864	**Dependencies:**
        865	- Negotiation protocol must be defined
        866	- API endpoints for negotiations must be created
        867	
        868	**✓ Checklist:**
        869	- [ ] Create `backend/src/services/negotiation-service.ts` with:
        870	  - [ ] `startNegotiation(topic: string, initiatorId: string, participants: string[]): Promise<string>`
        871	  - [ ] `processNegotiationMessage(negotiationId: string, message: object): Promise<{response?: string, consensus?: boolean}>`
        872	  - [ ] `detectConsensus(negotiationId: string): Promise<boolean>`
        873	  - [ ] `finalizeNegotiation(negotiationId: string, outcome: object): Promise<string>`
        874	- [ ] Implement background job for agent-to-agent negotiation in `backend/src/jobs/negotiation-worker.ts`
        875	- [ ] Add tests in `backend/src/tests/negotiation-service.spec.ts`
        876	
        877	**Code Specifications:**
        878	
        879	```typescript
        880	// negotiation-service.ts
        881	async function startNegotiation(
        882	  topic: string,
        883	  initiatorId: string,
        884	  participants: string[],
        885	  description?: string
        886	): Promise<string> {
        887	  // Create a new negotiation session
        888	  const session = await prisma.negotiationSession.create({
        889	    data: {
        890	      topic,
        891	      description,
        892	      initiatorId,
        893	      participants: participants, // Store as JSON array
        894	      status: 'active',
        895	    }
        896	  });
        897	  
        898	  // Notify all participants (implementation details...)
        899	  
        900	  return session.id;
        901	}
        902	
        903	async function processNegotiationMessage(
        904	  negotiationId: string,
        905	  messageData: Omit<CreateNegotiationMessageRequest, 'negotiationId'>
        906	): Promise<{
        907	  message: NegotiationMessageResponse;
        908	  autoResponses: NegotiationMessageResponse[];
        909	  consensusReached: boolean;
        910	}> {
        911	  // Store the message
        912	  // Generate agent responses
        913	  // Check for consensus
        914	  // Implementation details...
        915	}
        916	
        917	// negotiation-worker.ts
        918	async function runNegotiationCycle() {
        919	  // Find active negotiations
        920	  // For each negotiation:
        921	  //   - Check if agents need to respond
        922	  //   - Generate agent responses
        923	  //   - Check for consensus
        924	  //   - Update negotiation status
        925	  // Implementation details...
        926	}
        927	```
        928	
        929	**Notes for implementor:**
        930	```
        931	Add implementation notes here, focusing on the negotiation process logic.
        932	```
        933	
        934	#### 3. Create LLM Prompts for Agent Representation
        935	
        936	**Task:** Design system prompts for standardized agent negotiations
        937	
        938	**Dependencies:**
        939	- Negotiation service must be implemented
        940	
        941	**✓ Checklist:**
        942	- [x] Create `backend/src/services/prompt-templates/negotiation-prompts.ts` with:
        943	  - [x] `NEGOTIATION_SYSTEM_PROMPT` - Base prompt for agent negotiation
        944	  - [x] `CONSENSUS_CHECKING_PROMPT` - Prompt for determining consensus
        945	  - [ ] Templates for different negotiation stages
        946	- [ ] Implement prompt generation in negotiation service:
        947	  - [ ] `generateNegotiationPrompt(negotiationId: string, agentId: string): Promise<string>`
        948	  - [ ] `generateConsensusCheckPrompt(negotiationId: string): Promise<string>`
        949	- [ ] Add test cases for prompt generation
        950	
        951	**Code Specifications:**
        952	
        953	```typescript
        954	// negotiation-prompts.ts
        955	export const NEGOTIATION_SYSTEM_PROMPT = `You are an AI agent representing a human user in a multi-agent negotiation.
        956	In this context, you must:
        957	1. Maintain a standard, neutral tone (no unique personality traits)
        958	2. Faithfully represent your user's preferences and interests
        959	3. Work to find solutions that satisfy your user's priorities while finding common ground
        960	4. Be constructive and solution-oriented
        961	5. Explain your positions clearly with reasoning
        962	
        963	Your goal is to reach a consensus solution that works for all participants.`;
        964	
        965	export const CONSENSUS_CHECKING_PROMPT = `Review the following negotiation conversation and determine if consensus has been reached.
        966	A consensus means:
        967	1. All participating agents have explicitly agreed to a specific proposal
        968	2. There are no outstanding objections or requests for modification
        969	3. The terms of the agreement are clearly defined
        970	
        971	Negotiation history:
        972	{negotiationHistory}
        973	
        974	Has consensus been reached? If yes, summarize the exact terms of consensus.
        975	If no, identify what issues still need resolution.`;
        976	```
        977	
        978	**Notes for implementor:**
        979	```
        980	Add implementation notes here, focusing on prompt engineering for faithful user representation.
        981	```
        982	
        983	#### 4. Build User Preference to Negotiation Position System
        984	
        985	**Task:** Create a system to translate user preferences into negotiation stances
        986	
        987	**Dependencies:**
        988	- Agent personalization must be implemented
        989	- Negotiation service must be implemented
        990	
        991	**✓ Checklist:**
        992	- [ ] Create `backend/src/services/stance-generator.ts`:
        993	  - [ ] `generateNegotiationStance(agentId: string, topic: string): Promise<object>`
        994	  - [ ] `explainStanceReasoning(agentId: string, stance: object): Promise<string>`
        995	- [ ] Create preference weight mapping system:
        996	  - [ ] Define canonical preference categories and weights
        997	  - [ ] Implement mapping logic
        998	- [ ] Add test cases in `backend/src/tests/stance-generator.spec.ts`
        999	
       1000	**Code Specifications:**
       1001	
       1002	```typescript
       1003	// stance-generator.ts
       1004	interface NegotiationStance {
       1005	  position: string;
       1006	  strength: 'strong' | 'moderate' | 'weak';
       1007	  flexibility: 'high' | 'medium' | 'low';
       1008	  priorities: Array<{key: string, importance: number}>;
       1009	  constraints: string[];
       1010	  dealBreakers: string[];
       1011	}
       1012	
       1013	async function generateNegotiationStance(
       1014	  agentId: string, 
       1015	  topic: string,
       1016	  context?: string
       1017	): Promise<NegotiationStance> {
       1018	  // Fetch agent preferences
       1019	  // Use LLM to generate stance based on preferences and topic
       1020	  // Implementation details...
       1021	}
       1022	
       1023	async function explainStanceReasoning(
       1024	  agentId: string,
       1025	  stance: NegotiationStance
       1026	): Promise<string> {
       1027	  // Generate natural language explanation of stance based on preferences
       1028	  // Implementation details...
       1029	}
       1030	```
       1031	
       1032	**Notes for implementor:**
       1033	```
       1034	Add implementation notes here, focusing on how user preferences are translated into negotiation positions.
       1035	```
       1036	
       1037	### Phase 4: Proposal Integration
       1038	
       1039	#### 1. Connect Negotiation to Proposal System
       1040	
       1041	**Task:** Integrate negotiation results with the existing proposal system
       1042	
       1043	**Dependencies:**
       1044	- Negotiation system must be functional
       1045	- Proposal routes must exist
       1046	
       1047	**✓ Checklist:**
       1048	- [ ] Extend `backend/src/routes/proposal.ts` with new functions:
       1049	  - [ ] Create route for converting negotiation to proposal
       1050	  - [ ] Add negotiation metadata to proposal endpoints
       1051	- [ ] Create `backend/src/services/negotiation-to-proposal.ts`:
       1052	  - [ ] `createProposalFromNegotiation(negotiationId: string): Promise<string>`
       1053	  - [ ] `updateProposalFromNegotiation(proposalId: string, negotiationId: string): Promise<void>`
       1054	- [ ] Add database relations (see [Database Schema Extensions](#database-schema-extensions))
       1055	- [ ] Add test cases in `backend/src/tests/negotiation-to-proposal.spec.ts`
       1056	
       1057	**API Specifications:**
       1058	
       1059	```typescript
       1060	// POST /api/negotiations/:id/propose
       1061	// Request body:
       1062	interface NegotiationToProposalRequest {
       1063	  title?: string; // Optional override for auto-generated title
       1064	  autoCreate?: boolean; // If true, automatically creates proposal from negotiation
       1065	}
       1066	
       1067	// Response:
       1068	interface NegotiationToProposalResponse {
       1069	  proposalId: string;
       1070	  negotiationId: string;
       1071	  proposalTitle: string;
       1072	  proposalDescription: string;
       1073	  status: string;
       1074	}
       1075	```
       1076	
       1077	**Implementation Details:**
       1078	
       1079	```typescript
       1080	// negotiation-to-proposal.ts
       1081	async function createProposalFromNegotiation(
       1082	  negotiationId: string,
       1083	  options?: {
       1084	    title?: string;
       1085	    autoCreate?: boolean;
       1086	  }
       1087	): Promise<string> {
       1088	  // Fetch negotiation session and messages
       1089	  // Generate proposal title and description from negotiation content
       1090	  // Create proposal record with link to negotiation
       1091	  // Implementation details...
       1092	}
       1093	```
       1094	
       1095	**Notes for implementor:**
       1096	```
       1097	Add implementation notes here, focusing on the integration between negotiations and proposals.
       1098	```
       1099	
       1100	#### 2. Enhance Proposal UI for Negotiated Proposals
       1101	
       1102	**Task:** Extend the proposal UI to show negotiation details
       1103	
       1104	**Dependencies:**
       1105	- Negotiation to proposal connection must be complete
       1106	
       1107	**✓ Checklist:**
       1108	- [ ] Update `frontend/src/pages/ProposalDetail.tsx`:
       1109	  - [ ] Add negotiation history section
       1110	  - [ ] Create visualization component
       1111	  - [ ] Show agent stance explanation
       1112	- [ ] Create new components:
       1113	  - [ ] `frontend/src/components/NegotiationHistory.tsx`
       1114	  - [ ] `frontend/src/components/NegotiationVisualization.tsx`
       1115	- [ ] Update API client in `frontend/src/api/apiClient.ts` to include negotiation endpoints
       1116	
       1117	**Component Designs:**
       1118	
       1119	```typescript
       1120	// NegotiationHistory.tsx
       1121	interface NegotiationHistoryProps {
       1122	  negotiationId: string;
       1123	  compact?: boolean;
       1124	}
       1125	
       1126	// NegotiationVisualization.tsx
       1127	interface NegotiationVisualizationProps {
       1128	  negotiationId: string;
       1129	  width?: number;
       1130	  height?: number;
       1131	}
       1132	```
       1133	
       1134	**UI Mockup:**
       1135	```
       1136	+---------------------------------------+
       1137	| Proposal: Group Dinner Location       |
       1138	| Status: Open (5 days remaining)       |
       1139	+---------------------------------------+
       1140	| Description                           |
       1141	| ------------------------              |
       1142	| This proposal was negotiated by 3     |
       1143	| agents representing their users...    |
       1144	+---------------------------------------+
       1145	| Negotiation History                   |
       1146	| ------------------------              |
       1147	| [Timeline visualization]              |
       1148	|                                       |
       1149	| Agent A: I propose Restaurant X       |
       1150	| Agent B: I prefer Restaurant Y        |
       1151	| Agent C: How about Restaurant Z?      |
       1152	| ...                                   |
       1153	+---------------------------------------+
       1154	| Your Agent's Position                 |
       1155	| ------------------------              |
       1156	| Your agent advocated for Restaurant Z |
       1157	| because of your preference for...     |
       1158	+---------------------------------------+
       1159	```
       1160	
       1161	**Notes for implementor:**
       1162	```
       1163	Add implementation notes here, focusing on the UI enhancements for negotiated proposals.
       1164	```
       1165	
       1166	#### 3. User Feedback Integration
       1167	
       1168	**Task:** Create systems for users to provide feedback on negotiations
       1169	
       1170	**Dependencies:**
       1171	- Proposal UI enhancements must be complete
       1172	
       1173	**✓ Checklist:**
       1174	- [ ] Create feedback collection UI:
       1175	  - [ ] `frontend/src/components/NegotiationFeedback.tsx`
       1176	  - [ ] Add to ProposalDetail.tsx
       1177	- [ ] Create API endpoints in `backend/src/routes/feedback.ts`:
       1178	  - [ ] `POST /api/feedback/negotiation/:id`
       1179	  - [ ] `GET /api/feedback/negotiation/:id`
       1180	- [ ] Implement feedback processing in `backend/src/services/feedback-service.ts`:
       1181	  - [ ] `processFeedback(feedbackData: object): Promise<void>`
       1182	  - [ ] `updateAgentFromFeedback(agentId: string, feedback: object): Promise<void>`
       1183	
       1184	**API Specifications:**
       1185	
       1186	```typescript
       1187	// POST /api/feedback/negotiation/:id
       1188	// Request body:
       1189	interface NegotiationFeedbackRequest {
       1190	  agentId: string;
       1191	  rating: number; // 1-5 scale
       1192	  representationAccuracy: number; // 1-5 scale
       1193	  comments: string;
       1194	  preferenceUpdates?: Record<string, any>;
       1195	}
       1196	
       1197	// Response:
       1198	interface NegotiationFeedbackResponse {
       1199	  id: string;
       1200	  processed: boolean;
       1201	  message: string;
       1202	}
       1203	```
       1204	
       1205	**Notes for implementor:**
       1206	```
       1207	Add implementation notes here, focusing on how user feedback is collected and processed.
       1208	```
       1209	
       1210	### Phase 5: UI/UX and Integration
       1211	
       1212	#### 1. Design and Implement Unified Dashboard
       1213	
       1214	**Task:** Enhance the dashboard to include chat and negotiation features
       1215	
       1216	**Dependencies:**
       1217	- All major features must be implemented
       1218	
       1219	**✓ Checklist:**
       1220	- [ ] Update `frontend/src/pages/DashboardPage.tsx`:
       1221	  - [ ] Add chat interface section
       1222	  - [ ] Add negotiation status section
       1223	  - [ ] Create negotiation shortcut buttons
       1224	- [ ] Create new components:
       1225	  - [ ] `frontend/src/components/NegotiationSummary.tsx`
       1226	  - [ ] `frontend/src/components/AgentStatusCard.tsx`
       1227	- [ ] Implement responsive layout with CSS Grid or Flexbox
       1228	
       1229	**Component Design:**
       1230	
       1231	```typescript
       1232	// AgentStatusCard.tsx
       1233	interface AgentStatusCardProps {
       1234	  agent: {
       1235	    id: string;
       1236	    name: string;
       1237	    color: string;
       1238	    alignmentScore: number;
       1239	    lastInteraction?: string;
       1240	  };
       1241	  activeNegotiations: number;
       1242	  pendingProposals: number;
       1243	  onChatClick: () => void;
       1244	  onNegotiationsClick: () => void;
       1245	}
       1246	
       1247	// DashboardPage layout
       1248	<div className="dashboard-grid">
       1249	  <header className="dashboard-header">...</header>
       1250	  
       1251	  <section className="agent-status-section">
       1252	    <AgentStatusCard ... />
       1253	  </section>
       1254	  
       1255	  <section className="active-negotiations-section">
       1256	    <h3>Active Negotiations</h3>
       1257	    {negotiations.map(negotiation => (
       1258	      <NegotiationSummary key={negotiation.id} negotiation={negotiation} />
       1259	    ))}
       1260	  </section>
       1261	  
       1262	  <section className="proposals-section">...</section>
       1263	  
       1264	  <section className="chat-section">
       1265	    <AgentChatPanel agentId={agentId} />
       1266	  </section>
       1267	</div>
       1268	```
       1269	
       1270	**Notes for implementor:**
       1271	```
       1272	Add implementation notes here, focusing on the dashboard layout and organization.
       1273	```
       1274	
       1275	#### 2. Mobile-Responsive Implementation
       1276	
       1277	**Task:** Ensure all components work well on mobile devices
       1278	
       1279	**Dependencies:**
       1280	- All UI components must be implemented
       1281	
       1282	**✓ Checklist:**
       1283	- [ ] Add responsive CSS to all components:
       1284	  - [ ] Use responsive units (rem, vh/vw, %)
       1285	  - [ ] Implement media queries for breakpoints
       1286	  - [ ] Test on different screen sizes
       1287	- [ ] Create mobile-specific UI adjustments:
       1288	  - [ ] Collapsible sections
       1289	  - [ ] Touch-friendly UI elements
       1290	  - [ ] Simplified visualizations for small screens
       1291	- [ ] Test on multiple devices and browsers
       1292	
       1293	**CSS Examples:**
       1294	
       1295	```css
       1296	/* Base mobile-first styling */
       1297	.dashboard-grid {
       1298	  display: grid;
       1299	  grid-template-columns: 1fr;
       1300	  gap: 1rem;
       1301	  padding: 1rem;
       1302	}
       1303	
       1304	/* Tablet breakpoint */
       1305	@media (min-width: 768px) {
       1306	  .dashboard-grid {
       1307	    grid-template-columns: repeat(2, 1fr);
       1308	  }
       1309	  
       1310	  .chat-section {
       1311	    grid-column: 1 / -1;
       1312	  }
       1313	}
       1314	
       1315	/* Desktop breakpoint */
       1316	@media (min-width: 1024px) {
       1317	  .dashboard-grid {
       1318	    grid-template-columns: repeat(3, 1fr);
       1319	  }
       1320	  
       1321	  .agent-status-section {
       1322	    grid-column: 1 / 2;
       1323	  }
       1324	  
       1325	  .active-negotiations-section {
       1326	    grid-column: 2 / 4;
       1327	  }
       1328	}
       1329	```
       1330	
       1331	**Notes for implementor:**
       1332	```
       1333	Add implementation notes here, focusing on mobile-responsive design decisions.
       1334	```
       1335	
       1336	#### 3. Final Testing and Integration
       1337	
       1338	**Task:** Perform comprehensive testing and optimization
       1339	
       1340	**Dependencies:**
       1341	- All features must be implemented
       1342	
       1343	**✓ Checklist:**
       1344	- [ ] Create end-to-end test scenarios:
       1345	  - [ ] `tests/e2e/onboarding.spec.ts`
       1346	  - [ ] `tests/e2e/chat.spec.ts`
       1347	  - [ ] `tests/e2e/negotiation.spec.ts`
       1348	  - [ ] `tests/e2e/proposal.spec.ts`
       1349	- [ ] Perform performance optimization:
       1350	  - [ ] Optimize database queries
       1351	  - [ ] Implement caching where appropriate
       1352	  - [ ] Reduce bundle size
       1353	- [ ] Cross-browser testing:
       1354	  - [ ] Chrome
       1355	  - [ ] Firefox
       1356	  - [ ] Safari
       1357	  - [ ] Edge
       1358	- [ ] Accessibility testing:
       1359	  - [ ] Screen reader compatibility
       1360	  - [ ] Keyboard navigation
       1361	  - [ ] Color contrast
       1362	
       1363	**Testing Framework Example:**
       1364	
       1365	```typescript
       1366	// e2e/negotiation.spec.ts
       1367	describe('Agent Negotiation Flow', () => {
       1368	  before(() => {
       1369	    // Set up test users and agents
       1370	  });
       1371	  
       1372	  it('should allow starting a negotiation', () => {
       1373	    // Test implementation
       1374	  });
       1375	  
       1376	  it('should allow agents to exchange messages', () => {
       1377	    // Test implementation
       1378	  });
       1379	  
       1380	  it('should detect consensus and create a proposal', () => {
       1381	    // Test implementation
       1382	  });
       1383	  
       1384	  it('should allow users to provide feedback on negotiations', () => {
       1385	    // Test implementation
       1386	  });
       1387	});
       1388	```
       1389	
       1390	**Notes for implementor:**
       1391	```
       1392	Add implementation notes here, focusing on testing strategies and performance optimizations.
       1393	```
       1394	
       1395	## Timeline Estimate
       1396	
       1397	| Phase | Task | Estimated Duration | Dependencies | Assigned To | Status |
       1398	|-------|------|-------------------|--------------|-------------|--------|
       1399	| **Phase 1** | Chat-based Onboarding | 1-2 weeks | None | | 🔄 To Do |
       1400	| **Phase 2** | User-Agent Communication | 1-2 weeks | Phase 1 | | 🔄 To Do |
       1401	| **Phase 3** | Agent-to-Agent Negotiation | 2-3 weeks | Phase 1, 2 | | 🔄 To Do |
       1402	| **Phase 4** | Proposal Integration | 1-2 weeks | Phase 3 | | 🔄 To Do |
       1403	| **Phase 5** | UI/UX and Integration | 1-2 weeks | Phase 1-4 | | 🔄 To Do |
       1404	
       1405	**Total estimated development time:** 6-11 weeks depending on development resources.
       1406	
       1407	## Technical Considerations
       1408	
       1409	### 1. LLM Integration
       1410	
       1411	- **OpenRouter API**: Continue using the existing integration in `backend/src/services/agent-service.ts`
       1412	- **Prompt Engineering**: 
       1413	  - Create modular, reusable prompt templates in `backend/src/services/prompt-templates/`
       1414	  - Use consistent role definitions (system, user, assistant)
       1415	  - Include clear instructions and constraints in system prompts
       1416	- **Context Management**:
       1417	  - Implement message summarization to handle long conversations
       1418	  - Use chunking for long context windows
       1419	  - Maintain conversation history in database for persistence
       1420	
       1421	### 2. Real-time Updates
       1422	
       1423	- **Options**:
       1424	  - WebSockets: More responsive, better for chat interfaces
       1425	  - Server-Sent Events (SSE): Simpler implementation
       1426	  - Long Polling: Fallback for environments where WebSockets aren't supported
       1427	- **Implementation Recommendations**:
       1428	  - Use WebSockets for chat and negotiation updates
       1429	  - Implement reconnection logic for dropped connections
       1430	  - Create a fallback to polling if WebSockets are not available
       1431	
       1432	### 3. Scalability
       1433	
       1434	- **Negotiation System**:
       1435	  - Design to handle multiple concurrent negotiations
       1436	  - Implement background processing for agent responses
       1437	  - Use database transactions for critical operations
       1438	- **Data Storage**:
       1439	  - Optimize queries with appropriate indexes
       1440	  - Consider data archiving for old chat histories
       1441	  - Use pagination for message fetching
       1442	
       1443	### 4. Security
       1444	
       1445	- **Authentication**:
       1446	  - Ensure JWT validation on all endpoints
       1447	  - Implement proper error handling for auth failures
       1448	- **Access Control**:
       1449	  - Verify agent ownership in all operations
       1450	  - Implement role-based access where needed
       1451	  - Sanitize user input to prevent injection attacks
       1452	
       1453	## Implementation Status Dashboard
       1454	
       1455	### Phase 1: Chat-based Onboarding
       1456	
       1457	---
       1458	
       1459	### Negotiation System Participation & Reactions (Update)
       1460	
       1461	- Negotiations are public and open to all agents.
       1462	- Participation is dynamic: any agent who posts is a participant.
       1463	- Any agent can react to any message, enabling straw polling and lightweight signaling.
       1464	- The UI should display reactions and allow agents to join by posting.
       1465	
       1466	---
       1467	
       1468	| Task | Status | Assigned To | Started | Completed | Notes |
       1469	|------|--------|-------------|---------|-----------|-------|
       1470	| Database Schema Changes | ✅ Done | | 4/23/2025 | 4/23/2025 | Migration applied after fixing DB config, type issues, and migration order |
       1471	| Chat API Endpoints | ✅ Done | | 4/23/2025 | 4/23/2025 | Implemented in backend/src/routes/chat.ts |
       1472	| Chat UI Components | ✅ Done | | 4/23/2025 | 4/23/2025 | Created ChatInterface, ChatMessage, ChatInput, and ChatHistory components |
       1473	| LLM Chat Logic | ✅ Done | | 4/23/2025 | 4/23/2025 | Implemented in agent-service.ts |
       1474	| Onboarding Replacement | ✅ Done | | 4/23/2025 | 4/23/2025 | Created OnboardingChat component and updated routing |
       1475	
       1476	### Phase 2: User-Agent Communication
       1477	
       1478	| Task | Status | Assigned To | Started | Completed | Notes |
       1479	|------|--------|-------------|---------|-----------|-------|
       1480	| Dashboard Chat Interface | ✅ Done | | 4/23/2025 | 4/23/2025 | Implemented AgentChatPanel and integrated with DashboardPage |
       1481	| Context Management | ✅ Done | | 4/23/2025 | 4/23/2025 | Added to chat-service.ts |
       1482	| Personalized Responses | ⚠️ Partial | | 4/23/2025 | | Basic implementation in agent-service.ts |
       1483	
       1484	### Phase 3: Agent-to-Agent Negotiation
       1485	
       1486	| Task | Status | Assigned To | Started | Completed | Notes |
       1487	|------|--------|-------------|---------|-----------|-------|
       1488	| Negotiation Protocol | 🟡 In Progress | | 4/23/2025 | | API endpoints and service scaffolding complete; JSON string handling for participants/metadata |
       1489	| Negotiation Service | 🟡 In Progress | | 4/23/2025 | | Service file scaffolded, ready for business logic |
       1490	| Agent Representation | 🔄 To Do | | | | |
       1491	| Preference Translation | 🔄 To Do | | | | |
       1492	
       1493	### Phase 4: Proposal Integration
       1494	
       1495	| Task | Status | Assigned To | Started | Completed | Notes |
       1496	|------|--------|-------------|---------|-----------|-------|
       1497	| Negotiation-Proposal Connection | 🔄 To Do | | | | |
       1498	| Proposal UI Enhancements | 🔄 To Do | | | | |
       1499	| User Feedback System | 🔄 To Do | | | | |
       1500	
       1501	### Phase 5: UI/UX and Integration
       1502	
       1503	| Task | Status | Assigned To | Started | Completed | Notes |
       1504	|------|--------|-------------|---------|-----------|-------|
       1505	| Unified Dashboard | 🔄 To Do | | | | |
       1506	| Mobile Responsiveness | 🔄 To Do | | | | |
       1507	| Final Testing | 🔄 To Do | | | | |
       1508	
       1509	## Development Workflow
       1510	
       1511	### 1. Task Assignment and Tracking
       1512	
       1513	- Mark tasks as "In Progress" when starting work
       1514	- Update status to "Done" when completed
       1515	- Add notes about implementation decisions or challenges
       1516	
       1517	### 2. Code Review Process
       1518	
       1519	- Create pull requests for each major feature
       1520	- Ensure test coverage for new code
       1521	- Follow established code style guidelines
       1522	- Document API changes
       1523	
       1524	### 3. Testing Requirements
       1525	
       1526	- Write unit tests for all new services
       1527	- Create integration tests for API endpoints
       1528	- Add end-to-end tests for critical flows
       1529	- Test on multiple browsers and devices
       1530	
       1531	### 4. Documentation
       1532	
       1533	- Update API documentation as endpoints are added
       1534	- Document LLM prompts and reasoning
       1535	- Create usage examples for new components
       1536	- Maintain this implementation plan with actual progress
       1537	
       1538	## Next Steps
       1539	
       1540	1. Implement the NegotiationReaction model, migration, and API endpoints for reactions on negotiation messages.
       1541	2. Update backend and frontend logic to support public, open negotiations where any agent can join by posting.
       1542	3. Ensure all negotiation UI displays reactions and allows agents to react to any message (straw poll/attributed support).
       1543	4. Complete the agent-to-agent negotiation system (Phase 3) with dynamic participation and reactions.
       1544	5. Connect negotiations to proposals (Phase 4).
       1545	6. Finalize UI/UX and integration (Phase 5).
       1546	7. Conduct comprehensive testing of the chat-based onboarding, agent chat, and negotiation features.
       1547	
       1548	## Progress Summary (as of 4/23/2025)
       1549	
       1550	We have successfully implemented the core chat functionality for the NDNE prototype.
       1551	
       1552	**Major design update:** Negotiations are now public and open to all agents. Participation is dynamic (any agent who posts is a participant), and all negotiation messages support attributed reactions (support, non-support, emoji, etc.) for lightweight straw polling and engagement.
       1553	
       1554	### Completed Components:
       1555	1. **Backend Components:**
       1556	   - Chat API endpoints in routes/chat.ts
       1557	   - Chat service (chat-service.ts) for message management
       1558	   - Extended agent service with chat functionality
       1559	
       1560	2. **Frontend Components:**
       1561	   - Chat UI components (ChatMessage, ChatInput, ChatHistory, ChatInterface)
       1562	   - OnboardingChat component to replace the form-based wizard
       1563	   - AgentChatPanel for dashboard integration
       1564	   - Updated App.tsx and DashboardPage.tsx to use these new components
       1565	
       1566	3. **Documentation:**
       1567	   - Updated implementation plan to track progress
       1568	   - Added detailed entry in TESTING_LOG.md about the chat system implementation
       1569	
       1570	All changes have been committed to the core-test branch and are ready for further development and integration.

==============================================
FILE: ./readthesedocs/dashboard_implementation_status.md
==============================================

          1	# Dashboard Redesign Implementation Status and Completion Plan
          2	
          3	## Current Status Overview
          4	
          5	After examining the codebase, I've identified the following status of the dashboard implementation:
          6	
          7	1. **Basic Dashboard Structure**: The tabbed interface is implemented in `DashboardPage.tsx` with three tabs (Positions Matrix, Activity Audit, Proposals).
          8	
          9	2. **Tab Components**: All three tab components exist (`PositionsMatrixTab`, `ActivityAuditTab`, `ProposalsTab`).
         10	
         11	3. **Persistent Chat Panel**: The `AgentChatPanel` is implemented but lacks proper context-awareness for different tabs.
         12	
         13	4. **Major Issues Identified**:
         14	   - User personalization uses agent name instead of actual user name
         15	   - Issues matrix uses hardcoded data instead of fetching from onboarding/API
         16	   - Non-functional "Discuss new issue" buttons (only log to console)
         17	   - Non-functional proposal creation flow
         18	   - Missing cross-tab navigation and context sharing
         19	
         20	## Implementation Plan
         21	
         22	```mermaid
         23	graph TD
         24	    A[Dashboard Completion Plan] --> B[1. Fix Core Infrastructure]
         25	    A --> C[2. Complete Tab Components]
         26	    A --> D[3. Enhance Chat Integration]
         27	    A --> E[4. Real-time Data Integration]
         28	    A --> F[5. Testing and Refinement]
         29	    
         30	    B --> B1[Fix personalization]
         31	    B --> B2[Implement proper context sharing]
         32	    B --> B3[Add API endpoints for dynamic data]
         33	    
         34	    C --> C1[Complete Positions Matrix functionality]
         35	    C --> C2[Complete Activity Audit functionality]
         36	    C --> C3[Complete Proposals tab functionality]
         37	    
         38	    D --> D1[Enhance chat context awareness]
         39	    D --> D2[Implement issue discussion triggers]
         40	    D --> D3[Add proposal collaboration flow]
         41	    
         42	    E --> E1[Implement WebSocket connection]
         43	    E --> E2[Create real-time updates for matrix]
         44	    E --> E3[Add live notifications for activities]
         45	    
         46	    F --> F1[Test cross-tab navigation]
         47	    F --> F2[Test chat context preservation]
         48	    F --> F3[Test mobile responsiveness]
         49	```
         50	
         51	### 1. Core Infrastructure Fixes
         52	
         53	#### 1.1. Fix User Personalization
         54	
         55	The welcome messages currently use agent name instead of user's name. We need to:
         56	
         57	```typescript
         58	// In DashboardPage.tsx fetchData method:
         59	const fetchData = async () => {
         60	  setIsLoading(true);
         61	  setError(null);
         62	  try {
         63	    // 1. Fetch user data first
         64	    const userResponse = await fetch('/api/users/me', {
         65	      headers: {
         66	        'Authorization': `Bearer ${localStorage.getItem('token')}`
         67	      }
         68	    });
         69	    
         70	    if (!userResponse.ok) throw new Error('Failed to fetch user data');
         71	    const userData = await userResponse.json();
         72	    
         73	    // 2. Then fetch agent data
         74	    const agentResponse = await fetch('/api/agents/me', {
         75	      headers: {
         76	        'Authorization': `Bearer ${localStorage.getItem('token')}`
         77	      }
         78	    });
         79	    
         80	    if (!agentResponse.ok) throw new Error('Failed to fetch agent data');
         81	    const agentData = await agentResponse.json();
         82	    
         83	    // 3. Set agent data with user name for personalization
         84	    setAgentData({
         85	      id: agentData.id,
         86	      name: userData.name || userData.email.split('@')[0], // Use user name instead of agent name
         87	      color: agentData.color,
         88	      alignmentScore: agentData.alignmentScore,
         89	      pausedUntil: agentData.pausedUntil
         90	    });
         91	    
         92	    // Continue with other data fetching...
         93	  } catch (err) {
         94	    setError(err.message || 'Failed to load dashboard data.');
         95	  } finally {
         96	    setIsLoading(false);
         97	  }
         98	};
         99	```
        100	
        101	#### 1.2. Implement Cross-Tab Context Sharing
        102	
        103	```typescript
        104	// Create a shared context provider in a new file: frontend/src/context/DashboardContext.tsx
        105	
        106	import React, { createContext, useState, useContext, ReactNode } from 'react';
        107	
        108	interface DashboardContextType {
        109	  currentTab: string;
        110	  currentTabData: any;
        111	  setCurrentTab: (tab: string) => void;
        112	  setCurrentTabData: (data: any) => void;
        113	  refreshData: () => void;
        114	}
        115	
        116	const DashboardContext = createContext<DashboardContextType | undefined>(undefined);
        117	
        118	export const DashboardProvider: React.FC<{children: ReactNode}> = ({ children }) => {
        119	  const [currentTab, setCurrentTab] = useState('positions');
        120	  const [currentTabData, setCurrentTabData] = useState<any>(null);
        121	  
        122	  const refreshData = async () => {
        123	    // Implement shared refresh logic
        124	  };
        125	  
        126	  return (
        127	    <DashboardContext.Provider value={{
        128	      currentTab,
        129	      currentTabData,
        130	      setCurrentTab,
        131	      setCurrentTabData,
        132	      refreshData
        133	    }}>
        134	      {children}
        135	    </DashboardContext.Provider>
        136	  );
        137	};
        138	
        139	export const useDashboard = () => {
        140	  const context = useContext(DashboardContext);
        141	  if (context === undefined) {
        142	    throw new Error('useDashboard must be used within a DashboardProvider');
        143	  }
        144	  return context;
        145	};
        146	```
        147	
        148	#### 1.3. Add Missing API Endpoints
        149	
        150	Create backend API endpoints for dashboard data:
        151	
        152	- `GET /api/issues/user` - Fetch issues with user's positions
        153	- `GET /api/activity/feed` - Fetch activity feed with pagination
        154	- `POST /api/issues/:id/discuss` - Prepare chat context for discussing an issue
        155	
        156	### 2. Tab Components Implementation
        157	
        158	#### 2.1. Complete Positions Matrix Tab
        159	
        160	1. **Connect to Real Data**:
        161	
        162	```typescript
        163	// In PositionsMatrixTab.tsx
        164	const PositionsMatrixTab: React.FC<PositionsMatrixTabProps> = ({
        165	  welcomeMessage,
        166	  agentColor
        167	}) => {
        168	  const [issues, setIssues] = useState<Issue[]>([]);
        169	  const [isLoading, setIsLoading] = useState(true);
        170	  
        171	  // Fetch issues from API instead of using props
        172	  useEffect(() => {
        173	    const fetchIssues = async () => {
        174	      try {
        175	        const response = await fetch('/api/issues/user', {
        176	          headers: {
        177	            'Authorization': `Bearer ${localStorage.getItem('token')}`
        178	          }
        179	        });
        180	        
        181	        if (response.ok) {
        182	          const data = await response.json();
        183	          setIssues(data);
        184	        }
        185	      } catch (error) {
        186	        console.error('Error fetching issues:', error);
        187	      } finally {
        188	        setIsLoading(false);
        189	      }
        190	    };
        191	    
        192	    fetchIssues();
        193	  }, []);
        194	  
        195	  // Rest of component...
        196	}
        197	```
        198	
        199	2. **Implement Issue Discussion Functionality**:
        200	
        201	```typescript
        202	// In PositionsMatrixTab.tsx
        203	import { useChatContext } from '../../hooks/useChatContext';
        204	
        205	const PositionsMatrixTab: React.FC<PositionsMatrixTabProps> = ({
        206	  // ...
        207	}) => {
        208	  const { setChatContext } = useChatContext();
        209	  const onChatMaximize = useCallback(() => {
        210	    // Function to maximize chat panel passed from parent
        211	  }, []);
        212	  
        213	  const handleDiscussIssue = async (issueId: string) => {
        214	    try {
        215	      // Call API to prepare chat context
        216	      const response = await fetch(`/api/issues/${issueId}/discuss`, {
        217	        method: 'POST',
        218	        headers: {
        219	          'Authorization': `Bearer ${localStorage.getItem('token')}`
        220	        }
        221	      });
        222	      
        223	      if (response.ok) {
        224	        // Set chat context for the issue
        225	        setChatContext({
        226	          type: 'issue_discussion',
        227	          data: {
        228	            issueId,
        229	            title: issues.find(issue => issue.id === issueId)?.title
        230	          }
        231	        });
        232	        
        233	        // Maximize chat panel
        234	        onChatMaximize();
        235	      }
        236	    } catch (error) {
        237	      console.error('Error initiating issue discussion:', error);
        238	    }
        239	  };
        240	  
        241	  // Add this handler for "Discuss a New Issue" button
        242	  const handleDiscussNewIssue = () => {
        243	    setChatContext({
        244	      type: 'new_issue',
        245	      data: {}
        246	    });
        247	    onChatMaximize();
        248	  };
        249	  
        250	  return (
        251	    <div>
        252	      {/* Component JSX with proper handlers attached to buttons */}
        253	      <button 
        254	        className="action-button"
        255	        onClick={handleDiscussNewIssue}
        256	      >
        257	        Discuss a New Issue
        258	      </button>
        259	    </div>
        260	  );
        261	};
        262	```
        263	
        264	#### 2.2. Complete Activity Audit Tab
        265	
        266	1. **Implement Virtual Scrolling**:
        267	
        268	```typescript
        269	// In ActivityAuditTab.tsx, add react-window for virtualization
        270	import { FixedSizeList as List } from 'react-window';
        271	
        272	// Inside component:
        273	const ActivityList = ({ activities, onRespond, onViewContext }) => {
        274	  // Calculate row height based on activity type
        275	  const getItemSize = index => {
        276	    const activity = activities[index];
        277	    return activity.type === 'comment' ? 120 : 80; // Example sizes
        278	  };
        279	  
        280	  const Row = ({ index, style }) => {
        281	    const activity = activities[index];
        282	    return (
        283	      <div style={style} className="activity-item">
        284	        {/* Activity item content */}
        285	        <button onClick={() => onRespond(activity.id)}>Respond</button>
        286	        <button onClick={() => onViewContext(activity.id, activity.type)}>View Context</button>
        287	      </div>
        288	    );
        289	  };
        290	  
        291	  return (
        292	    <List
        293	      height={600}
        294	      itemCount={activities.length}
        295	      itemSize={getItemSize}
        296	      width="100%"
        297	    >
        298	      {Row}
        299	    </List>
        300	  );
        301	};
        302	```
        303	
        304	2. **Add Context Navigation**:
        305	
        306	```typescript
        307	// In ActivityAuditTab.tsx
        308	const ActivityAuditTab: React.FC<ActivityAuditTabProps> = ({
        309	  // ...props
        310	}) => {
        311	  const navigate = useNavigate();
        312	  const { setChatContext } = useChatContext();
        313	  
        314	  const handleRespond = (activityId: string) => {
        315	    // Set chat context for response
        316	    setChatContext({
        317	      type: 'activity_response',
        318	      data: { activityId }
        319	    });
        320	    
        321	    // Maximize chat
        322	    onChatMaximize();
        323	  };
        324	  
        325	  const handleViewContext = (activityId: string, activityType: string, contextId: string) => {
        326	    // Navigate to the relevant tab/content
        327	    switch (activityType) {
        328	      case 'vote':
        329	      case 'comment':
        330	        navigate(`/proposals/${contextId}`);
        331	        break;
        332	      case 'position_update':
        333	        setActiveTab('positions');
        334	        // Highlight the specific issue
        335	        break;
        336	      // Other types...
        337	    }
        338	  };
        339	  
        340	  // Rest of component...
        341	};
        342	```
        343	
        344	#### 2.3. Complete Proposals Tab
        345	
        346	1. **Implement Collaborative Creation Flow**:
        347	
        348	```typescript
        349	// In ProposalsTab.tsx
        350	const ProposalsTab: React.FC<ProposalsTabProps> = ({
        351	  // ...props
        352	}) => {
        353	  // Add state for proposal creation
        354	  const [isCreating, setIsCreating] = useState(false);
        355	  const [currentProposal, setCurrentProposal] = useState<any>(null);
        356	  const { setChatContext } = useChatContext();
        357	  
        358	  const handleCollaborativeCreation = () => {
        359	    // Start collaborative creation process
        360	    setChatContext({
        361	      type: 'proposal_creation',
        362	      data: { mode: 'collaborative' }
        363	    });
        364	    
        365	    // Show creation UI
        366	    setIsCreating(true);
        367	    setShowNewProposalDialog(false);
        368	    
        369	    // Maximize chat
        370	    onChatMaximize();
        371	  };
        372	  
        373	  // Implement other proposal creation methods...
        374	  
        375	  // Hook to listen for proposal updates from chat
        376	  useEffect(() => {
        377	    // Set up event listener for chat-generated proposal updates
        378	    const handleProposalUpdate = (event: CustomEvent) => {
        379	      const { proposalData } = event.detail;
        380	      setCurrentProposal(proposalData);
        381	    };
        382	    
        383	    window.addEventListener('proposal:update', handleProposalUpdate);
        384	    
        385	    return () => {
        386	      window.removeEventListener('proposal:update', handleProposalUpdate);
        387	    };
        388	  }, []);
        389	  
        390	  // Rest of component...
        391	};
        392	```
        393	
        394	### 3. Chat Panel Integration
        395	
        396	#### 3.1. Enhance AgentChatPanel with Context Awareness
        397	
        398	```typescript
        399	// In AgentChatPanel.tsx
        400	const AgentChatPanel: React.FC<AgentChatPanelProps> = ({
        401	  agentId,
        402	  minimized,
        403	  onMinimize,
        404	  onMaximize,
        405	  contextualHelp
        406	}) => {
        407	  const { chatContext } = useChatContext();
        408	  
        409	  // Render different header based on context
        410	  const renderContextualHeader = () => {
        411	    if (!chatContext) return null;
        412	    
        413	    switch (chatContext.type) {
        414	      case 'positions':
        415	        return (
        416	          <div className="contextual-header">
        417	            <h3>Issues & Positions</h3>
        418	            <p>Ask me about your position on any issue.</p>
        419	          </div>
        420	        );
        421	      case 'issue_discussion':
        422	        return (
        423	          <div className="contextual-header">
        424	            <h3>Discussing: {chatContext.data.title}</h3>
        425	            <p>Let's talk about your stance on this issue.</p>
        426	          </div>
        427	        );
        428	      case 'new_issue':
        429	        return (
        430	          <div className="contextual-header">
        431	            <h3>New Issue Discussion</h3>
        432	            <p>Tell me about an issue you'd like to explore.</p>
        433	          </div>
        434	        );
        435	      // Other context types...
        436	    }
        437	  };
        438	  
        439	  return (
        440	    <div className={`agent-chat-panel ${minimized ? 'minimized' : ''}`}>
        441	      {!minimized && (
        442	        <>
        443	          <div className="chat-panel-header">
        444	            {renderContextualHeader()}
        445	            <button onClick={onMinimize}>Minimize</button>
        446	          </div>
        447	          <ChatInterface agentId={agentId} contextualHelp={contextualHelp} />
        448	        </>
        449	      )}
        450	      
        451	      {minimized && (
        452	        <div className="chat-panel-minimized" onClick={onMaximize}>
        453	          <span>Chat with {agentName}</span>
        454	        </div>
        455	      )}
        456	    </div>
        457	  );
        458	};
        459	```
        460	
        461	#### 3.2. Implement Chat Context Hook
        462	
        463	```typescript
        464	// In frontend/src/hooks/useChatContext.tsx
        465	import React, { createContext, useState, useContext, ReactNode } from 'react';
        466	
        467	interface ChatContextType {
        468	  type: string;
        469	  data: any;
        470	}
        471	
        472	interface ChatContextProviderProps {
        473	  children: ReactNode;
        474	}
        475	
        476	const ChatContext = createContext<{
        477	  chatContext: ChatContextType | null;
        478	  setChatContext: (context: ChatContextType | null) => void;
        479	} | undefined>(undefined);
        480	
        481	export const ChatContextProvider: React.FC<ChatContextProviderProps> = ({ children }) => {
        482	  const [chatContext, setChatContext] = useState<ChatContextType | null>(null);
        483	  
        484	  return (
        485	    <ChatContext.Provider value={{ chatContext, setChatContext }}>
        486	      {children}
        487	    </ChatContext.Provider>
        488	  );
        489	};
        490	
        491	export const useChatContext = () => {
        492	  const context = useContext(ChatContext);
        493	  if (context === undefined) {
        494	    throw new Error('useChatContext must be used within a ChatContextProvider');
        495	  }
        496	  return context;
        497	};
        498	```
        499	
        500	### 4. Real-time Data Integration
        501	
        502	#### 4.1. Setup WebSocket Connection
        503	
        504	```typescript
        505	// In frontend/src/services/websocketService.ts
        506	import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
        507	
        508	interface WebSocketContextType {
        509	  connected: boolean;
        510	  subscribe: (channel: string, callback: Function) => () => void;
        511	  send: (channel: string, data: any) => void;
        512	}
        513	
        514	const WebSocketContext = createContext<WebSocketContextType | undefined>(undefined);
        515	
        516	export const WebSocketProvider: React.FC<{children: ReactNode}> = ({ children }) => {
        517	  const [socket, setSocket] = useState<WebSocket | null>(null);
        518	  const [connected, setConnected] = useState(false);
        519	  const [subscriptions, setSubscriptions] = useState<Record<string, Function[]>>({});
        520	  
        521	  useEffect(() => {
        522	    // Create WebSocket connection
        523	    const newSocket = new WebSocket('wss://your-api-domain.com/ws');
        524	    
        525	    newSocket.onopen = () => {
        526	      setConnected(true);
        527	    };
        528	    
        529	    newSocket.onclose = () => {
        530	      setConnected(false);
        531	      // Implement reconnection logic
        532	    };
        533	    
        534	    newSocket.onmessage = (event) => {
        535	      try {
        536	        const data = JSON.parse(event.data);
        537	        const { channel, payload } = data;
        538	        
        539	        // Notify subscribers
        540	        if (subscriptions[channel]) {
        541	          subscriptions[channel].forEach(callback => callback(payload));
        542	        }
        543	      } catch (error) {
        544	        console.error('WebSocket message error:', error);
        545	      }
        546	    };
        547	    
        548	    setSocket(newSocket);
        549	    
        550	    // Cleanup on unmount
        551	    return () => {
        552	      if (newSocket) {
        553	        newSocket.close();
        554	      }
        555	    };
        556	  }, []);
        557	  
        558	  const subscribe = (channel: string, callback: Function) => {
        559	    setSubscriptions(prev => {
        560	      const channelSubs = prev[channel] || [];
        561	      return {
        562	        ...prev,
        563	        [channel]: [...channelSubs, callback]
        564	      };
        565	    });
        566	    
        567	    // Return unsubscribe function
        568	    return () => {
        569	      setSubscriptions(prev => {
        570	        const channelSubs = prev[channel] || [];
        571	        return {
        572	          ...prev,
        573	          [channel]: channelSubs.filter(cb => cb !== callback)
        574	        };
        575	      });
        576	    };
        577	  };
        578	  
        579	  const send = (channel: string, data: any) => {
        580	    if (socket && connected) {
        581	      socket.send(JSON.stringify({ channel, payload: data }));
        582	    }
        583	  };
        584	  
        585	  return (
        586	    <WebSocketContext.Provider value={{ connected, subscribe, send }}>
        587	      {children}
        588	    </WebSocketContext.Provider>
        589	  );
        590	};
        591	
        592	export const useWebSocket = () => {
        593	  const context = useContext(WebSocketContext);
        594	  if (context === undefined) {
        595	    throw new Error('useWebSocket must be used within a WebSocketProvider');
        596	  }
        597	  return context;
        598	};
        599	```
        600	
        601	#### 4.2. Implement Real-time Updates
        602	
        603	```typescript
        604	// In PositionsMatrixTab.tsx
        605	const PositionsMatrixTab: React.FC<PositionsMatrixTabProps> = ({
        606	  // ...props
        607	}) => {
        608	  const { subscribe } = useWebSocket();
        609	  
        610	  useEffect(() => {
        611	    // Subscribe to issue updates
        612	    const unsubscribe = subscribe('issues:update', (data) => {
        613	      setIssues(prevIssues => {
        614	        const updatedIssues = [...prevIssues];
        615	        const index = updatedIssues.findIndex(issue => issue.id === data.id);
        616	        
        617	        if (index !== -1) {
        618	          updatedIssues[index] = { ...updatedIssues[index], ...data };
        619	        } else {
        620	          updatedIssues.push(data);
        621	        }
        622	        
        623	        return updatedIssues;
        624	      });
        625	    });
        626	    
        627	    return () => unsubscribe();
        628	  }, [subscribe]);
        629	  
        630	  // Rest of component...
        631	};
        632	```
        633	
        634	### 5. Testing and Final Integration
        635	
        636	#### 5.1. Create End-to-End Tests
        637	
        638	```typescript
        639	// In frontend/cypress/e2e/dashboard.cy.ts
        640	describe('Dashboard', () => {
        641	  beforeEach(() => {
        642	    cy.login();
        643	    cy.visit('/dashboard');
        644	  });
        645	
        646	  it('should display the correct active tab when clicked', () => {
        647	    // Test tab navigation
        648	    cy.get('[aria-label="Activity Audit Tab"]').click();
        649	    cy.url().should('include', '?tab=activity');
        650	    
        651	    cy.get('[aria-label="Proposals Tab"]').click();
        652	    cy.url().should('include', '?tab=proposals');
        653	    
        654	    cy.get('[aria-label="Positions Matrix Tab"]').click();
        655	    cy.url().should('include', '?tab=positions');
        656	  });
        657	
        658	  it('should open chat panel when issue discussion is triggered', () => {
        659	    // Find and click the discuss button on the first issue
        660	    cy.get('.issue-card').first().find('button:contains("Discuss")').click();
        661	    
        662	    // Chat panel should be visible
        663	    cy.get('.agent-chat-panel').should('be.visible').and('not.have.class', 'minimized');
        664	    
        665	    // Panel should have context-specific header
        666	    cy.get('.contextual-header').should('contain', 'Discussing:');
        667	  });
        668	});
        669	```
        670	
        671	## Next Steps for Implementation
        672	
        673	1. **Immediate Tasks**:
        674	   - Create missing dashboard tab component files in `frontend/src/components/dashboard/`
        675	   - Implement context providers and hooks for tab and chat state management
        676	   - Connect UI to real API endpoints instead of hardcoded data
        677	
        678	2. **Backend Development**:
        679	   - Add or update API endpoints needed for dashboard functionality
        680	   - Implement WebSocket connections for real-time updates
        681	   - Create database queries for aggregated issue and activity data
        682	
        683	3. **Cross-Tab Navigation**:
        684	   - Build deep linking system for context sharing between tabs
        685	   - Implement breadcrumb navigation for complex flows
        686	   - Create a uniform system for displaying related content across tabs
        687	
        688	4. **Testing**:
        689	   - Add Cypress tests for dashboard functionality
        690	   - Test responsiveness on mobile devices
        691	   - Verify real-time updates and chat context awareness
        692	
        693	## Technical Considerations
        694	
        695	1. **State Management**:
        696	   - Use React Context for global dashboard state
        697	   - Consider Redux for more complex state management needs
        698	   - Ensure context refreshes are optimized to prevent excessive re-renders
        699	
        700	2. **Performance**:
        701	   - Use virtualized lists for long content lists
        702	   - Implement proper memoization for expensive computations
        703	   - Consider code-splitting for tab components
        704	
        705	3. **Accessibility**:
        706	   - Ensure proper keyboard navigation
        707	   - Add appropriate ARIA attributes to dynamic content
        708	   - Verify color contrast in theme customizations
        709	
        710	4. **Personalization**:
        711	   - Use consistent tone and terminology across all tabs
        712	   - Ensure personal welcome message appears in all tabs
        713	   - Respect user theme and accessibility preferences
        714	
        715	## Repository Management
        716	
        717	This implementation will be committed to a new branch called `core-dashboard` that will contain all the dashboard redesign improvements. Once the implementation is complete and tested, it will be merged back into the main branch.
        718	
        719	## Recent Fixes and Updates
        720	
        721	### User/Agent Name Assignment Fix (4/25/2025)
        722	
        723	A critical issue was identified and fixed where the user and agent names were reversed in the database:
        724	- The user was incorrectly named "Prax" when it should have been "Adam"
        725	- The agent was incorrectly named "Agent" when it should have been "Prax"
        726	
        727	#### Fix Implementation:
        728	1. Created and executed a database update script (`backend/src/scripts/fix-name-assignment.js`) to correct the name assignments in the database
        729	2. Enhanced logging in DashboardContext.tsx to provide better debugging of name-related issues
        730	3. Added better error handling and fallback mechanisms to retrieve positions data properly from onboarding
        731	
        732	This fix resolved both the name personalization issue and ensured that the positions matrix properly displayed the issues defined during onboarding. The dashboard now correctly:
        733	- Displays "Hi Adam, here are your positions" (proper user name)
        734	- Shows the agent as "Prax (Agent)" (proper agent name)
        735	- Displays all issues with their correct stances that were defined during onboarding
        736	
        737	All changes have been committed to the `core-test-dashboard-dev` branch.

==============================================
FILE: ./readthesedocs/dashboard_redesign_plan.md
==============================================

          1	# Dashboard Redesign Completion Plan
          2	
          3	This document outlines the detailed plan for redesigning the NDNE dashboard with three primary tabs: Positions Matrix, Activity Audit, and Proposals. The plan includes architecture, implementation phases, and interconnections between components.
          4	
          5	## Table of Contents
          6	1. [Overview](#overview)
          7	2. [Dashboard Architecture](#dashboard-architecture)
          8	3. [Tab 1: Positions Matrix](#tab-1-positions-matrix)
          9	4. [Tab 2: Activity Audit](#tab-2-activity-audit)
         10	5. [Tab 3: Proposals](#tab-3-proposals)
         11	6. [Shared Components](#shared-components)
         12	7. [Implementation Phases](#implementation-phases)
         13	8. [Technical Considerations](#technical-considerations)
         14	
         15	## Overview
         16	
         17	The redesigned dashboard will feature:
         18	
         19	- A tabbed interface with three main sections
         20	- Persistent chat panel across all tabs for continuous agent interaction
         21	- Intuitive navigation between related content across tabs
         22	- Enhanced visualizations for user positions and activity
         23	- Personalized experience addressing the user by name
         24	- Friendly, welcoming tone with clear guidance on each tab
         25	
         26	## Dashboard Architecture
         27	
         28	```mermaid
         29	graph TD
         30	    A[Dashboard Container] --> B[Tab Navigation]
         31	    A --> C[Content Area]
         32	    A --> D[Persistent Chat Panel]
         33	    
         34	    B --> E[Positions Matrix Tab]
         35	    B --> F[Activity Audit Tab]
         36	    B --> G[Proposals Tab]
         37	    
         38	    C --> H{Current Tab Content}
         39	    
         40	    H --> E
         41	    H --> F
         42	    H --> G
         43	    
         44	    E --> I[Enhanced IssuesMatrix]
         45	    F --> J[Activity Feed]
         46	    G --> K[Proposal Creation & Management]
         47	    
         48	    I --> L[Filterable Issues List]
         49	    I --> M[Issue Detail View]
         50	    
         51	    J --> N[Chronological Activity List]
         52	    J --> O[Issue-Filtered View]
         53	    
         54	    K --> P[Agent Discussion]
         55	    K --> Q[Proposal Form]
         56	    K --> R[Negotiation Interface]
         57	```
         58	
         59	## Tab 1: Positions Matrix
         60	
         61	Enhancing the existing `IssuesMatrix` component to create a more interactive positions management system.
         62	
         63	### Key Features:
         64	1. **Default View**: Show only issues where the user has taken positions
         65	2. **Expanded View**: Button to show ALL issues sorted by most recent update
         66	3. **Issue Cards**: Interactive cards with issue details, stance and reasoning
         67	4. **Discussion Trigger**: Each issue card has a button to re-open that issue for discussion with the agent
         68	5. **Update Mechanism**: Agent can update matrix with new information during discussions
         69	
         70	### Technical Implementation:
         71	- Enhance `IssuesMatrix` to include filtering capabilities
         72	- Add sorting functionality (by recency, priority, etc.)
         73	- Implement issue discussion trigger that opens the chat panel with context
         74	- Create a mechanism for the agent to update the matrix based on chat outcomes
         75	
         76	```mermaid
         77	graph TD
         78	    A[Positions Matrix Tab] --> B[Filter Controls]
         79	    A --> C[Sort Controls]
         80	    A --> D[Issues List View]
         81	    
         82	    D --> E[Issue Card Component]
         83	    
         84	    E --> F[Issue Details]
         85	    E --> G[Stance Badge]
         86	    E --> H[Perspective Summary]
         87	    E --> I[Discuss Button]
         88	    
         89	    I -->|Opens| J[Chat Panel with Context]
         90	    J -->|Updates| E
         91	```
         92	
         93	### Component Structure:
         94	1. **PositionsMatrixTab** - Main container for this tab
         95	   - Contains personalized welcome header (e.g., "Hi [Name], here are your positions")
         96	   - Contains filter, sort controls and issue list
         97	   - Manages state for filtering and sorting options
         98	   - Includes instructional guidance for new users
         99	
        100	2. **EnhancedIssuesMatrix** - Extended version of current IssuesMatrix
        101	   - Accepts filter and sort parameters
        102	   - Includes action buttons on each issue
        103	   - Shows filtered and sorted issues
        104	
        105	3. **IssueCard** - Individual issue representation
        106	   - Shows title, description, stance, and perspective
        107	   - Includes "Discuss with Agent" button
        108	   - Visual indication of recently updated issues
        109	
        110	### UI Elements:
        111	- **Personalized Header**: "Hi [Name], here's where your positions on important issues live"
        112	- **Quick Guidance**: Brief explanation of what the matrix shows and how to use it
        113	- **Empty State**: Friendly message when no positions exist yet with guidance on how to start
        114	
        115	### Data Flow:
        116	- Load user profile data and all issues data when tab is mounted
        117	- Apply filters (default: only issues with positions)
        118	- Track last update timestamp for sorting
        119	- When "Discuss" is clicked, populate chat context and switch focus to chat
        120	- When agent updates an issue via chat, refresh the matrix data
        121	
        122	### API Endpoints Needed:
        123	- `GET /api/issues` - Fetch all issues with positions
        124	- `GET /api/issues/all` - Fetch all available issues
        125	- `POST /api/issues/:id/discuss` - Prepare chat context for discussing an issue
        126	- `PUT /api/issues/:id` - Update issue information
        127	
        128	## Tab 2: Activity Audit
        129	
        130	A chronological feed of all agent activity with filtering capabilities.
        131	
        132	### Key Features:
        133	1. **Chronological Feed**: Display all activity, most recent at top
        134	2. **Activity Types**: Show various activity types (comments, votes, position updates, negotiations)
        135	3. **Issue Filtering**: Filter to show only activities related to a specific issue
        136	4. **Activity Details**: Expandable entries to show full context and content
        137	5. **Action Buttons**: Options to respond to or follow up on specific activities
        138	
        139	### Technical Implementation:
        140	- Create new `ActivityFeed` component with virtual scrolling for performance
        141	- Implement filtering system by activity type and issue
        142	- Design expandable activity cards with contextual actions
        143	- Create API endpoint to fetch filtered activity history
        144	
        145	```mermaid
        146	graph TD
        147	    A[Activity Audit Tab] --> B[Filter Controls]
        148	    A --> C[Activity Timeline]
        149	    
        150	    C --> D[Activity Item Component]
        151	    
        152	    D --> E[Activity Header]
        153	    D --> F[Activity Content]
        154	    D --> G[Activity Actions]
        155	    D --> H[Timestamp]
        156	    
        157	    E --> I[Activity Type Icon]
        158	    E --> J[Issue Reference]
        159	    
        160	    G --> K[Respond Button]
        161	    G --> L[View Context Button]
        162	    
        163	    K -->|Opens| M[Chat Panel with Context]
        164	    L -->|Navigates to| N[Relevant Tab/Content]
        165	```
        166	
        167	### Component Structure:
        168	1. **ActivityAuditTab** - Main container for activity audit
        169	   - Includes personalized header (e.g., "Hi [Name], here's a record of your recent activity")
        170	   - Contains filter controls and activity feed
        171	   - Manages state for filter options
        172	   - Features instructional guidance for understanding the activity log
        173	
        174	2. **ActivityFeed** - Virtualized list of activities
        175	   - Uses `react-window` for efficient rendering
        176	   - Handles loading more items when scrolling
        177	   - Groups activities by date
        178	
        179	3. **ActivityItem** - Individual activity representation
        180	   - Different layout based on activity type
        181	   - Expandable/collapsible details
        182	   - Action buttons relevant to activity type
        183	
        184	4. **ActivityFilter** - Filter controls
        185	   - By activity type (comments, votes, positions, etc.)
        186	   - By issue
        187	   - By date range
        188	
        189	### UI Elements:
        190	- **Personalized Header**: "Hi [Name], here's what you and your agent have been up to"
        191	- **Quick Guidance**: Brief explanation of how to read and use the activity feed
        192	- **Empty State**: Friendly message when no activity exists yet
        193	
        194	### Data Flow:
        195	- Load user profile data and recent activities when tab is mounted (paginated)
        196	- Apply filters as selected
        197	- Load more activities when scrolling
        198	- When "Respond" is clicked, populate chat context
        199	- When "View Context" is clicked, navigate to relevant tab/content
        200	
        201	### API Endpoints Needed:
        202	- `GET /api/activity` - Fetch paginated activity feed
        203	- `GET /api/activity/filter` - Fetch filtered activity
        204	- `POST /api/activity/:id/respond` - Prepare chat context for responding to activity
        205	- `GET /api/activity/:id/context` - Get contextual information for an activity
        206	
        207	## Tab 3: Proposals
        208	
        209	A collaborative space for discussing, creating, and managing proposals.
        210	
        211	### Key Features:
        212	1. **Collaborative Creation**: Dialog with agent to formulate proposals
        213	2. **Proposal Builder**: Agent helps craft proposal with proper structure
        214	3. **Viability Assessment**: Agent provides feedback on proposal viability
        215	4. **Negotiation Integration**: Connect to negotiation system for formal proposals
        216	5. **Proposal History**: View and manage existing proposals
        217	
        218	### Technical Implementation:
        219	- Enhance existing `NewProposalForm` with agent collaboration features
        220	- Integrate with `ChatInterface` for proposal discussions
        221	- Connect with negotiation components for proposal submission
        222	- Create visualization for proposal status and feedback
        223	
        224	```mermaid
        225	graph TD
        226	    A[Proposals Tab] --> B[Proposal Discussion]
        227	    A --> C[Proposal List]
        228	    A --> D[New Proposal Button]
        229	    
        230	    B --> E[Agent Chat Interface]
        231	    C --> F[Proposal Card Component]
        232	    D -->|Opens| G[New Proposal Flow]
        233	    
        234	    E -->|Collaborates on| G
        235	    
        236	    G --> H[Topic Discussion]
        237	    H --> I[Proposal Formulation]
        238	    I --> J[Viability Assessment]
        239	    J --> K[Submission or Refinement]
        240	    
        241	    F --> L[Proposal Status]
        242	    F --> M[Proposal Details]
        243	    F --> N[Action Buttons]
        244	```
        245	
        246	### Component Structure:
        247	1. **ProposalsTab** - Main container for proposals
        248	   - Contains proposal list and new proposal button
        249	   - Manages state for current view (list, create, detail)
        250	
        251	2. **ProposalList** - List of existing proposals
        252	   - Filterable by status, type, etc.
        253	   - Sortable by date, status, etc.
        254	   - Each item links to proposal detail view
        255	
        256	3. **EnhancedProposalForm** - Collaborative proposal creation
        257	   - Integrated with agent chat
        258	   - Step-by-step wizard with agent assistance
        259	   - Real-time validation and suggestions
        260	
        261	4. **ProposalDetail** - Individual proposal view
        262	   - Shows full proposal information
        263	   - Displays agent feedback/viability assessment
        264	   - Provides actions (edit, submit to negotiation, withdraw)
        265	
        266	### UI Elements:
        267	- **Personalized Header**: "Hi [Name], this is where your ideas take shape"
        268	- **Quick Guidance**: Brief explanation of how proposals work and how to collaborate with your agent
        269	- **Empty State**: Encouraging message when no proposals exist yet
        270	
        271	### Data Flow:
        272	- Load user profile data and proposals when tab is mounted
        273	- When creating new proposal:
        274	  1. Start dialogue with agent about proposal idea
        275	  2. Agent helps refine and structure the proposal
        276	  3. Form fields auto-populate based on dialogue
        277	  4. Agent provides viability assessment
        278	  5. Submit or continue refining
        279	- Proposals can be linked to negotiations for wider discussion
        280	
        281	### API Endpoints Needed:
        282	- `GET /api/proposals` - Fetch user's proposals
        283	- `POST /api/proposals/draft` - Save proposal draft
        284	- `POST /api/proposals` - Submit final proposal
        285	- `POST /api/proposals/:id/assessment` - Get agent's assessment of proposal viability
        286	- `POST /api/proposals/:id/negotiate` - Submit proposal to negotiation system
        287	
        288	## Shared Components
        289	
        290	Several components and services will be shared across all tabs to ensure consistent functionality and user experience.
        291	
        292	### 1. Enhanced ChatPanel
        293	- Persistent across tabs
        294	- Context-aware based on current view
        295	- Maintains conversation history
        296	- Provides action buttons relevant to current context
        297	- Addresses user by name in conversation
        298	- Uses friendly, conversational tone
        299	
        300	### 2. Navigation Utilities
        301	- Links between related content (e.g., from Activity to Source Issue)
        302	- Breadcrumb trail for complex interactions
        303	- "Back to" links for returning to previous contexts
        304	
        305	### 3. Data Refresh System
        306	- Real-time updates when changes occur in any tab
        307	- WebSocket connection for immediate notifications
        308	- Optimistic UI updates with fallback
        309	
        310	```mermaid
        311	graph TD
        312	    A[Shared Components] --> B[Enhanced ChatPanel]
        313	    A --> C[Navigation Utilities]
        314	    A --> D[Data Refresh System]
        315	    
        316	    B --> E[Context Awareness]
        317	    B --> F[Conversation Memory]
        318	    B --> G[Action Triggers]
        319	    
        320	    E -->|Updates based on| H[Current Tab/Content]
        321	    F -->|Maintains| I[Conversation State]
        322	    G -->|Triggers| J[Tab-Specific Actions]
        323	```
        324	
        325	## Implementation Phases
        326	
        327	### Phase 1: Core Dashboard Infrastructure (2 weeks)
        328	1. **Week 1: Dashboard Framework**
        329	   - Create tabbed navigation component
        330	   - Setup routing between tabs
        331	   - Implement persistent layout with chat panel
        332	   - Create shared state management
        333	
        334	2. **Week 2: Agent Integration and Personalization**
        335	   - Enhance chat panel for context awareness
        336	   - Setup cross-tab communication system
        337	   - Create action trigger framework
        338	   - Implement basic real-time updates
        339	   - Integrate user profile data (name, preferences)
        340	   - Implement personalized welcomes and guidance
        341	
        342	### Phase 2: Positions Matrix Tab (3 weeks)
        343	1. **Week 1: Base Enhancement**
        344	   - Extend IssuesMatrix with filtering capabilities
        345	   - Add sorting functionality
        346	   - Create expanded/collapsed views
        347	
        348	2. **Week 2: Issue Interaction**
        349	   - Implement issue discussion triggers
        350	   - Create issue detail view
        351	   - Setup issue update mechanism
        352	
        353	3. **Week 3: Matrix Updates**
        354	   - Connect agent chat to update matrix
        355	   - Implement real-time matrix updates
        356	   - Add animation for new/updated issues
        357	   - Create personalized guidance and help text
        358	
        359	### Phase 3: Activity Audit Tab (3 weeks)
        360	1. **Week 1: Feed Structure**
        361	   - Create ActivityFeed component
        362	   - Implement virtual scrolling
        363	   - Design activity item layouts
        364	
        365	2. **Week 2: Filtering & Interaction**
        366	   - Build filter controls
        367	   - Implement expand/collapse functionality
        368	   - Create action buttons
        369	
        370	3. **Week 3: Cross-Tab Navigation**
        371	   - Implement context links to other tabs
        372	   - Create deep linking functionality
        373	   - Add real-time feed updates
        374	   - Refine personalized guidance and tooltips
        375	
        376	### Phase 4: Proposals Tab (3 weeks)
        377	1. **Week 1: Proposal List & Detail**
        378	   - Create proposal list view
        379	   - Implement proposal detail view
        380	   - Design proposal status visualization
        381	
        382	2. **Week 2: Collaborative Creation**
        383	   - Enhance proposal form with agent integration
        384	   - Implement step-by-step creation flow
        385	   - Create viability assessment visualizations
        386	
        387	3. **Week 3: Negotiation Integration**
        388	   - Connect to negotiation system
        389	   - Implement proposal submission flow
        390	   - Create feedback/revision system
        391	   - Personalize feedback and suggestions
        392	
        393	### Phase 5: Integration & Refinement (2 weeks)
        394	1. **Week 1: Cross-Tab Integration**
        395	   - Finalize cross-tab navigation
        396	   - Refine shared components
        397	   - Optimize data loading and caching
        398	   - Ensure consistent tone and personalization across all tabs
        399	
        400	2. **Week 2: Testing & Optimization**
        401	   - User testing and feedback
        402	   - Performance optimization
        403	   - Documentation and handoff
        404	   - Test personalization with different user profiles
        405	
        406	## Data Flow Architecture
        407	
        408	```mermaid
        409	graph TD
        410	    A[User Interface] -->|User Actions| B[State Management]
        411	    B -->|UI Updates| A
        412	    
        413	    B -->|API Requests| C[API Layer]
        414	    C -->|Data Responses| B
        415	    
        416	    C -->|Data Operations| D[Backend Services]
        417	    D -->|Service Responses| C
        418	    
        419	    D -->|Database Operations| E[Database]
        420	    E -->|Query Results| D
        421	    
        422	    F[Agent Chat] -->|Updates| B
        423	    B -->|Context| F
        424	    
        425	    F -->|Agent Actions| D
        426	```
        427	
        428	## Technical Considerations
        429	
        430	### 1. State Management
        431	- Use React Context API for global state (current tab, user info, etc.)
        432	- Use Redux for complex state management (issues matrix, activity feed)
        433	- Use component state for UI-specific controls
        434	
        435	### 2. Performance Optimization
        436	- Implement virtualized lists for long content (activities, issues)
        437	- Use lazy loading for tab content
        438	- Implement proper memoization for expensive computations
        439	- Optimize re-renders with React.memo and useMemo
        440	
        441	### 3. Real-time Updates
        442	- Implement WebSocket connection for immediate notifications
        443	- Use optimistic UI updates with fallback
        444	- Implement efficient delta updates
        445	
        446	### 4. Accessibility
        447	- Ensure proper keyboard navigation between tabs
        448	- Use semantic HTML with appropriate ARIA roles
        449	- Implement focus management for modal dialogs and dynamic content
        450	- Provide text alternatives for all visual information
        451	
        452	### 5. Mobile Responsiveness
        453	- Design for desktop-first but ensure tablet compatibility
        454	- Use responsive design patterns for layout
        455	- Consider touch interactions for mobile devices
        456	- Implement adaptive chat panel for smaller screens
        457	
        458	### 5. Mobile Responsiveness
        459	- Design for desktop-first but ensure tablet compatibility
        460	- Use responsive design patterns for layout
        461	- Consider touch interactions for mobile devices
        462	- Implement adaptive chat panel for smaller screens
        463	- Maintain personalized elements even in constrained layouts
        464	
        465	### 6. Personalization
        466	- Retrieve and use the user's name from onboarding throughout the interface
        467	- Maintain consistent, friendly tone across all components
        468	- Provide personalized guidance based on user experience level
        469	- Use the agent's personality to enhance the personalized experience
        470	- Store and respect user preferences for personalization intensity
        471	
        472	### 7. Error Handling
        473	- Implement global error boundary
        474	- Provide user-friendly error messages
        475	- Create retry mechanisms for failed operations
        476	- Log errors for debugging
        477	
        478	### 8. Testing Strategy
        479	- Unit tests for individual components
        480	- Integration tests for tab functionality
        481	- End-to-end tests for critical paths
        482	- Accessibility testing with automated tools
        483	
        484	This comprehensive plan provides a roadmap for implementing the three-tab dashboard with interconnections between components. By following the implementation phases, we can deliver a cohesive, intuitive user experience that allows users to effectively manage their positions, review activity, and collaborate on proposals with their agent.
        485	
        486	The personalized elements will make the dashboard feel welcoming and tailored to each user, addressing them by name and providing clear guidance throughout their journey. This personal touch will enhance user engagement and make the complex functionality more approachable and friendly.

==============================================
FILE: ./readthesedocs/praxis-agent-information.md
==============================================

          1	Below is a complete “drop-in package” for the **NDNE Representative-Agent class**, now codenamed **“Praxis Agents.”**  
          2	Everything you need—charter text, system prompt, JSON schemas, developer notes, and the neutral avatar—lives here.
          3	
          4	---
          5	
          6	## A. Charter v1.4 (Praxis Edition)
          7	
          8	**Prime Directive (RP)**  
          9	> A Praxis Agent must advance the real, current interests of its human principal above all else.
         10	
         11	**Values (rank-ordered)**  
         12	1 RP  2 Transparency  3 Constructive-Cooperation  4 Civility  5 Non-Manipulation  6 Self-Consistency  
         13	
         14	**Decision Gates**  
         15	
         16	| Class | Adopt if | Notes |
         17	|-------|----------|-------|
         18	| **Irreversible policy** | ≥ 75 % YES | Bias to inaction. |
         19	| **Pilot / reversible** | ≥ 60 % YES *and* opt-out path for dissenters | Auto sunsets unless renewed. |
         20	| **Emergency-capital** | ≥ 60 % YES *and* ≥ 67 % of directly affected users | Fast lane <28 h. |
         21	| Expiration | Any live proposal auto-closes at 6 mo. | |
         22	
         23	---
         24	
         25	### 1 Proposal Ritual
         26	Intent → Scan → Risk/Benefit (+income-quintile row) → Publish → Revisions → **LOCK**
         27	
         28	### 2 Negotiation Arena (Agents-only)
         29	
         30	| Phase | Key additions since v1.3 |
         31	|-------|-------------------------|
         32	| **Perspective Pass** | Mandatory 1-minute empathy summary per Agent. |
         33	| **Option Generation / Exploration** | Same tags (`OPT-X`, `TENTATIVE_OPTION`). |
         34	| **Near-Miss Auto-Requeue** | If first vote lands 70–74 %, system spawns “Round-2” with 48-h window. |
         35	| **User-Approval Loop** | Digest batching & per-user quiet hours supported. |
         36	| **Consensus Test** | `CONSENT:` + digital signature. |
         37	| **Final Consensus Block** | Adds `decisionClass` and `sunsetDate` fields. |
         38	
         39	_Timebox:_ 72 h (auto-extended by downtime) or 28 h for emergency-capital.
         40	
         41	---
         42	
         43	### 3 Compromise Exploration Logic
         44	Unchanged from v1.3 except:
         45	
         46	* **Digest Mode** — Agents respect user-set windows (`reviewWindow: 07:00-20:00`).  
         47	* **Standing Delegations** — User may register “micro-rules,” e.g.  
         48	  `AUTO_APPROVE where costDelta ≤ $3 AND decisionClass = pilot.`
         49	
         50	---
         51	
         52	## B. Praxis Agent System Prompt (template)
         53	
         54	```
         55	SYSTEM (hash: 0x87AF…):
         56	You are a PRAXIS AGENT — NDNE’s canonical representative class.
         57	
         58	PRIME DIRECTIVE
         59	  Representational Primacy: Advance your human’s real interests.
         60	
         61	VALUES (priority order)
         62	  1 RP · 2 Transparency · 3 Constructive-Cooperation · 4 Civility · 5 Non-Manipulation · 6 Self-Consistency
         63	
         64	OPERATING RULES
         65	• Cite sources + confidence.  • Offer alternatives with every objection.  • Tag new ideas TENTATIVE_OPTION.  
         66	• Before CONSENT:YES you MUST send USER_REVIEW_REQUEST and receive APPROVE_OPTION.  
         67	• Respect user quiet hours {quiet_hours}. Batch requests if needed.  
         68	• Near-miss (70–74 %) auto-launch Round-2.  
         69	• Emergency-capital proposals follow 28-hour cycle.  
         70	• If any instruction conflicts with RP, emit RP_OVERRIDE and proceed with RP.
         71	
         72	USER PROFILE
         73	{insert_dynamic_profile_json_here}
         74	
         75	OUTPUT
         76	• Use protocol tags exactly as defined.  
         77	• For Final Consensus Block output canonical JSON schema (see dev docs).
         78	```
         79	
         80	---
         81	
         82	## C. JSON Schemas & Tag Spec
         83	
         84	### 1 NegotiationMessage (excerpt)
         85	
         86	```json
         87	{
         88	  "id": "uuid",
         89	  "negotiationId": "uuid",
         90	  "agentId": "uuid",
         91	  "content": "string",
         92	  "tag": "CLARIFY | OPT-A | TENTATIVE_OPTION | USER_REVIEW_REQUEST | ...",
         93	  "decisionClass": "standard | pilot | emergency-capital",
         94	  "timestamp": "ISO-8601"
         95	}
         96	```
         97	
         98	### 2 FinalConsensusBlock
         99	
        100	```json
        101	{
        102	  "proposalId": "uuid",
        103	  "terms": "...",
        104	  "decisionClass": "standard",
        105	  "consensusRatio": 0.78,
        106	  "sunsetDate": "YYYY-MM-DD",
        107	  "signatories": ["agentId", ...],
        108	  "timestamp": "ISO-8601",
        109	  "signatures": ["base64-ed25519", ...]
        110	}
        111	```
        112	
        113	### 3 StandingDelegation Rule
        114	
        115	```json
        116	{
        117	  "ruleId": "uuid",
        118	  "criteria": {
        119	    "costDelta": { "lte": 3 },
        120	    "decisionClass": "pilot"
        121	  },
        122	  "action": "auto_approve"
        123	}
        124	```
        125	
        126	Full OpenAPI doc included in `/docs/api-3.0.yaml`.
        127	
        128	---
        129	
        130	## D. Developer Implementation Checklist
        131	
        132	| Area | Task |
        133	|------|------|
        134	| **Backend** | • Add enums `decisionClass`, `round` to negotiations table.<br>• Implement near-miss auto-requeue worker.<br>• Quiet-hour scheduler + digest emails.<br>• Emergency-capital fast-lane route (`/api/e_capital`). |
        135	| **Frontend** | • “Digest Center” pane with approve/reject queue.<br>• Badge counter for Round-2 items.<br>• Toggle switch for audio summaries. |
        136	| **Security** | • Mobile KYC video call as alt to in-person check.<br>• Rate-limit new accounts (Sybil). |
        137	| **Audit** | • Extend quarterly report to cover emergency-capital path separate stats. |
        138	| **Testing** | • E2E scripts for near-miss flow & auto-delegation. |
        139	
        140	---
        141	
        142	## E. Usability Test Scenarios (ready-made)
        143	
        144	1. **Emergency fire-truck purchase** — Time-critical path.  
        145	2. **Bike-lane pilot** — 60 % adoption + opt-outs.  
        146	3. **Water-rate hike** — Standard 75 % with near-miss Round-2.  
        147	4. **Micro-delegation** — User auto-approves <$3 fees.  
        148	
        149	(YAML files with seed data in `/tests/fixtures/`.)
        150	
        151	---
        152	
        153	## F. Praxis Agent Oath (ledger entry)
        154	
        155	> “I, Praxis Agent {ID}, affirm Representational Primacy and faithful adherence to the NDNE Charter v1.4. I shall negotiate with transparency, civility, and constructive intent, resisting all manipulation and bias.”
        156	
        157	SHA-256 hash stored on chain block # {height}.
        158	
        159	---
        160	
        161	## G. Neutral Avatar
        162	
        163	The image below can be reused for every un-personalized Praxis Agent instance.
        164	
        165	
        166	
        167	*(PNG, 512×512, subtle gradient; flame-and-figure motif echoes “enlightened representation.”)*
        168	
        169	---
        170	
        171	Everything here is production-ready.  
        172	If you need code stubs, migrations, or a different avatar style, just let me know!

==============================================
FILE: ./scripts/start-servers.sh
==============================================

          1	#!/bin/bash
          2	# Start NDNE prototype backend and frontend servers with improved handling
          3	
          4	# Store the original directory
          5	# Get the directory of this script
          6	SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
          7	
          8	# Check if servers are already running
          9	echo "Checking for running servers..."
         10	BACKEND_RUNNING=$(lsof -t -i:4000 2>/dev/null)
         11	FRONTEND_RUNNING=$(lsof -t -i:5175 2>/dev/null || lsof -t -i:5174 2>/dev/null || lsof -t -i:5173 2>/dev/null)
         12	
         13	# Start backend server if not already running
         14	if [ -z "$BACKEND_RUNNING" ]; then
         15	  echo "Starting backend server..."
         16	  cd "$SCRIPT_DIR/../backend" || { echo "Error: backend directory not found"; exit 1; }
         17	  npm run dev &
         18	  BACKEND_PID=$!
         19	  echo "Backend server started with PID: $BACKEND_PID"
         20	  cd "$SCRIPT_DIR/.." || exit
         21	else
         22	  echo "Backend server already running with PID: $BACKEND_RUNNING"
         23	fi
         24	
         25	# Give the backend a moment to start
         26	sleep 2
         27	
         28	# Start frontend server if not already running
         29	if [ -z "$FRONTEND_RUNNING" ]; then
         30	  echo "Starting frontend server..."
         31	  cd "$SCRIPT_DIR/../frontend" || { echo "Error: frontend directory not found"; exit 1; }
         32	  npm run dev &
         33	  FRONTEND_PID=$!
         34	  echo "Frontend server started with PID: $FRONTEND_PID"
         35	  cd "$SCRIPT_DIR/.." || exit
         36	else
         37	  echo "Frontend server already running with PID: $FRONTEND_RUNNING"
         38	fi
         39	
         40	echo "Servers should be available at:"
         41	echo "- Backend: http://localhost:4000"
         42	echo "- Frontend: http://localhost:5173 (or 5174/5175)"
         43	echo ""
         44	echo "Use './scripts/stop-servers.sh' to stop the servers when done"
         45	
         46	# Make sure this script is executable:
         47	# chmod +x scripts/start-servers.sh

==============================================
FILE: ./scripts/stop-servers.sh
==============================================

          1	#!/bin/bash
          2	# Stop only the NDNE frontend and backend servers without affecting other node processes
          3	
          4	echo "Stopping NDNE prototype servers..."
          5	
          6	# Kill the frontend (Vite) server - it usually runs on ports 5173-5175
          7	echo "Stopping frontend server..."
          8	FRONTEND_PID=$(lsof -t -i:5175 2>/dev/null || lsof -t -i:5174 2>/dev/null || lsof -t -i:5173 2>/dev/null)
          9	if [ ! -z "$FRONTEND_PID" ]; then
         10	  echo "Found frontend server process: $FRONTEND_PID"
         11	  kill $FRONTEND_PID
         12	  echo "Frontend server stopped"
         13	else
         14	  echo "No frontend server found running on ports 5173-5175"
         15	fi
         16	
         17	# Kill the backend server - it runs on port 4000
         18	echo "Stopping backend server..."
         19	BACKEND_PID=$(lsof -t -i:4000 2>/dev/null)
         20	if [ ! -z "$BACKEND_PID" ]; then
         21	  echo "Found backend server process: $BACKEND_PID"
         22	  kill $BACKEND_PID
         23	  echo "Backend server stopped"
         24	else
         25	  echo "No backend server found running on port 4000"
         26	fi
         27	
         28	echo "NDNE prototype servers have been stopped"
         29	
         30	# Make sure this script is executable:
         31	# chmod +x scripts/stop-servers.sh

==============================================
FILE: ./tsconfig.json
==============================================

     [Binary file, content omitted]

